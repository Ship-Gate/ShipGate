#!/usr/bin/env npx tsx
/**
 * ISL Evidence PR Commenter
 * 
 * Posts or updates a PR comment with the ISL "ship score" and verification results.
 * Uses a unique marker to find and update existing comments on re-runs.
 * 
 * Usage:
 *   npx tsx scripts/github/commentEvidence.ts <evidence-report-path>
 * 
 * Environment Variables:
 *   GITHUB_TOKEN - GitHub token with PR write permissions
 *   GITHUB_REPOSITORY - Owner/repo format (e.g., "owner/repo")
 *   GITHUB_PR_NUMBER - Pull request number
 *   GITHUB_API_URL - Optional: GitHub API base URL (defaults to https://api.github.com)
 */

import { readFileSync } from 'node:fs';
import type {
  GitHubEnvConfig,
  GitHubComment,
  EvidenceReportInput,
  ClauseResultInput,
  CommentOptions,
  CommentResult,
} from './githubTypes.js';

// ============================================================================
// Constants
// ============================================================================

/** Unique marker to identify Vibecheck ISL comments for updates */
const COMMENT_MARKER = '<!-- VIBECHECK_ISL_REPORT -->';

/** Default options for comment generation */
const DEFAULT_OPTIONS: CommentOptions = {
  maxFailedClauses: 5,
  includeFullReport: true,
  footerText: '*This comment is automatically generated by Vibecheck ISL verification.*',
};

// ============================================================================
// Environment Configuration
// ============================================================================

/**
 * Parse environment variables into configuration
 */
function getEnvConfig(): GitHubEnvConfig {
  const token = process.env['GITHUB_TOKEN'];
  if (!token) {
    throw new Error('GITHUB_TOKEN environment variable is required');
  }

  const repository = process.env['GITHUB_REPOSITORY'];
  if (!repository) {
    throw new Error('GITHUB_REPOSITORY environment variable is required (format: owner/repo)');
  }

  const [owner, repo] = repository.split('/');
  if (!owner || !repo) {
    throw new Error('GITHUB_REPOSITORY must be in format owner/repo');
  }

  const prNumberStr = process.env['GITHUB_PR_NUMBER'] || process.env['PR_NUMBER'];
  if (!prNumberStr) {
    throw new Error('GITHUB_PR_NUMBER environment variable is required');
  }

  const prNumber = parseInt(prNumberStr, 10);
  if (isNaN(prNumber) || prNumber <= 0) {
    throw new Error('GITHUB_PR_NUMBER must be a positive integer');
  }

  const apiBaseUrl = process.env['GITHUB_API_URL'] || 'https://api.github.com';

  return { token, owner, repo, prNumber, apiBaseUrl };
}

// ============================================================================
// GitHub API Functions
// ============================================================================

/**
 * Make a GitHub API request
 */
async function githubRequest<T>(
  config: GitHubEnvConfig,
  method: string,
  path: string,
  body?: unknown
): Promise<T> {
  const url = `${config.apiBaseUrl}${path}`;
  
  const response = await fetch(url, {
    method,
    headers: {
      'Accept': 'application/vnd.github+json',
      'Authorization': `Bearer ${config.token}`,
      'X-GitHub-Api-Version': '2022-11-28',
      'Content-Type': 'application/json',
    },
    body: body ? JSON.stringify(body) : undefined,
  });

  if (!response.ok) {
    const error = await response.text();
    throw new Error(`GitHub API error (${response.status}): ${error}`);
  }

  return response.json() as Promise<T>;
}

/**
 * List all comments on a PR
 */
async function listPRComments(config: GitHubEnvConfig): Promise<GitHubComment[]> {
  const path = `/repos/${config.owner}/${config.repo}/issues/${config.prNumber}/comments`;
  return githubRequest<GitHubComment[]>(config, 'GET', path);
}

/**
 * Create a new comment on a PR
 */
async function createComment(config: GitHubEnvConfig, body: string): Promise<GitHubComment> {
  const path = `/repos/${config.owner}/${config.repo}/issues/${config.prNumber}/comments`;
  return githubRequest<GitHubComment>(config, 'POST', path, { body });
}

/**
 * Update an existing comment
 */
async function updateComment(
  config: GitHubEnvConfig,
  commentId: number,
  body: string
): Promise<GitHubComment> {
  const path = `/repos/${config.owner}/${config.repo}/issues/comments/${commentId}`;
  return githubRequest<GitHubComment>(config, 'PATCH', path, { body });
}

/**
 * Find existing Vibecheck ISL comment by marker
 */
async function findExistingComment(config: GitHubEnvConfig): Promise<GitHubComment | null> {
  const comments = await listPRComments(config);
  return comments.find(c => c.body.includes(COMMENT_MARKER)) || null;
}

// ============================================================================
// Report Loading & Validation
// ============================================================================

/**
 * Load evidence report from JSON file
 */
function loadEvidenceReport(filePath: string): EvidenceReportInput {
  try {
    const content = readFileSync(filePath, 'utf-8');
    const report = JSON.parse(content) as EvidenceReportInput;
    
    // Basic validation
    if (!report.scoreSummary) {
      throw new Error('Missing scoreSummary in evidence report');
    }
    if (!report.clauseResults) {
      report.clauseResults = [];
    }
    
    return report;
  } catch (error) {
    if (error instanceof Error && error.message.includes('ENOENT')) {
      throw new Error(`Evidence report file not found: ${filePath}`);
    }
    throw error;
  }
}

// ============================================================================
// Comment Generation
// ============================================================================

/**
 * Get emoji for recommendation
 */
function getRecommendationEmoji(recommendation: string): string {
  switch (recommendation) {
    case 'ship': return '✅';
    case 'review': return '⚠️';
    case 'block': return '❌';
    default: return '❓';
  }
}

/**
 * Get verdict label from recommendation
 */
function getVerdictLabel(recommendation: string): string {
  switch (recommendation) {
    case 'ship': return 'SHIP';
    case 'review': return 'REVIEW';
    case 'block': return 'NO_SHIP';
    default: return 'UNKNOWN';
  }
}

/**
 * Format a clause location as a string
 */
function formatLocation(clause: ClauseResultInput): string {
  if (!clause.location) return '';
  const { file, line, column } = clause.location;
  if (!file) return '';
  let loc = file;
  if (line !== undefined) {
    loc += `:${line}`;
    if (column !== undefined) {
      loc += `:${column}`;
    }
  }
  return loc;
}

/**
 * Generate the PR comment body from an evidence report
 */
function generateCommentBody(
  report: EvidenceReportInput,
  options: CommentOptions = DEFAULT_OPTIONS
): string {
  const { scoreSummary, clauseResults } = report;
  const emoji = getRecommendationEmoji(scoreSummary.recommendation);
  const verdict = getVerdictLabel(scoreSummary.recommendation);
  
  const lines: string[] = [];
  
  // Marker (hidden)
  lines.push(COMMENT_MARKER);
  lines.push('');
  
  // Header
  lines.push(`## ${emoji} ISL Verification: **${verdict}**`);
  lines.push('');
  
  // Score summary
  lines.push('### Ship Score');
  lines.push('');
  lines.push(`| Metric | Value |`);
  lines.push(`|--------|-------|`);
  lines.push(`| **Overall Score** | **${scoreSummary.overallScore}%** |`);
  lines.push(`| Pass | ${scoreSummary.passCount} |`);
  lines.push(`| Partial | ${scoreSummary.partialCount} |`);
  lines.push(`| Fail | ${scoreSummary.failCount} |`);
  lines.push(`| Total Clauses | ${scoreSummary.totalClauses} |`);
  if (scoreSummary.confidence) {
    lines.push(`| Confidence | ${scoreSummary.confidence} |`);
  }
  lines.push('');
  
  // Failed clauses details
  const failedClauses = clauseResults.filter(c => c.state === 'fail');
  if (failedClauses.length > 0) {
    lines.push('### Top Failed Clauses');
    lines.push('');
    
    const displayClauses = failedClauses.slice(0, options.maxFailedClauses);
    
    for (const clause of displayClauses) {
      const location = formatLocation(clause);
      const locationStr = location ? ` \`${location}\`` : '';
      const typeStr = clause.clauseType ? ` (${clause.clauseType})` : '';
      
      lines.push(`- **${clause.clauseId}**${typeStr}${locationStr}`);
      if (clause.reason) {
        lines.push(`  - ${clause.reason}`);
      }
    }
    
    if (failedClauses.length > options.maxFailedClauses) {
      lines.push('');
      lines.push(`*...and ${failedClauses.length - options.maxFailedClauses} more failed clauses*`);
    }
    lines.push('');
  }
  
  // Partial clauses summary
  const partialClauses = clauseResults.filter(c => c.state === 'partial');
  if (partialClauses.length > 0) {
    lines.push(`<details>`);
    lines.push(`<summary>Partial Clauses (${partialClauses.length})</summary>`);
    lines.push('');
    for (const clause of partialClauses.slice(0, 10)) {
      const location = formatLocation(clause);
      const locationStr = location ? ` \`${location}\`` : '';
      lines.push(`- **${clause.clauseId}**${locationStr}: ${clause.reason || 'Partially satisfied'}`);
    }
    if (partialClauses.length > 10) {
      lines.push(`- *...and ${partialClauses.length - 10} more*`);
    }
    lines.push('');
    lines.push(`</details>`);
    lines.push('');
  }
  
  // Full report (collapsible)
  if (options.includeFullReport) {
    lines.push(`<details>`);
    lines.push(`<summary>Full Evidence Report</summary>`);
    lines.push('');
    lines.push('```json');
    lines.push(JSON.stringify(report, null, 2));
    lines.push('```');
    lines.push('');
    lines.push(`</details>`);
    lines.push('');
  }
  
  // Metadata
  if (report.metadata) {
    const { durationMs, agentVersion } = report.metadata;
    lines.push('---');
    if (durationMs !== undefined) {
      lines.push(`*Duration: ${(durationMs / 1000).toFixed(2)}s*`);
    }
    if (agentVersion) {
      lines.push(`*Agent Version: ${agentVersion}*`);
    }
    lines.push('');
  }
  
  // Footer
  if (options.footerText) {
    lines.push('---');
    lines.push(options.footerText);
  }
  
  return lines.join('\n');
}

// ============================================================================
// Main Logic
// ============================================================================

/**
 * Post or update the evidence report as a PR comment
 */
async function postEvidenceComment(
  reportPath: string,
  options: CommentOptions = DEFAULT_OPTIONS
): Promise<CommentResult> {
  // Load config from environment
  const config = getEnvConfig();
  
  // Load and parse the evidence report
  const report = loadEvidenceReport(reportPath);
  
  // Generate comment body
  const body = generateCommentBody(report, options);
  
  // Check for existing comment
  const existingComment = await findExistingComment(config);
  
  let result: CommentResult;
  
  if (existingComment) {
    // Update existing comment
    const updated = await updateComment(config, existingComment.id, body);
    result = {
      success: true,
      commentId: updated.id,
      commentUrl: updated.html_url,
      action: 'updated',
    };
    console.log(`Updated existing comment: ${updated.html_url}`);
  } else {
    // Create new comment
    const created = await createComment(config, body);
    result = {
      success: true,
      commentId: created.id,
      commentUrl: created.html_url,
      action: 'created',
    };
    console.log(`Created new comment: ${created.html_url}`);
  }
  
  return result;
}

// ============================================================================
// CLI Entry Point
// ============================================================================

async function main(): Promise<void> {
  const args = process.argv.slice(2);
  
  if (args.length === 0 || args.includes('--help') || args.includes('-h')) {
    console.log(`
ISL Evidence PR Commenter

Usage:
  npx tsx scripts/github/commentEvidence.ts <evidence-report-path>

Environment Variables:
  GITHUB_TOKEN       - GitHub token with PR write permissions (required)
  GITHUB_REPOSITORY  - Owner/repo format, e.g., "owner/repo" (required)
  GITHUB_PR_NUMBER   - Pull request number (required)
  GITHUB_API_URL     - GitHub API base URL (optional, defaults to https://api.github.com)

Example:
  GITHUB_TOKEN=ghp_xxx GITHUB_REPOSITORY=owner/repo GITHUB_PR_NUMBER=123 \\
    npx tsx scripts/github/commentEvidence.ts .vibecheck/reports/evidence.json
`);
    process.exit(args.includes('--help') || args.includes('-h') ? 0 : 1);
  }
  
  const reportPath = args[0];
  if (!reportPath) {
    console.error('Error: Evidence report path is required');
    process.exit(1);
  }
  
  try {
    const result = await postEvidenceComment(reportPath);
    
    // Output result as JSON for CI consumption
    console.log('\nResult:');
    console.log(JSON.stringify(result, null, 2));
    
    process.exit(0);
  } catch (error) {
    console.error('Error posting evidence comment:', error instanceof Error ? error.message : error);
    process.exit(1);
  }
}

// Run if executed directly
main().catch(err => {
  console.error('Unhandled error:', err);
  process.exit(1);
});
