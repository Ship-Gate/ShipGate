// ============================================================================
// Go Validation Template
// ============================================================================

export interface ValidationTemplateData {
  PackageName: string;
  Types: ValidationTypeData[];
  CustomValidators: CustomValidatorData[];
}

export interface ValidationTypeData {
  Name: string;
  HasCustomValidation: boolean;
  ValidatorFuncName?: string;
}

export interface CustomValidatorData {
  Name: string;
  FuncName: string;
  Pattern?: string;
  Code: string;
}

/**
 * Render validation helper file
 */
export function renderValidationHelpers(data: ValidationTemplateData): string {
  const lines: string[] = [];
  
  // Header and package
  lines.push(`// Code generated by @isl-lang/codegen-go. DO NOT EDIT.`);
  lines.push(`package ${data.PackageName}`);
  lines.push('');
  lines.push('import (');
  lines.push('\t"regexp"');
  lines.push('\t"github.com/go-playground/validator/v10"');
  lines.push(')');
  lines.push('');
  
  // Global validator instance
  lines.push('var validate *validator.Validate');
  lines.push('');
  lines.push('func init() {');
  lines.push('\tvalidate = validator.New()');
  lines.push('\tRegisterCustomValidators(validate)');
  lines.push('}');
  lines.push('');
  
  // Custom validator patterns
  for (const cv of data.CustomValidators) {
    if (cv.Pattern) {
      lines.push(`var ${cv.FuncName}Pattern = regexp.MustCompile(\`${cv.Pattern}\`)`);
    }
  }
  if (data.CustomValidators.some(cv => cv.Pattern)) {
    lines.push('');
  }
  
  // Custom validator functions
  for (const cv of data.CustomValidators) {
    lines.push(cv.Code);
    lines.push('');
  }
  
  // Registration function
  lines.push('// RegisterCustomValidators registers all custom validation functions.');
  lines.push('func RegisterCustomValidators(v *validator.Validate) {');
  for (const cv of data.CustomValidators) {
    lines.push(`\tv.RegisterValidation("${cv.Name}", ${cv.FuncName})`);
  }
  lines.push('}');
  lines.push('');
  
  // Validate function for each type
  for (const t of data.Types) {
    lines.push(`// Validate${t.Name} validates a ${t.Name} instance.`);
    lines.push(`func Validate${t.Name}(s *${t.Name}) error {`);
    lines.push('\treturn validate.Struct(s)');
    lines.push('}');
    lines.push('');
  }
  
  // Generic validate function
  lines.push('// Validate validates any struct using the global validator.');
  lines.push('func Validate(s interface{}) error {');
  lines.push('\treturn validate.Struct(s)');
  lines.push('}');
  
  return lines.join('\n');
}

/**
 * Render custom regex validator
 */
export function renderRegexValidator(name: string, pattern: string): CustomValidatorData {
  const funcName = `validate${name}`;
  
  const code = [
    `// ${funcName} validates the ${name} format.`,
    `func ${funcName}(fl validator.FieldLevel) bool {`,
    `\treturn ${funcName}Pattern.MatchString(fl.Field().String())`,
    `}`,
  ].join('\n');
  
  return {
    Name: name.toLowerCase(),
    FuncName: funcName,
    Pattern: pattern,
    Code: code,
  };
}
