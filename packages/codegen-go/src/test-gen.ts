// ============================================================================
// Go Test Stub Generator
// Generates _test.go files from ISL scenarios
// ============================================================================

import type {
  Behavior,
  ScenarioBlock,
  Scenario,
  Expression,
  StringLiteral,
  NumberLiteral,
  BooleanLiteral,
  Identifier,
  MemberExpr,
  BinaryExpr,
  AssignmentStmt,
  CallStmt,
  Statement,
} from './ast-types.js';

import {
  toGoName,
  type GoImports,
  emptyImports,
} from './types.js';

// Generated test file result
export interface GeneratedTestFile {
  path: string;
  content: string;
}

/**
 * Generate test stubs from ISL scenario blocks
 */
export function generateTestStubs(
  packageName: string,
  behaviors: Behavior[],
  scenarios: ScenarioBlock[],
): GeneratedTestFile[] {
  const files: GeneratedTestFile[] = [];

  const testContent = generateBehaviorTests(packageName, behaviors, scenarios);
  files.push({
    path: `${packageName}/handlers_test.go`,
    content: testContent,
  });

  return files;
}

/**
 * Generate test file content for all behaviors
 */
function generateBehaviorTests(
  packageName: string,
  behaviors: Behavior[],
  scenarios: ScenarioBlock[],
): string {
  const imports = emptyImports();
  imports.standard.add('context');
  imports.standard.add('testing');
  const sections: string[] = [];

  // Build scenario lookup by behavior name
  const scenarioMap = new Map<string, Scenario[]>();
  for (const block of scenarios) {
    const key = block.behaviorName.name;
    if (!scenarioMap.has(key)) {
      scenarioMap.set(key, []);
    }
    scenarioMap.get(key)!.push(...block.scenarios);
  }

  // Generate tests for each behavior (sorted for stable output)
  const sortedBehaviors = [...behaviors].sort((a, b) => a.name.name.localeCompare(b.name.name));
  for (const behavior of sortedBehaviors) {
    const behaviorScenarios = scenarioMap.get(behavior.name.name) ?? [];
    const testSection = generateBehaviorTestSection(behavior, behaviorScenarios);
    mergeInto(imports, testSection.imports);
    sections.push(testSection.code);
  }

  // Format the file
  const lines: string[] = [];
  lines.push(`// Code generated by @isl-lang/codegen-go. DO NOT EDIT.`);
  lines.push(`package ${packageName}`);
  lines.push('');
  lines.push('import (');
  const stdImports = Array.from(imports.standard).sort();
  for (const imp of stdImports) {
    lines.push(`\t"${imp}"`);
  }
  if (imports.standard.size > 0 && imports.external.size > 0) {
    lines.push('');
  }
  const extImports = Array.from(imports.external).sort();
  for (const imp of extImports) {
    lines.push(`\t"${imp}"`);
  }
  lines.push(')');
  lines.push('');

  for (let i = 0; i < sections.length; i++) {
    lines.push(sections[i]!);
    if (i < sections.length - 1) {
      lines.push('');
    }
  }

  return lines.join('\n');
}

/**
 * Generate test section for a single behavior
 */
function generateBehaviorTestSection(
  behavior: Behavior,
  scenarios: Scenario[],
): { code: string; imports: GoImports } {
  const imports = emptyImports();
  const behaviorName = toGoName(behavior.name.name);
  const lines: string[] = [];

  if (scenarios.length > 0) {
    lines.push(`func Test${behaviorName}(t *testing.T) {`);

    for (const scenario of scenarios) {
      const scenarioName = scenario.name.value;
      const testName = sanitizeTestName(scenarioName);
      const scenarioCode = generateScenarioTest(behavior, scenario);
      mergeInto(imports, scenarioCode.imports);

      lines.push(`\tt.Run("${testName}", func(t *testing.T) {`);
      for (const line of scenarioCode.lines) {
        lines.push(`\t\t${line}`);
      }
      lines.push('\t})');
      lines.push('');
    }

    lines.push('}');
  } else {
    // Generate minimal test stubs when no scenarios exist
    lines.push(`func Test${behaviorName}_Success(t *testing.T) {`);
    lines.push(`\tctx := context.Background()`);
    lines.push('');
    lines.push(`\tinput := ${behaviorName}Input{`);
    for (const field of behavior.input.fields) {
      const fieldName = toGoName(field.name.name);
      const zeroVal = getTestValue(field.type.kind, field.name.name);
      lines.push(`\t\t${fieldName}: ${zeroVal},`);
    }
    lines.push('\t}');
    lines.push('');
    lines.push('\t// TODO: Setup test dependencies and call handler');
    lines.push(`\t_ = ctx`);
    lines.push(`\t_ = input`);
    lines.push('}');
    lines.push('');

    // Generate error case stubs
    for (const errSpec of behavior.output.errors) {
      const errName = toGoName(errSpec.name.name);
      lines.push(`func Test${behaviorName}_${errName}(t *testing.T) {`);
      lines.push(`\tctx := context.Background()`);
      if (errSpec.when) {
        lines.push(`\t// Scenario: ${errSpec.when.value}`);
      }
      lines.push(`\t// TODO: Setup state that triggers ${errSpec.name.name}`);
      lines.push(`\t_ = ctx`);
      lines.push('}');
      lines.push('');
    }
  }

  return { code: lines.join('\n'), imports };
}

/**
 * Generate test code from a scenario definition (given/when/then)
 */
function generateScenarioTest(
  behavior: Behavior,
  scenario: Scenario,
): { lines: string[]; imports: GoImports } {
  const imports = emptyImports();
  const behaviorName = toGoName(behavior.name.name);
  const lines: string[] = [];

  // Given block
  if (scenario.given.length > 0) {
    lines.push('// Given');
    for (const stmt of scenario.given) {
      lines.push(`// ${renderStatement(stmt)}`);
    }
    lines.push('');
  }

  lines.push(`ctx := context.Background()`);
  lines.push('');

  // When block
  lines.push('// When');
  lines.push(`input := ${behaviorName}Input{`);
  for (const stmt of scenario.when) {
    const assignment = renderAssignment(stmt);
    if (assignment) {
      lines.push(`\t${assignment}`);
    }
  }
  for (const field of behavior.input.fields) {
    if (!field.optional) {
      const hasAssignment = scenario.when.some(s => {
        if (s.kind === 'AssignmentStmt') {
          return (s as AssignmentStmt).target.name === field.name.name;
        }
        return false;
      });
      if (!hasAssignment) {
        const fieldName = toGoName(field.name.name);
        const testVal = getTestValue(field.type.kind, field.name.name);
        lines.push(`\t${fieldName}: ${testVal}, // TODO: set test value`);
      }
    }
  }
  lines.push('}');
  lines.push('');

  lines.push(`_ = ctx`);
  lines.push(`_ = input`);
  lines.push('');

  // Then block
  if (scenario.then.length > 0) {
    lines.push('// Then');
    for (const assertion of scenario.then) {
      lines.push(`// Assert: ${renderExpressionStr(assertion)}`);
    }
    lines.push('// TODO: Call handler and verify assertions');
  } else {
    lines.push('// TODO: Add assertions');
  }

  return { lines, imports };
}

/**
 * Render a statement as a comment string
 */
function renderStatement(stmt: Statement): string {
  switch (stmt.kind) {
    case 'AssignmentStmt': {
      const as = stmt as AssignmentStmt;
      return `${as.target.name} = ${renderExpressionStr(as.value)}`;
    }
    case 'CallStmt': {
      const cs = stmt as CallStmt;
      const call = renderExpressionStr(cs.call);
      return cs.target ? `${cs.target.name} := ${call}` : call;
    }
    default:
      return stmt.kind;
  }
}

/**
 * Render an assignment statement as a Go struct field
 */
function renderAssignment(stmt: Statement): string | null {
  if (stmt.kind === 'AssignmentStmt') {
    const as = stmt as AssignmentStmt;
    const fieldName = toGoName(as.target.name);
    const value = renderGoValue(as.value);
    return `${fieldName}: ${value},`;
  }
  return null;
}

/**
 * Render an expression as a Go value
 */
function renderGoValue(expr: Expression): string {
  switch (expr.kind) {
    case 'StringLiteral':
      return `"${(expr as StringLiteral).value}"`;
    case 'NumberLiteral':
      return String((expr as NumberLiteral).value);
    case 'BooleanLiteral':
      return String((expr as BooleanLiteral).value);
    case 'Identifier':
      return (expr as Identifier).name;
    default:
      return `nil /* TODO: ${expr.kind} */`;
  }
}

/**
 * Render an expression as a readable string
 */
function renderExpressionStr(expr: Expression): string {
  switch (expr.kind) {
    case 'StringLiteral':
      return `"${(expr as StringLiteral).value}"`;
    case 'NumberLiteral':
      return String((expr as NumberLiteral).value);
    case 'BooleanLiteral':
      return String((expr as BooleanLiteral).value);
    case 'Identifier':
      return (expr as Identifier).name;
    case 'MemberExpr': {
      const me = expr as MemberExpr;
      return `${renderExpressionStr(me.object)}.${me.property.name}`;
    }
    case 'BinaryExpr': {
      const be = expr as BinaryExpr;
      return `${renderExpressionStr(be.left)} ${be.operator} ${renderExpressionStr(be.right)}`;
    }
    default:
      return expr.kind;
  }
}

/**
 * Get a sensible test value for a given type kind
 */
function getTestValue(typeKind: string, fieldName: string): string {
  const lower = fieldName.toLowerCase();
  if (lower.includes('email')) return '"test@example.com"';
  if (lower.includes('name')) return '"test"';
  if (lower.includes('password')) return '"P@ssw0rd123"';
  if (lower.includes('url')) return '"https://example.com"';

  switch (typeKind) {
    case 'PrimitiveType':
      return '"test"';
    case 'ReferenceType':
      return 'nil /* TODO */';
    default:
      return '"test"';
  }
}

/**
 * Sanitize a string for use as a Go test name
 */
function sanitizeTestName(name: string): string {
  return name.replace(/[^a-zA-Z0-9_]/g, '_').replace(/_+/g, '_').replace(/^_|_$/g, '');
}

/**
 * Merge imports in place
 */
function mergeInto(target: GoImports, source: GoImports): void {
  source.standard.forEach(i => target.standard.add(i));
  source.external.forEach(i => target.external.add(i));
}
