import * as core from '@actions/core';
import * as github from '@actions/github';
import { glob } from 'glob';
import * as fs from 'fs';
import { Tier1StaticProver } from '@isl-verify/core';
import { LicenseStorage, LicenseValidator } from '@shipgate/shared';

async function run(): Promise<void> {
  try {
    const pattern = core.getInput('pattern');
    const tier = core.getInput('tier') as 'tier1' | 'tier2' | 'tier3';
    const license = core.getInput('license');
    const failOnError = core.getInput('fail-on-error') === 'true';
    const commentPR = core.getInput('comment-pr') === 'true';

    core.info(`Running ISL Verify ${tier} on pattern: ${pattern}`);

    // Set license if provided
    if (license) {
      process.env.ISL_VERIFY_LICENSE = license;
    }

    // Validate license for tier2/tier3
    if (tier !== 'tier1') {
      const validation = LicenseStorage.validate();
      if (!validation.valid) {
        core.setFailed(`License required for ${tier}. Set the 'license' input.`);
        return;
      }
      core.info(`License validated: ${validation.tier}`);
    }

    // Find files
    const files = await glob(pattern, { absolute: true, posix: true });
    core.info(`Found ${files.length} files to verify`);

    if (files.length === 0) {
      core.warning('No files found matching pattern');
      return;
    }

    // Run verification
    const prover = new Tier1StaticProver();
    const allFindings: any[] = [];

    for (const file of files) {
      const source = fs.readFileSync(file, 'utf-8');
      const result = await prover.verify({ file, source, tier });

      const failed = result.properties.filter((p) => p.status === 'fail');
      failed.forEach((prop) => {
        allFindings.push({
          file,
          property: prop.property,
          message: prop.message,
        });
      });
    }

    // Set outputs
    core.setOutput('findings-count', allFindings.length);
    core.setOutput('passed', allFindings.length === 0);

    // Comment on PR if enabled
    if (commentPR && github.context.payload.pull_request) {
      await commentOnPR(allFindings);
    }

    // Print summary
    if (allFindings.length === 0) {
      core.info('✅ All checks passed!');
    } else {
      core.warning(`⚠️  ${allFindings.length} issue(s) found`);
      allFindings.forEach((f) => {
        core.warning(`${f.file}: ${f.property} - ${f.message}`);
      });

      if (failOnError) {
        core.setFailed(`Verification failed with ${allFindings.length} issue(s)`);
      }
    }
  } catch (error) {
    core.setFailed(`Action failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

async function commentOnPR(findings: any[]): Promise<void> {
  try {
    const token = process.env.GITHUB_TOKEN || core.getInput('github-token');
    if (!token) {
      core.warning('No GitHub token provided, skipping PR comment');
      return;
    }

    const octokit = github.getOctokit(token);
    const { context } = github;

    if (!context.payload.pull_request) {
      return;
    }

    const body = formatPRComment(findings);

    await octokit.rest.issues.createComment({
      ...context.repo,
      issue_number: context.payload.pull_request.number,
      body,
    });
  } catch (error) {
    core.warning(`Failed to comment on PR: ${error instanceof Error ? error.message : 'Unknown'}`);
  }
}

function formatPRComment(findings: any[]): string {
  if (findings.length === 0) {
    return `## ✅ ISL Verify Passed\n\nAll verification checks passed!`;
  }

  const lines = [
    `## ⚠️ ISL Verify Found ${findings.length} Issue(s)`,
    '',
    '| File | Property | Message |',
    '|------|----------|---------|',
  ];

  findings.forEach((f) => {
    const file = f.file.split('/').pop() || f.file;
    lines.push(`| \`${file}\` | ${f.property} | ${f.message} |`);
  });

  lines.push('');
  lines.push('---');
  lines.push('*Generated by [ISL Verify](https://isl-verify.com)*');

  return lines.join('\n');
}

run();
