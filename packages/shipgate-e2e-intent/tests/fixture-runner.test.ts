/**
 * Shipgate E2E Intent Verification Test Suite
 *
 * Proves the core claim: ISL specs catch real code violations.
 * Each fixture has good.ts (should pass) and bad.ts (should fail/warn).
 *
 * The test runner:
 *   1. Parses the ISL spec
 *   2. Reads good.ts and bad.ts implementation source
 *   3. Runs isl-verify against each
 *   4. Uses @shipgate/sdk decideGate() for verdict
 *   5. Asserts against expected.json constraints
 *   6. Snapshots full output for CI regression detection
 */

import { describe, it, expect } from 'vitest';
import { readFileSync, existsSync, readdirSync } from 'fs';
import { join, resolve } from 'path';
import { parse as parseISL } from '@isl-lang/parser';
import { verify as verifyDomain } from '@isl-lang/isl-verify';

type GateVerdict = 'SHIP' | 'WARN' | 'NO_SHIP';

function decideGate(result: { passed: boolean; score: number; reasons: Array<{ impact: string }> }): GateVerdict {
  if (result.reasons.some((r) => r.impact === 'critical')) return 'NO_SHIP';
  if (result.passed && result.score >= 80) return 'SHIP';
  if (result.score >= 50) return 'WARN';
  return 'NO_SHIP';
}

// ─── Types ──────────────────────────────────────────────────────────────────

interface ExpectedSide {
  verdictOneOf?: string[];
  scoreAbove?: number;
  scoreBelow?: number;
  mustContainMessagePatterns?: string[];
  mustNotContainMessages?: string[];
  description?: string;
}

interface FixtureExpected {
  good: ExpectedSide;
  bad: ExpectedSide;
}

interface VerifyOutput {
  verdict: string;
  score: number;
  passed: boolean;
  details: Array<{ name: string; status: string; message?: string }>;
  messages: string[];
  error?: string;
}

// ─── Helpers ────────────────────────────────────────────────────────────────

const FIXTURES_DIR = resolve(__dirname, '..', 'fixtures');

function getFixtureDirs(): string[] {
  return readdirSync(FIXTURES_DIR, { withFileTypes: true })
    .filter((d) => d.isDirectory())
    .map((d) => d.name)
    .sort();
}

async function runVerification(
  specPath: string,
  implPath: string,
): Promise<VerifyOutput> {
  try {
    const specSource = readFileSync(specPath, 'utf-8');
    const implSource = readFileSync(implPath, 'utf-8');

    const { domain, errors: parseErrors } = parseISL(specSource, specPath);

    if (parseErrors.length > 0 || !domain) {
      return {
        verdict: 'NO_SHIP',
        score: 0,
        passed: false,
        details: [],
        messages: parseErrors.map((e: { message: string }) => `Parse error: ${e.message}`),
        error: 'ISL parse failed',
      };
    }

    const result = await verifyDomain(domain, implSource, {
      runner: { timeout: 30000, verbose: false },
    });

    const score = result.trustScore.overall;
    const passed = score >= 70;

    const sdkResult = {
      passed,
      score,
      reasons: result.trustScore.details.map((d) => ({
        label: `${d.name}: ${d.status}`,
        impact: d.impact ?? ('medium' as const),
      })),
    };

    const verdict = decideGate(sdkResult);

    const messages: string[] = [];
    for (const detail of result.trustScore.details) {
      const msg = `[${detail.category}] ${detail.name}: ${detail.status}`;
      messages.push(msg.toLowerCase());
      if (detail.message) {
        messages.push(detail.message.toLowerCase());
      }
    }

    if (result.testResult.verificationFailed) {
      messages.push(`verification failed: ${result.testResult.verificationFailureReason ?? 'unknown'}`);
    }

    return {
      verdict,
      score,
      passed,
      details: result.trustScore.details.map((d) => ({
        name: d.name,
        status: d.status,
        message: d.message,
      })),
      messages,
    };
  } catch (err) {
    const errorMsg = err instanceof Error ? err.message : String(err);
    return {
      verdict: 'NO_SHIP',
      score: 0,
      passed: false,
      details: [],
      messages: [errorMsg.toLowerCase()],
      error: errorMsg,
    };
  }
}

async function runAutoSpecVerification(implPath: string): Promise<VerifyOutput> {
  try {
    const implSource = readFileSync(implPath, 'utf-8');

    // Extract functions/types to build a minimal auto-spec
    const funcMatches = [...implSource.matchAll(/export\s+function\s+(\w+)/g)];
    const typeMatches = [...implSource.matchAll(/export\s+(?:interface|type)\s+(\w+)/g)];

    if (funcMatches.length === 0 && typeMatches.length === 0) {
      return {
        verdict: 'NO_SHIP',
        score: 30,
        passed: false,
        details: [],
        messages: ['no exported functions or types found'],
      };
    }

    // Build minimal auto-spec
    const domainName = 'AutoGenerated';
    const lines: string[] = [`domain ${domainName} {`, '  version: "1.0.0"'];

    for (const t of typeMatches) {
      lines.push('', `  entity ${t[1]} {`, '    id: String', '  }');
    }

    for (const fn of funcMatches) {
      lines.push(
        '',
        `  behavior ${fn[1]} {`,
        '    input {}',
        '    output {',
        '      success: String',
        '    }',
        '    invariants {',
        `      - ${fn[1]} never_throws_unhandled`,
        '    }',
        '  }',
      );
    }

    lines.push('}');
    const specSource = lines.join('\n');

    const { domain, errors: parseErrors } = parseISL(specSource, 'auto-generated.isl');
    if (parseErrors.length > 0 || !domain) {
      return {
        verdict: 'NO_SHIP',
        score: 20,
        passed: false,
        details: [],
        messages: ['auto-generated spec failed to parse'],
      };
    }

    const result = await verifyDomain(domain, implSource, {
      runner: { timeout: 30000, verbose: false },
    });

    const score = result.trustScore.overall;
    // Auto-specs cap confidence — even passing code gets a WARN at best
    const cappedScore = Math.min(score, 75);
    const passed = cappedScore >= 70;

    const sdkResult = {
      passed,
      score: cappedScore,
      reasons: result.trustScore.details.map((d) => ({
        label: `${d.name}: ${d.status}`,
        impact: d.impact ?? ('medium' as const),
      })),
    };

    const verdict = decideGate(sdkResult);

    const messages: string[] = ['auto-generated spec'];
    for (const detail of result.trustScore.details) {
      messages.push(`[${detail.category}] ${detail.name}: ${detail.status}`.toLowerCase());
    }

    return {
      verdict,
      score: cappedScore,
      passed,
      details: result.trustScore.details.map((d) => ({
        name: d.name,
        status: d.status,
        message: d.message,
      })),
      messages,
    };
  } catch (err) {
    const errorMsg = err instanceof Error ? err.message : String(err);
    return {
      verdict: 'NO_SHIP',
      score: 0,
      passed: false,
      details: [],
      messages: [errorMsg.toLowerCase()],
      error: errorMsg,
    };
  }
}

function assertExpectation(output: VerifyOutput, expected: ExpectedSide, label: string): void {
  if (expected.verdictOneOf) {
    expect(
      expected.verdictOneOf,
      `${label}: verdict ${output.verdict} not in ${JSON.stringify(expected.verdictOneOf)}`,
    ).toContain(output.verdict);
  }

  if (expected.scoreAbove !== undefined) {
    const normalizedScore = output.score > 1 ? output.score / 100 : output.score;
    expect(
      normalizedScore,
      `${label}: score ${normalizedScore} not above ${expected.scoreAbove}`,
    ).toBeGreaterThanOrEqual(expected.scoreAbove);
  }

  if (expected.scoreBelow !== undefined) {
    const normalizedScore = output.score > 1 ? output.score / 100 : output.score;
    expect(
      normalizedScore,
      `${label}: score ${normalizedScore} not below ${expected.scoreBelow}`,
    ).toBeLessThan(expected.scoreBelow);
  }

  if (expected.mustContainMessagePatterns) {
    const allMessages = output.messages.join(' ');
    for (const pattern of expected.mustContainMessagePatterns) {
      expect(
        allMessages,
        `${label}: expected message pattern "${pattern}" not found in: ${allMessages}`,
      ).toMatch(new RegExp(pattern, 'i'));
    }
  }

  if (expected.mustNotContainMessages) {
    const allMessages = output.messages.join(' ');
    for (const pattern of expected.mustNotContainMessages) {
      expect(
        allMessages,
        `${label}: unexpected message pattern "${pattern}" found`,
      ).not.toMatch(new RegExp(pattern, 'i'));
    }
  }
}

// ─── Test Suite ─────────────────────────────────────────────────────────────

describe('Shipgate E2E Intent Verification', () => {
  const fixtureDirs = getFixtureDirs();

  it('should have at least 12 fixtures', () => {
    expect(fixtureDirs.length).toBeGreaterThanOrEqual(12);
  });

  // Run each fixture that has a spec.isl
  const specFixtures = fixtureDirs.filter((name) =>
    existsSync(join(FIXTURES_DIR, name, 'spec.isl')),
  );

  for (const fixtureName of specFixtures) {
    describe(`fixture: ${fixtureName}`, () => {
      const fixtureDir = join(FIXTURES_DIR, fixtureName);
      const specPath = join(fixtureDir, 'spec.isl');
      const goodPath = join(fixtureDir, 'good.ts');
      const badPath = join(fixtureDir, 'bad.ts');
      const expectedPath = join(fixtureDir, 'expected.json');

      it('good.ts should satisfy the spec', async () => {
        if (!existsSync(goodPath)) return;
        const expected: FixtureExpected = JSON.parse(readFileSync(expectedPath, 'utf-8'));
        const output = await runVerification(specPath, goodPath);

        assertExpectation(output, expected.good, `${fixtureName}/good.ts`);

        // Snapshot for regression detection
        expect({
          fixture: fixtureName,
          variant: 'good',
          verdict: output.verdict,
          passed: output.passed,
          detailCount: output.details.length,
        }).toMatchSnapshot();
      });

      it('bad.ts should be caught by the spec', async () => {
        if (!existsSync(badPath)) return;
        const expected: FixtureExpected = JSON.parse(readFileSync(expectedPath, 'utf-8'));
        const output = await runVerification(specPath, badPath);

        assertExpectation(output, expected.bad, `${fixtureName}/bad.ts`);

        // Snapshot for regression detection
        expect({
          fixture: fixtureName,
          variant: 'bad',
          verdict: output.verdict,
          passed: output.passed,
          detailCount: output.details.length,
        }).toMatchSnapshot();
      });

      it('bad.ts should score lower than good.ts', async () => {
        if (!existsSync(goodPath) || !existsSync(badPath)) return;
        const goodOutput = await runVerification(specPath, goodPath);
        const badOutput = await runVerification(specPath, badPath);

        expect(
          badOutput.score,
          `${fixtureName}: bad.ts (${badOutput.score}) should score ≤ good.ts (${goodOutput.score})`,
        ).toBeLessThanOrEqual(goodOutput.score);
      });
    });
  }

  // Shallow auto-spec fixture (no spec.isl — tests auto-generation)
  describe('fixture: shallow-auto-spec', () => {
    const fixtureDir = join(FIXTURES_DIR, 'shallow-auto-spec');
    const goodPath = join(fixtureDir, 'good.ts');
    const badPath = join(fixtureDir, 'bad.ts');
    const expectedPath = join(fixtureDir, 'expected.json');

    it('good.ts with rich exports should produce decent auto-spec score', async () => {
      if (!existsSync(goodPath)) return;
      const expected: FixtureExpected = JSON.parse(readFileSync(expectedPath, 'utf-8'));
      const output = await runAutoSpecVerification(goodPath);

      assertExpectation(output, expected.good, 'shallow-auto-spec/good.ts');

      expect({
        fixture: 'shallow-auto-spec',
        variant: 'good',
        verdict: output.verdict,
        passed: output.passed,
      }).toMatchSnapshot();
    });

    it('bad.ts with minimal exports should produce low auto-spec score', async () => {
      if (!existsSync(badPath)) return;
      const expected: FixtureExpected = JSON.parse(readFileSync(expectedPath, 'utf-8'));
      const output = await runAutoSpecVerification(badPath);

      assertExpectation(output, expected.bad, 'shallow-auto-spec/bad.ts');

      expect({
        fixture: 'shallow-auto-spec',
        variant: 'bad',
        verdict: output.verdict,
        passed: output.passed,
      }).toMatchSnapshot();
    });
  });
});

// ─── Truth Mode Invariants ─────────────────────────────────────────────────────

describe('Truth Mode Invariants', () => {
  it('bad code + good spec = FAIL (never SHIP)', async () => {
    const fixtureDir = join(FIXTURES_DIR, 'good-code-good-spec');
    const specPath = join(fixtureDir, 'spec.isl');
    const badPath = join(fixtureDir, 'bad.ts');
    if (!existsSync(badPath) || !existsSync(specPath)) return;

    const output = await runVerification(specPath, badPath);
    expect(
      output.verdict,
      'INVARIANT: bad code + good spec must NEVER produce SHIP',
    ).not.toBe('SHIP');
  });

  it('good code + good spec = PASS or WARN (never NO_SHIP with critical failures)', async () => {
    const fixtureDir = join(FIXTURES_DIR, 'good-code-good-spec');
    const specPath = join(fixtureDir, 'spec.isl');
    const goodPath = join(fixtureDir, 'good.ts');
    if (!existsSync(goodPath) || !existsSync(specPath)) return;

    const output = await runVerification(specPath, goodPath);
    expect(
      ['SHIP', 'WARN'],
      'INVARIANT: good code + good spec must produce SHIP or WARN',
    ).toContain(output.verdict);
  });

  it('empty spec = near-zero score (no free credit)', async () => {
    const fixtureDir = join(FIXTURES_DIR, 'empty-spec-zero');
    const specPath = join(fixtureDir, 'spec.isl');
    const goodPath = join(fixtureDir, 'good.ts');
    if (!existsSync(goodPath) || !existsSync(specPath)) return;

    const output = await runVerification(specPath, goodPath);
    const normalizedScore = output.score > 1 ? output.score / 100 : output.score;
    expect(
      normalizedScore,
      'INVARIANT: empty spec must produce near-zero score',
    ).toBeLessThan(0.5);
  });

  it('shallow spec (invariants only) must NOT produce SHIP for bad code', async () => {
    const fixtureDir = join(FIXTURES_DIR, 'shallow-spec-noship');
    const specPath = join(fixtureDir, 'spec.isl');
    const badPath = join(fixtureDir, 'bad.ts');
    if (!existsSync(badPath) || !existsSync(specPath)) return;

    const output = await runVerification(specPath, badPath);
    const normalizedScore = output.score > 1 ? output.score / 100 : output.score;
    expect(
      normalizedScore,
      'INVARIANT: shallow spec + bad code must not score above 0.85',
    ).toBeLessThan(0.85);
  });
});

// ─── Summary Report ─────────────────────────────────────────────────────────────

describe('Shipgate Intent Proof Summary', () => {
  it('should generate a proof summary across all fixtures', async () => {
    const fixtureDirs = getFixtureDirs();
    const results: Array<{
      fixture: string;
      goodVerdict: string;
      goodScore: number;
      badVerdict: string;
      badScore: number;
      separation: number;
    }> = [];

    for (const fixtureName of fixtureDirs) {
      const fixtureDir = join(FIXTURES_DIR, fixtureName);
      const specPath = join(fixtureDir, 'spec.isl');
      const goodPath = join(fixtureDir, 'good.ts');
      const badPath = join(fixtureDir, 'bad.ts');

      if (!existsSync(goodPath) || !existsSync(badPath)) continue;

      let goodOutput: VerifyOutput;
      let badOutput: VerifyOutput;

      if (existsSync(specPath)) {
        goodOutput = await runVerification(specPath, goodPath);
        badOutput = await runVerification(specPath, badPath);
      } else {
        goodOutput = await runAutoSpecVerification(goodPath);
        badOutput = await runAutoSpecVerification(badPath);
      }

      results.push({
        fixture: fixtureName,
        goodVerdict: goodOutput.verdict,
        goodScore: goodOutput.score,
        badVerdict: badOutput.verdict,
        badScore: badOutput.score,
        separation: goodOutput.score - badOutput.score,
      });
    }

    // Proof: good code scores higher than bad code in every fixture
    for (const r of results) {
      expect(
        r.separation,
        `${r.fixture}: good (${r.goodScore}) should score >= bad (${r.badScore})`,
      ).toBeGreaterThanOrEqual(0);
    }

    // Snapshot the full summary for CI artifact
    expect(results).toMatchSnapshot();
  });
});
