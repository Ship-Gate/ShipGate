/**
 * Prisma Schema Generator
 *
 * Generates Prisma schema from ISL entities + storage blocks.
 * Uses DatabaseAdapter for datasource and env-specific config.
 */

import type { Domain, Entity, Field, StorageDecl, IndexDecl } from '@isl-lang/parser';
import type { GeneratedFile, ShipStack } from '../types.js';
import { islTypeToPrisma, toSnakeCase } from '../types.js';
import { getDatabaseAdapter } from '../adapters/index.js';

export function generatePrismaSchema(domain: Domain, stack: ShipStack): GeneratedFile[] {
  const files: GeneratedFile[] = [];
  const lines: string[] = [];
  const dbId = stack.database === 'postgres' ? 'postgres' : 'sqlite';
  const adapter = getDatabaseAdapter(dbId);

  // Header
  lines.push('// =============================================================================');
  lines.push(`// Prisma Schema — Generated from ISL domain "${domain.name.name}"`);
  lines.push('// DO NOT EDIT — This file is auto-generated by isl ship');
  lines.push('// =============================================================================');
  lines.push('');

  // Datasource
  const provider = stack.database === 'mongodb' ? 'mongodb' : stack.database === 'mysql' ? 'mysql' : adapter.provider;
  lines.push('datasource db {');
  lines.push(`  provider = "${provider}"`);
  lines.push('  url      = env("DATABASE_URL")');
  lines.push('}');
  lines.push('');

  // Generator
  lines.push('generator client {');
  lines.push('  provider = "prisma-client-js"');
  lines.push('}');
  lines.push('');

  // Build storage lookup for entity-specific config
  const storageMap = new Map<string, StorageDecl>();
  for (const s of domain.storage) {
    storageMap.set(s.entity.name, s);
  }

  const isPostgres = stack.database === 'postgres';

  // Generate models for each entity
  for (const entity of domain.entities) {
    const storage = storageMap.get(entity.name.name);
    lines.push(...generateModel(entity, storage, domain, isPostgres));
    lines.push('');
  }

  files.push({
    path: 'prisma/schema.prisma',
    content: lines.join('\n'),
    layer: 'database',
  });

  return files;
}

function generateModel(entity: Entity, storage: StorageDecl | undefined, domain: Domain, isPostgres: boolean): string[] {
  const lines: string[] = [];
  const tableName = storage?.table?.value ?? toSnakeCase(entity.name.name) + 's';

  lines.push(`model ${entity.name.name} {`);

  // Fields
  for (const field of entity.fields) {
    lines.push(`  ${generatePrismaField(field, entity, domain, isPostgres)}`);
  }

  // Table mapping
  lines.push('');
  lines.push(`  @@map("${tableName}")`);

  // Indexes from storage block
  if (storage) {
    for (const idx of storage.indexes) {
      lines.push(`  ${generatePrismaIndex(idx)}`);
    }
  }

  lines.push('}');
  return lines;
}

function generatePrismaField(field: Field, entity: Entity, domain: Domain, isPostgres: boolean): string {
  const name = field.name.name;
  let typeName = resolveFieldType(field);
  let attrs: string[] = [];

  // Check annotations for special handling
  const annotations = field.annotations ?? [];
  const isImmutable = annotations.some(a => a.name.name === 'immutable');
  const isUnique = annotations.some(a => a.name.name === 'unique');
  const isIndexed = annotations.some(a => a.name.name === 'indexed');
  const refAnnotation = annotations.find(a => a.name.name === 'references');

  // Postgres-specific native types: @db.Text, @db.Timestamp, @db.JsonB
  if (isPostgres) {
    const dbAttr = getPostgresDbAttr(field, typeName);
    if (dbAttr) attrs.push(dbAttr);
  }

  // ID field detection
  if (name === 'id') {
    attrs.push('@id');
    if (typeName === 'String') {
      attrs.push('@default(uuid())');
    } else {
      attrs.push('@default(autoincrement())');
    }
  }

  // Unique constraint
  if (isUnique && name !== 'id') {
    attrs.push('@unique');
  }

  // Default timestamps
  if (name === 'created_at' || name === 'createdAt') {
    attrs.push('@default(now())');
  }
  if (name === 'updated_at' || name === 'updatedAt') {
    attrs.push('@updatedAt');
  }

  // Foreign key reference
  if (refAnnotation && refAnnotation.value) {
    const refTarget = refAnnotation.value.kind === 'Identifier'
      ? refAnnotation.value.name
      : String(refAnnotation.value);
    // Add relation field above the FK field
    // We'll handle this at the model level instead
  }

  // Optional
  const optionalMark = field.optional ? '?' : '';

  // Map field name to snake_case column
  const columnName = toSnakeCase(name);
  if (columnName !== name) {
    attrs.push(`@map("${columnName}")`);
  }

  const attrStr = attrs.length > 0 ? ' ' + attrs.join(' ') : '';
  return `${name} ${typeName}${optionalMark}${attrStr}`;
}

/** Map ISL types/constraints to Postgres native types */
function getPostgresDbAttr(field: Field, typeName: string): string | null {
  // Timestamp → @db.Timestamp(3)
  if (typeName === 'DateTime') {
    return '@db.Timestamp(3)';
  }
  // Json → @db.JsonB
  if (typeName === 'Json') {
    return '@db.JsonB';
  }
  // String with long text → @db.Text (from max_length constraint or unconstrained)
  const maxLength = getConstraintValue(field.type, 'max_length') as number | undefined;
  if (typeName === 'String' && (maxLength === undefined || maxLength > 255)) {
    return '@db.Text';
  }
  return null;
}

function getConstraintValue(typeDef: unknown, name: string): unknown {
  if (!typeDef || typeof typeDef !== 'object') return undefined;
  const t = typeDef as { kind?: string; constraints?: Array<{ name?: string; value?: { value?: unknown } }>; base?: unknown };
  if (t.kind === 'ConstrainedType' && t.constraints) {
    const c = t.constraints.find((x) => x.name === name);
    if (c?.value && typeof c.value === 'object' && 'value' in c.value) return (c.value as { value: unknown }).value;
    if (c?.value) return c.value;
  }
  if (t.kind === 'ConstrainedType' && t.base) return getConstraintValue(t.base, name);
  if (t.kind === 'OptionalType' && 'inner' in t) return getConstraintValue((t as { inner: unknown }).inner, name);
  return undefined;
}

function resolveFieldType(field: Field): string {
  const typeDef = field.type;
  if (!typeDef) return 'String';

  switch (typeDef.kind) {
    case 'ReferenceType':
      return islTypeToPrisma(typeDef.name.parts.map(p => p.name).join('.'));
    case 'ListType':
      return resolveFieldType({ ...field, type: typeDef.element } as Field) + '[]';
    case 'OptionalType':
      return resolveFieldType({ ...field, type: typeDef.inner } as Field);
    default:
      return 'String';
  }
}

function generatePrismaIndex(idx: IndexDecl): string {
  const fieldNames = idx.fields.map(f => f.name).join(', ');
  if (idx.unique) {
    return `@@unique([${fieldNames}])`;
  }
  return `@@index([${fieldNames}])`;
}
