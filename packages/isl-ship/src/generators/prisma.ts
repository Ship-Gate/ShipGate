/**
 * Prisma Schema Generator
 *
 * Generates Prisma schema from ISL entities + storage blocks.
 */

import type { Domain, Entity, Field, StorageDecl, IndexDecl } from '@isl-lang/parser';
import type { GeneratedFile, ShipStack } from '../types.js';
import { islTypeToPrisma, toSnakeCase } from '../types.js';

export function generatePrismaSchema(domain: Domain, stack: ShipStack): GeneratedFile[] {
  const files: GeneratedFile[] = [];
  const lines: string[] = [];

  // Header
  lines.push('// =============================================================================');
  lines.push(`// Prisma Schema — Generated from ISL domain "${domain.name.name}"`);
  lines.push('// DO NOT EDIT — This file is auto-generated by isl ship');
  lines.push('// =============================================================================');
  lines.push('');

  // Datasource
  const provider = stack.database === 'mongodb' ? 'mongodb' : stack.database === 'mysql' ? 'mysql' : stack.database === 'sqlite' ? 'sqlite' : 'postgresql';
  lines.push('datasource db {');
  lines.push(`  provider = "${provider}"`);
  lines.push('  url      = env("DATABASE_URL")');
  lines.push('}');
  lines.push('');

  // Generator
  lines.push('generator client {');
  lines.push('  provider = "prisma-client-js"');
  lines.push('}');
  lines.push('');

  // Build storage lookup for entity-specific config
  const storageMap = new Map<string, StorageDecl>();
  for (const s of domain.storage) {
    storageMap.set(s.entity.name, s);
  }

  // Generate models for each entity
  for (const entity of domain.entities) {
    const storage = storageMap.get(entity.name.name);
    lines.push(...generateModel(entity, storage, domain));
    lines.push('');
  }

  files.push({
    path: 'prisma/schema.prisma',
    content: lines.join('\n'),
    layer: 'database',
  });

  return files;
}

function generateModel(entity: Entity, storage: StorageDecl | undefined, domain: Domain): string[] {
  const lines: string[] = [];
  const tableName = storage?.table?.value ?? toSnakeCase(entity.name.name) + 's';

  lines.push(`model ${entity.name.name} {`);

  // Fields
  for (const field of entity.fields) {
    lines.push(`  ${generatePrismaField(field, entity, domain)}`);
  }

  // Table mapping
  lines.push('');
  lines.push(`  @@map("${tableName}")`);

  // Indexes from storage block
  if (storage) {
    for (const idx of storage.indexes) {
      lines.push(`  ${generatePrismaIndex(idx)}`);
    }
  }

  lines.push('}');
  return lines;
}

function generatePrismaField(field: Field, entity: Entity, domain: Domain): string {
  const name = field.name.name;
  let typeName = resolveFieldType(field);
  let attrs: string[] = [];

  // Check annotations for special handling
  const annotations = field.annotations ?? [];
  const isImmutable = annotations.some(a => a.name.name === 'immutable');
  const isUnique = annotations.some(a => a.name.name === 'unique');
  const isIndexed = annotations.some(a => a.name.name === 'indexed');
  const refAnnotation = annotations.find(a => a.name.name === 'references');

  // ID field detection
  if (name === 'id') {
    attrs.push('@id');
    if (typeName === 'String') {
      attrs.push('@default(uuid())');
    } else {
      attrs.push('@default(autoincrement())');
    }
  }

  // Unique constraint
  if (isUnique && name !== 'id') {
    attrs.push('@unique');
  }

  // Default timestamps
  if (name === 'created_at' || name === 'createdAt') {
    attrs.push('@default(now())');
  }
  if (name === 'updated_at' || name === 'updatedAt') {
    attrs.push('@updatedAt');
  }

  // Foreign key reference
  if (refAnnotation && refAnnotation.value) {
    const refTarget = refAnnotation.value.kind === 'Identifier'
      ? refAnnotation.value.name
      : String(refAnnotation.value);
    // Add relation field above the FK field
    // We'll handle this at the model level instead
  }

  // Optional
  const optionalMark = field.optional ? '?' : '';

  // Map field name to snake_case column
  const columnName = toSnakeCase(name);
  if (columnName !== name) {
    attrs.push(`@map("${columnName}")`);
  }

  const attrStr = attrs.length > 0 ? ' ' + attrs.join(' ') : '';
  return `${name} ${typeName}${optionalMark}${attrStr}`;
}

function resolveFieldType(field: Field): string {
  const typeDef = field.type;
  if (!typeDef) return 'String';

  switch (typeDef.kind) {
    case 'ReferenceType':
      return islTypeToPrisma(typeDef.name.parts.map(p => p.name).join('.'));
    case 'ListType':
      return resolveFieldType({ ...field, type: typeDef.element } as Field) + '[]';
    case 'OptionalType':
      return resolveFieldType({ ...field, type: typeDef.inner } as Field);
    default:
      return 'String';
  }
}

function generatePrismaIndex(idx: IndexDecl): string {
  const fieldNames = idx.fields.map(f => f.name).join(', ');
  if (idx.unique) {
    return `@@unique([${fieldNames}])`;
  }
  return `@@index([${fieldNames}])`;
}
