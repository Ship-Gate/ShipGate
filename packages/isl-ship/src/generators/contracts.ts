/**
 * Runtime Contract Enforcement Generator
 *
 * Generates Express middleware that enforces ISL preconditions, postconditions,
 * and invariants at runtime. Every API call is verified against the spec.
 */

import type { Domain, Behavior, Entity, Expression } from '@isl-lang/parser';
import type { GeneratedFile } from '../types.js';
import { toCamelCase } from '../types.js';

export function generateContracts(domain: Domain): GeneratedFile[] {
  const files: GeneratedFile[] = [];

  // Main contract middleware
  files.push(generateContractMiddleware(domain));

  // Contract definitions (preconditions, postconditions, invariants)
  files.push(generateContractDefinitions(domain));

  // Error handler
  files.push(generateErrorHandler(domain));

  return files;
}

// ─── Contract Middleware ──────────────────────────────────────────────────────

function generateContractMiddleware(domain: Domain): GeneratedFile {
  const lines: string[] = [];

  lines.push('// =============================================================================');
  lines.push(`// Runtime Contract Enforcement — "${domain.name.name}"`);
  lines.push('// Enforces ISL preconditions, postconditions, and invariants at runtime.');
  lines.push('// Every API call is verified against the spec before and after execution.');
  lines.push('// DO NOT EDIT — This file is auto-generated by isl ship');
  lines.push('// =============================================================================');
  lines.push('');
  lines.push("import { Request, Response, NextFunction } from 'express';");
  lines.push("import { contracts, ContractViolation } from './contract-definitions.js';");
  lines.push('');

  // Contract violation error class
  lines.push('export class ContractViolationError extends Error {');
  lines.push('  public readonly violations: ContractViolation[];');
  lines.push('  public readonly phase: "precondition" | "postcondition" | "invariant";');
  lines.push('  public readonly behavior: string;');
  lines.push('');
  lines.push('  constructor(behavior: string, phase: "precondition" | "postcondition" | "invariant", violations: ContractViolation[]) {');
  lines.push('    const msg = `Contract violation in ${behavior} (${phase}): ${violations.map(v => v.message).join(", ")}`;');
  lines.push('    super(msg);');
  lines.push('    this.name = "ContractViolationError";');
  lines.push('    this.violations = violations;');
  lines.push('    this.phase = phase;');
  lines.push('    this.behavior = behavior;');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  // Main middleware
  lines.push('/**');
  lines.push(' * Express middleware that enforces ISL contracts at runtime.');
  lines.push(' * Wraps res.json to intercept responses and check postconditions.');
  lines.push(' */');
  lines.push('export function contractMiddleware(req: Request, res: Response, next: NextFunction): void {');
  lines.push('  // Store original json method');
  lines.push('  const originalJson = res.json.bind(res);');
  lines.push('');
  lines.push('  // Find matching contract for this route');
  lines.push('  const route = `${req.method} ${req.path}`;');
  lines.push('  const contract = contracts.find(c => matchRoute(c.method, c.path, req.method, req.path));');
  lines.push('');
  lines.push('  if (!contract) {');
  lines.push('    return next();');
  lines.push('  }');
  lines.push('');
  lines.push('  // ── Check preconditions ──');
  lines.push('  const preViolations: ContractViolation[] = [];');
  lines.push('  for (const pre of contract.preconditions) {');
  lines.push('    try {');
  lines.push('      if (!pre.check(req.body, req.params, req.query)) {');
  lines.push('        preViolations.push({ rule: pre.name, message: pre.message, phase: "precondition" });');
  lines.push('      }');
  lines.push('    } catch {');
  lines.push('      preViolations.push({ rule: pre.name, message: `Precondition check failed: ${pre.message}`, phase: "precondition" });');
  lines.push('    }');
  lines.push('  }');
  lines.push('');
  lines.push('  if (preViolations.length > 0) {');
  lines.push('    res.status(400).json({');
  lines.push('      error: "Contract violation",');
  lines.push('      phase: "precondition",');
  lines.push('      behavior: contract.behavior,');
  lines.push('      violations: preViolations,');
  lines.push('    });');
  lines.push('    return;');
  lines.push('  }');
  lines.push('');
  lines.push('  // ── Wrap response to check postconditions ──');
  lines.push('  res.json = ((data: unknown) => {');
  lines.push('    const postViolations: ContractViolation[] = [];');
  lines.push('    for (const post of contract.postconditions) {');
  lines.push('      try {');
  lines.push('        if (!post.check(data, req.body, req.params)) {');
  lines.push('          postViolations.push({ rule: post.name, message: post.message, phase: "postcondition" });');
  lines.push('        }');
  lines.push('      } catch {');
  lines.push('        // Postcondition check error — log but don\'t block');
  lines.push('        console.warn(`Postcondition check error for ${contract.behavior}: ${post.message}`);');
  lines.push('      }');
  lines.push('    }');
  lines.push('');
  lines.push('    if (postViolations.length > 0) {');
  lines.push('      console.warn(`[ISL Contract] Postcondition violations in ${contract.behavior}:`, postViolations);');
  lines.push('      // In strict mode, return error. In warn mode, log and continue.');
  lines.push('      if (process.env.ISL_CONTRACT_MODE === "strict") {');
  lines.push('        return originalJson({');
  lines.push('          error: "Contract violation",');
  lines.push('          phase: "postcondition",');
  lines.push('          behavior: contract.behavior,');
  lines.push('          violations: postViolations,');
  lines.push('          data,');
  lines.push('        });');
  lines.push('      }');
  lines.push('    }');
  lines.push('');
  lines.push('    return originalJson(data);');
  lines.push('  }) as Response["json"];');
  lines.push('');
  lines.push('  next();');
  lines.push('}');
  lines.push('');

  // Route matching helper
  lines.push('function matchRoute(contractMethod: string, contractPath: string, reqMethod: string, reqPath: string): boolean {');
  lines.push('  if (contractMethod !== reqMethod) return false;');
  lines.push('  // Convert :param patterns to regex');
  lines.push('  const pattern = contractPath.replace(/:([\\w]+)/g, "([^/]+)");');
  lines.push('  const regex = new RegExp(`^${pattern}$`);');
  lines.push('  return regex.test(reqPath);');
  lines.push('}');

  return {
    path: 'src/contracts.ts',
    content: lines.join('\n'),
    layer: 'contracts',
  };
}

// ─── Contract Definitions ─────────────────────────────────────────────────────

function generateContractDefinitions(domain: Domain): GeneratedFile {
  const lines: string[] = [];

  lines.push('// =============================================================================');
  lines.push(`// Contract Definitions — "${domain.name.name}"`);
  lines.push('// Generated from ISL preconditions, postconditions, and invariants.');
  lines.push('// DO NOT EDIT — This file is auto-generated by isl ship');
  lines.push('// =============================================================================');
  lines.push('');

  // Types
  lines.push('export interface ContractViolation {');
  lines.push('  rule: string;');
  lines.push('  message: string;');
  lines.push('  phase: "precondition" | "postcondition" | "invariant";');
  lines.push('}');
  lines.push('');
  lines.push('export interface PreconditionCheck {');
  lines.push('  name: string;');
  lines.push('  message: string;');
  lines.push('  check: (body: Record<string, unknown>, params: Record<string, string>, query: Record<string, unknown>) => boolean;');
  lines.push('}');
  lines.push('');
  lines.push('export interface PostconditionCheck {');
  lines.push('  name: string;');
  lines.push('  message: string;');
  lines.push('  check: (result: unknown, input: Record<string, unknown>, params: Record<string, string>) => boolean;');
  lines.push('}');
  lines.push('');
  lines.push('export interface RouteContract {');
  lines.push('  behavior: string;');
  lines.push('  method: string;');
  lines.push('  path: string;');
  lines.push('  preconditions: PreconditionCheck[];');
  lines.push('  postconditions: PostconditionCheck[];');
  lines.push('}');
  lines.push('');

  // Build route-to-behavior mapping from api blocks
  const routeMap = new Map<string, { method: string; path: string; behavior: string }>();
  for (const api of domain.apis) {
    const basePath = api.basePath?.value ?? '';
    for (const ep of api.endpoints) {
      if (ep.behavior) {
        routeMap.set(ep.behavior.name, {
          method: ep.method,
          path: basePath + ep.path.value,
          behavior: ep.behavior.name,
        });
      }
    }
  }

  // Generate contracts array
  lines.push('export const contracts: RouteContract[] = [');

  for (const behavior of domain.behaviors) {
    const route = routeMap.get(behavior.name.name);
    if (!route) continue;

    lines.push('  {');
    lines.push(`    behavior: "${behavior.name.name}",`);
    lines.push(`    method: "${route.method}",`);
    lines.push(`    path: "${route.path}",`);

    // Preconditions
    lines.push('    preconditions: [');
    for (let i = 0; i < (behavior.preconditions?.length ?? 0); i++) {
      const pre = behavior.preconditions[i]!;
      const exprStr = compileExpressionToJS(pre, 'input');
      const humanStr = expressionToHuman(pre);
      lines.push('      {');
      lines.push(`        name: "pre_${i}",`);
      lines.push(`        message: ${JSON.stringify(humanStr)},`);
      lines.push(`        check: (body) => { const input = body; try { return ${exprStr}; } catch { return false; } },`);
      lines.push('      },');
    }
    lines.push('    ],');

    // Postconditions
    lines.push('    postconditions: [');
    for (const postBlock of (behavior.postconditions ?? [])) {
      for (let i = 0; i < (postBlock.predicates?.length ?? 0); i++) {
        const post = postBlock.predicates[i]!;
        const exprStr = compileExpressionToJS(post, 'result');
        const humanStr = expressionToHuman(post);
        lines.push('      {');
        lines.push(`        name: "post_${i}",`);
        lines.push(`        message: ${JSON.stringify(humanStr)},`);
        lines.push(`        check: (result) => { try { return ${exprStr}; } catch { return false; } },`);
        lines.push('      },');
      }
    }
    lines.push('    ],');

    lines.push('  },');
  }

  lines.push('];');

  // Entity invariants
  lines.push('');
  lines.push('// ─── Entity Invariants ─────────────────────────────────────────────────────');
  lines.push('');
  lines.push('export interface EntityInvariant {');
  lines.push('  entity: string;');
  lines.push('  name: string;');
  lines.push('  message: string;');
  lines.push('  check: (data: Record<string, unknown>) => boolean;');
  lines.push('}');
  lines.push('');
  lines.push('export const entityInvariants: EntityInvariant[] = [');

  for (const entity of domain.entities) {
    for (let i = 0; i < (entity.invariants?.length ?? 0); i++) {
      const inv = entity.invariants[i]!;
      const exprStr = compileExpressionToJS(inv, 'data');
      const humanStr = expressionToHuman(inv);
      lines.push('  {');
      lines.push(`    entity: "${entity.name.name}",`);
      lines.push(`    name: "inv_${i}",`);
      lines.push(`    message: ${JSON.stringify(humanStr)},`);
      lines.push(`    check: (data) => { try { return ${exprStr}; } catch { return false; } },`);
      lines.push('  },');
    }
  }

  lines.push('];');
  lines.push('');

  // Validation helper
  lines.push('/**');
  lines.push(' * Validate entity data against invariants.');
  lines.push(' * Call this before writing to the database.');
  lines.push(' */');
  lines.push('export function validateEntity(entityName: string, data: Record<string, unknown>): ContractViolation[] {');
  lines.push('  return entityInvariants');
  lines.push('    .filter(inv => inv.entity === entityName)');
  lines.push('    .filter(inv => !inv.check(data))');
  lines.push('    .map(inv => ({ rule: inv.name, message: inv.message, phase: "invariant" as const }));');
  lines.push('}');

  return {
    path: 'src/contract-definitions.ts',
    content: lines.join('\n'),
    layer: 'contracts',
  };
}

// ─── Error Handler ────────────────────────────────────────────────────────────

function generateErrorHandler(domain: Domain): GeneratedFile {
  const lines: string[] = [];

  lines.push('// =============================================================================');
  lines.push(`// Error Handler — "${domain.name.name}"`);
  lines.push('// DO NOT EDIT — This file is auto-generated by isl ship');
  lines.push('// =============================================================================');
  lines.push('');
  lines.push("import { Request, Response, NextFunction } from 'express';");
  lines.push('');
  lines.push('export function errorHandler(err: Error, _req: Request, res: Response, _next: NextFunction): void {');
  lines.push('  console.error(`[Error] ${err.message}`);');
  lines.push('');
  lines.push('  if (err.name === "ContractViolationError") {');
  lines.push('    res.status(400).json({');
  lines.push('      error: "Contract violation",');
  lines.push('      message: err.message,');
  lines.push('    });');
  lines.push('    return;');
  lines.push('  }');
  lines.push('');
  lines.push('  res.status(500).json({');
  lines.push('    error: "Internal server error",');
  lines.push('    message: process.env.NODE_ENV === "development" ? err.message : "Something went wrong",');
  lines.push('  });');
  lines.push('}');

  return {
    path: 'src/error-handler.ts',
    content: lines.join('\n'),
    layer: 'backend',
  };
}

// ─── Expression Compiler ──────────────────────────────────────────────────────

/**
 * Compile an ISL expression AST node to a JavaScript boolean expression string.
 * This is the heart of runtime contract enforcement.
 */
function compileExpressionToJS(expr: Expression, rootVar: string): string {
  if (!expr) return 'true';

  switch (expr.kind) {
    case 'BinaryExpr': {
      const left = compileExpressionToJS(expr.left, rootVar);
      const right = compileExpressionToJS(expr.right, rootVar);
      const op = mapOperator(expr.operator);
      return `(${left} ${op} ${right})`;
    }
    case 'UnaryExpr': {
      const operand = compileExpressionToJS(expr.operand, rootVar);
      return `(!${operand})`;
    }
    case 'MemberExpr': {
      const obj = compileExpressionToJS(expr.object, rootVar);
      const prop = expr.property.kind === 'Identifier' ? expr.property.name : compileExpressionToJS(expr.property, rootVar);
      return `${obj}?.${prop}`;
    }
    case 'CallExpr': {
      const callee = compileExpressionToJS(expr.callee, rootVar);
      const args = expr.arguments.map((a: Expression) => compileExpressionToJS(a, rootVar)).join(', ');
      return `${callee}(${args})`;
    }
    case 'Identifier': {
      // Map 'input.X' to rootVar.X
      if (expr.name === 'input' || expr.name === 'result' || expr.name === 'this') {
        return rootVar;
      }
      return `${rootVar}?.${expr.name}`;
    }
    case 'QualifiedName': {
      const parts = expr.parts.map(p => p.name);
      if (parts[0] === 'input' || parts[0] === 'result') {
        return `${rootVar}?.${parts.slice(1).join('?.')}`;
      }
      return parts.join('?.');
    }
    case 'StringLiteral':
      return JSON.stringify(expr.value);
    case 'NumberLiteral':
      return String(expr.value);
    case 'BooleanLiteral':
      return String(expr.value);
    case 'NullLiteral':
      return 'null';
    default:
      return 'true';
  }
}

function mapOperator(op: string): string {
  switch (op) {
    case '==': return '===';
    case '!=': return '!==';
    case 'and': case '&&': return '&&';
    case 'or': case '||': return '||';
    case 'implies': return '? true :';
    default: return op;
  }
}

function expressionToHuman(expr: Expression): string {
  if (!expr) return '';
  switch (expr.kind) {
    case 'BinaryExpr':
      return `${expressionToHuman(expr.left)} ${expr.operator} ${expressionToHuman(expr.right)}`;
    case 'UnaryExpr':
      return `not ${expressionToHuman(expr.operand)}`;
    case 'MemberExpr':
      return `${expressionToHuman(expr.object)}.${expr.property.kind === 'Identifier' ? expr.property.name : expressionToHuman(expr.property)}`;
    case 'CallExpr':
      return `${expressionToHuman(expr.callee)}(${expr.arguments.map((a: Expression) => expressionToHuman(a)).join(', ')})`;
    case 'Identifier':
      return expr.name;
    case 'QualifiedName':
      return expr.parts.map(p => p.name).join('.');
    case 'StringLiteral':
      return `"${expr.value}"`;
    case 'NumberLiteral':
      return String(expr.value);
    case 'BooleanLiteral':
      return String(expr.value);
    default:
      return `<${expr.kind}>`;
  }
}
