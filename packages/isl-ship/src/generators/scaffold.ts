/**
 * Project Scaffold Generator
 *
 * Generates package.json, tsconfig, docker-compose, README, .env, etc.
 * Uses DatabaseAdapter for database-specific config.
 */

import type { Domain } from '@isl-lang/parser';
import type { GeneratedFile, ShipStack } from '../types.js';
import { toKebabCase } from '../types.js';
import { getDatabaseAdapter } from '../adapters/index.js';

export interface ScaffoldOptions {
  /** Override DATABASE_URL (from --db-url) */
  dbUrl?: string;
}

export function generateScaffold(domain: Domain, stack: ShipStack, projectName: string, options?: ScaffoldOptions): GeneratedFile[] {
  const files: GeneratedFile[] = [];
  const dbName = toKebabCase(domain.name.name);
  const useAdapter = stack.database === 'postgres' || stack.database === 'sqlite';
  const adapter = useAdapter ? getDatabaseAdapter(stack.database) : null;

  files.push(generatePackageJson(domain, stack, projectName, adapter));
  files.push(generateTsConfig());
  files.push(generateEnvFile(domain, stack, adapter, options?.dbUrl));
  files.push(generateEnvExample(domain, stack, adapter, options?.dbUrl));
  files.push(generateGitignore(stack));
  files.push(generateReadme(domain, stack, projectName));

  if (stack.docker) {
    files.push(generateDockerfile(projectName));
    if (stack.database === 'postgres' || stack.database === 'mysql') {
      files.push(generateDockerCompose(domain, stack, projectName, stack.database === 'postgres' ? (adapter ?? undefined) : undefined));
    }
  }

  return files;
}

// ─── package.json ─────────────────────────────────────────────────────────────

function generatePackageJson(domain: Domain, stack: ShipStack, projectName: string, adapter: ReturnType<typeof getDatabaseAdapter> | null): GeneratedFile {
  const [migrateDev, migrateDeploy] = adapter?.getMigrationCommands() ?? ['prisma migrate dev', 'prisma migrate deploy'];
  const seedCmd = adapter?.getSeedCommand() ?? 'prisma db seed';
  const pkg = {
    name: toKebabCase(projectName),
    version: domain.version?.value ?? '0.1.0',
    private: true,
    type: 'module',
    scripts: {
      dev: 'tsx watch src/server.ts',
      'dev:first': 'prisma db push && prisma db seed && tsx watch src/server.ts',
      build: 'tsc',
      start: 'node dist/server.js',
      'db:generate': 'prisma generate',
      'db:push': 'prisma db push',
      'db:prepare': 'prisma db push && prisma db seed',
      'db:migrate': migrateDev,
      'db:migrate:deploy': migrateDeploy,
      'db:seed': seedCmd,
      'db:studio': 'prisma studio',
      lint: 'eslint src/',
      test: 'vitest run',
    },
    dependencies: {
      express: '^4.21.0',
      cors: '^2.8.5',
      '@prisma/client': '^5.22.0',
      '@faker-js/faker': '^8.4.0',
      bcrypt: '^5.1.0',
      dotenv: '^16.4.0',
    },
    devDependencies: {
      '@types/bcrypt': '^5.0.0',
      '@types/express': '^5.0.0',
      '@types/cors': '^2.8.17',
      '@types/node': '^22.0.0',
      typescript: '^5.7.0',
      tsx: '^4.19.0',
      prisma: '^5.22.0',
      vitest: '^2.1.0',
      eslint: '^9.0.0',
    },
    prisma: {
      seed: 'tsx prisma/seed.ts',
    },
  };

  return {
    path: 'package.json',
    content: JSON.stringify(pkg, null, 2),
    layer: 'scaffold',
  };
}

// ─── tsconfig.json ────────────────────────────────────────────────────────────

function generateTsConfig(): GeneratedFile {
  const config = {
    compilerOptions: {
      target: 'ES2022',
      module: 'ESNext',
      moduleResolution: 'bundler',
      outDir: 'dist',
      rootDir: 'src',
      strict: true,
      esModuleInterop: true,
      skipLibCheck: true,
      forceConsistentCasingInFileNames: true,
      resolveJsonModule: true,
      declaration: true,
      sourceMap: true,
    },
    include: ['src'],
    exclude: ['dist', 'node_modules'],
  };

  return {
    path: 'tsconfig.json',
    content: JSON.stringify(config, null, 2),
    layer: 'scaffold',
  };
}

// ─── .env ─────────────────────────────────────────────────────────────────────

function generateEnvFile(domain: Domain, stack: ShipStack, adapter: ReturnType<typeof getDatabaseAdapter> | null, dbUrl?: string): GeneratedFile {
  const dbName = toKebabCase(domain.name.name);
  let envVars: Record<string, string>;
  if (adapter) {
    envVars = adapter.generateEnvVars({ dbName, dbUrl });
  } else {
    envVars = {
      NODE_ENV: 'development',
      PORT: '3000',
      DATABASE_URL: stack.database === 'mysql'
        ? `mysql://root:root@localhost:3306/${dbName}`
        : `postgresql://postgres:postgres@localhost:5432/${dbName}?schema=public`,
    };
  }

  const lines: string[] = [];
  lines.push(`# ${domain.name.name} — Environment Variables`);
  lines.push('# Generated by isl ship');
  lines.push('');
  for (const [key, value] of Object.entries(envVars)) {
    if (key !== 'DATABASE_URL_DOCKER') lines.push(`${key}=${value.startsWith('"') ? value : `"${value}"`}`);
  }

  if (domain.config) {
    lines.push('');
    lines.push('# From ISL config block');
    for (const entry of domain.config.entries) {
      if (entry.source === 'env') {
        const defaultVal = entry.defaultValue?.kind === 'NumberLiteral'
          ? String(entry.defaultValue.value)
          : entry.defaultValue?.kind === 'StringLiteral'
            ? entry.defaultValue.value
            : '';
        lines.push(`${entry.reference.value}=${defaultVal}`);
      } else if (entry.source === 'secret') {
        lines.push(`${entry.reference.value}=changeme`);
      }
    }
  }

  lines.push('');
  lines.push('# Runtime contract enforcement mode: "strict" | "warn" | "off"');
  lines.push('ISL_CONTRACT_MODE=warn');

  return {
    path: '.env',
    content: lines.join('\n'),
    layer: 'config',
  };
}

function generateEnvExample(domain: Domain, stack: ShipStack, adapter: ReturnType<typeof getDatabaseAdapter> | null, dbUrl?: string): GeneratedFile {
  const dbName = toKebabCase(domain.name.name);
  let envVars: Record<string, string>;
  if (adapter) {
    envVars = adapter.generateEnvVars({ dbName, dbUrl });
  } else {
    envVars = {
      NODE_ENV: 'development',
      PORT: '3000',
      DATABASE_URL: stack.database === 'mysql'
        ? `mysql://root:root@localhost:3306/${dbName}`
        : `postgresql://postgres:postgres@localhost:5432/${dbName}?schema=public`,
    };
  }

  const lines: string[] = [];
  lines.push(`# ${domain.name.name} — Environment Variables Template`);
  lines.push('# Copy to .env and fill in values');
  lines.push('');
  for (const [key, value] of Object.entries(envVars)) {
    if (key === 'DATABASE_URL_DOCKER') continue;
    if (key === 'DATABASE_URL' && adapter?.provider === 'postgresql') {
      lines.push('# Local:');
      lines.push(`${key}="${value}"`);
      const dockerUrl = envVars['DATABASE_URL_DOCKER'];
      if (dockerUrl) {
        lines.push('# Docker:');
        lines.push(`# ${key}="${dockerUrl}"`);
      }
    } else {
      lines.push(`${key}=${value.startsWith('"') ? value : `"${value}"`}`);
    }
  }

  if (domain.config) {
    for (const entry of domain.config.entries) {
      if (entry.source === 'env') {
        lines.push(`${entry.reference.value}=`);
      } else if (entry.source === 'secret') {
        lines.push(`# SECRET: ${entry.reference.value}=`);
      }
    }
  }

  lines.push('ISL_CONTRACT_MODE=warn');

  return {
    path: '.env.example',
    content: lines.join('\n'),
    layer: 'config',
  };
}

// ─── .gitignore ───────────────────────────────────────────────────────────────

function generateGitignore(stack: ShipStack): GeneratedFile {
  const lines = ['node_modules/', 'dist/', '.env', '.env.local', '*.log', '.DS_Store'];
  if (stack.database === 'sqlite' || stack.database === 'postgres') {
    lines.push('prisma/*.db', 'prisma/migrations/');
  }
  return {
    path: '.gitignore',
    content: lines.join('\n'),
    layer: 'scaffold',
  };
}

// ─── Dockerfile ───────────────────────────────────────────────────────────────

function generateDockerfile(projectName: string): GeneratedFile {
  return {
    path: 'Dockerfile',
    content: [
      '# ─── Build Stage ────────────────────────────────────────────────────────────',
      'FROM node:22-alpine AS builder',
      'WORKDIR /app',
      'COPY package*.json ./',
      'RUN npm ci',
      'COPY prisma ./prisma/',
      'RUN npx prisma generate',
      'COPY tsconfig.json ./',
      'COPY src ./src/',
      'RUN npm run build',
      '',
      '# ─── Production Stage ───────────────────────────────────────────────────────',
      'FROM node:22-alpine',
      'WORKDIR /app',
      'COPY --from=builder /app/dist ./dist/',
      'COPY --from=builder /app/node_modules ./node_modules/',
      'COPY --from=builder /app/package.json ./',
      'COPY --from=builder /app/prisma ./prisma/',
      '',
      'ENV NODE_ENV=production',
      'EXPOSE 3000',
      '',
      'CMD ["node", "dist/server.js"]',
    ].join('\n'),
    layer: 'scaffold',
  };
}

// ─── docker-compose.yml ───────────────────────────────────────────────────────

function generateDockerCompose(domain: Domain, stack: ShipStack, projectName: string, adapter?: ReturnType<typeof getDatabaseAdapter>): GeneratedFile {
  const kebab = toKebabCase(projectName);
  const dbName = toKebabCase(domain.name.name);

  const lines: string[] = [];
  lines.push('version: "3.8"');
  lines.push('');
  lines.push('services:');

  // App service
  lines.push(`  ${kebab}:`);
  lines.push('    build: .');
  lines.push('    ports:');
  lines.push('      - "3000:3000"');
  lines.push('    environment:');
  if (stack.database === 'postgres' && adapter) {
    const envVars = adapter.generateEnvVars({ dbName });
    const dockerUrl = envVars['DATABASE_URL_DOCKER'] ?? `postgresql://postgres:postgres@db:5432/${dbName}?schema=public`;
    lines.push(`      - DATABASE_URL=${dockerUrl}`);
  } else if (stack.database === 'mysql') {
    lines.push(`      - DATABASE_URL=mysql://root:root@db:3306/${dbName}`);
  }
  lines.push('      - NODE_ENV=development');
  lines.push('      - ISL_CONTRACT_MODE=warn');
  if (stack.database === 'postgres' || stack.database === 'mysql') {
    lines.push('    depends_on:');
    lines.push('      db:');
    lines.push('        condition: service_healthy');
  }
  lines.push('    volumes:');
  lines.push('      - ./src:/app/src');
  lines.push('');

  // Database service (Postgres 16 + healthcheck)
  if (stack.database === 'postgres' && adapter?.getDockerComposeService) {
    const dbService = adapter.getDockerComposeService({ dbName });
    lines.push('  db:');
    lines.push(`    image: ${(dbService as { image?: string }).image ?? 'postgres:16-alpine'}`);
    lines.push('    environment:');
    for (const [k, v] of Object.entries((dbService as { environment?: Record<string, string> }).environment ?? {})) {
      lines.push(`      ${k}: ${v}`);
    }
    lines.push('    ports:');
    lines.push('      - "5432:5432"');
    lines.push('    volumes:');
    lines.push('      - pgdata:/var/lib/postgresql/data');
    lines.push('    healthcheck:');
    const hc = (dbService as { healthcheck?: Record<string, unknown> }).healthcheck;
    if (hc) {
      lines.push('      test: ["CMD-SHELL", "pg_isready -U postgres"]');
      lines.push('      interval: 5s');
      lines.push('      timeout: 5s');
      lines.push('      retries: 5');
    }
  } else if (stack.database === 'mysql') {
    lines.push('  db:');
    lines.push('    image: mysql:8');
    lines.push('    environment:');
    lines.push('      MYSQL_ROOT_PASSWORD: root');
    lines.push(`      MYSQL_DATABASE: ${dbName}`);
    lines.push('    ports:');
    lines.push('      - "3306:3306"');
    lines.push('    volumes:');
    lines.push('      - mysqldata:/var/lib/mysql');
  }

  lines.push('');
  lines.push('volumes:');
  if (stack.database === 'postgres') {
    lines.push('  pgdata:');
  } else if (stack.database === 'mysql') {
    lines.push('  mysqldata:');
  }

  return {
    path: 'docker-compose.yml',
    content: lines.join('\n'),
    layer: 'scaffold',
  };
}

// ─── README ───────────────────────────────────────────────────────────────────

function generateReadme(domain: Domain, stack: ShipStack, projectName: string): GeneratedFile {
  const lines: string[] = [];

  lines.push(`# ${projectName}`);
  lines.push('');
  lines.push(`> Generated from ISL specification by \`isl ship\``);
  lines.push('');
  lines.push('## Stack');
  lines.push('');
  lines.push(`| Layer | Technology |`);
  lines.push(`|-------|-----------|`);
  lines.push(`| Backend | ${stack.backend} |`);
  lines.push(`| Database | ${stack.database} |`);
  lines.push(`| ORM | ${stack.orm} |`);
  lines.push(`| Runtime Contracts | ${stack.runtime ? 'Enabled' : 'Disabled'} |`);
  lines.push('');
  lines.push('## Quick Start');
  lines.push('');
  lines.push('```bash');
  lines.push('# Install dependencies');
  lines.push('npm install');
  lines.push('');
  lines.push('# Start database');
  lines.push('docker compose up -d db');
  lines.push('');
  lines.push('# First run: push schema + seed (or use npm run dev:first)');
  lines.push('npm run db:prepare');
  lines.push('');
  lines.push('# Start dev server');
  lines.push('npm run dev');
  lines.push('```');
  lines.push('');
  lines.push('## Runtime Contract Enforcement');
  lines.push('');
  lines.push('This app includes **ISL runtime contract enforcement**. Every API request is');
  lines.push('verified against the ISL specification:');
  lines.push('');
  lines.push('- **Preconditions** are checked before handler execution');
  lines.push('- **Postconditions** are checked after handler execution');
  lines.push('- **Entity invariants** are checked before database writes');
  lines.push('');
  lines.push('Set `ISL_CONTRACT_MODE` in `.env`:');
  lines.push('- `strict` — Block requests that violate contracts (recommended for dev)');
  lines.push('- `warn` — Log violations but allow requests (default)');
  lines.push('- `off` — Disable contract checking (production)');
  lines.push('');

  // API docs
  if (domain.apis.length > 0) {
    lines.push('## API Endpoints');
    lines.push('');
    for (const api of domain.apis) {
      const base = api.basePath?.value ?? '';
      for (const ep of api.endpoints) {
        const behavior = ep.behavior ? ` → ${ep.behavior.name}` : '';
        lines.push(`- \`${ep.method} ${base}${ep.path.value}\`${behavior}`);
      }
    }
    lines.push('');
  }

  // Entities
  lines.push('## Entities');
  lines.push('');
  for (const entity of domain.entities) {
    lines.push(`### ${entity.name.name}`);
    lines.push('');
    lines.push('| Field | Type |');
    lines.push('|-------|------|');
    for (const field of entity.fields) {
      const typeName = field.type?.kind === 'ReferenceType'
        ? field.type.name.parts.map(p => p.name).join('.')
        : field.type?.kind ?? 'unknown';
      lines.push(`| ${field.name.name} | ${typeName}${field.optional ? '?' : ''} |`);
    }
    lines.push('');
  }

  lines.push('---');
  lines.push(`*Generated by ISL Ship v0.1.0 from \`${domain.name.name}\` domain*`);

  return {
    path: 'README.md',
    content: lines.join('\n'),
    layer: 'scaffold',
  };
}
