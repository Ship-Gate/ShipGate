/**
 * Backend API Generator
 *
 * Generates Express/Fastify API routes from ISL api blocks + behaviors.
 */

import type { Domain, ApiBlock, EndpointDecl, Behavior, Entity, Field, TypeDefinition } from '@isl-lang/parser';
import type { GeneratedFile, ShipStack } from '../types.js';
import { toCamelCase, toKebabCase, islTypeToTS } from '../types.js';

export function generateBackend(domain: Domain, stack: ShipStack): GeneratedFile[] {
  const files: GeneratedFile[] = [];
  const domainName = domain.name.name;
  const lowerName = toKebabCase(domainName);

  // Generate entity types
  files.push(generateEntityTypes(domain));

  // Generate route files from api blocks
  if (domain.apis.length > 0) {
    for (const api of domain.apis) {
      files.push(generateRouteFile(api, domain, stack));
    }
  } else {
    // Auto-generate CRUD routes from entities + behaviors
    files.push(generateAutoRoutes(domain, stack));
  }

  // Generate behavior service stubs
  files.push(generateServices(domain));

  // Generate main server entry point
  files.push(generateServerEntry(domain, stack));

  return files;
}

// â”€â”€â”€ Entity Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function generateEntityTypes(domain: Domain): GeneratedFile {
  const lines: string[] = [];

  lines.push('// =============================================================================');
  lines.push(`// Types â€” Generated from ISL domain "${domain.name.name}"`);
  lines.push('// DO NOT EDIT â€” This file is auto-generated by isl ship');
  lines.push('// =============================================================================');
  lines.push('');

  for (const entity of domain.entities) {
    lines.push(`export interface ${entity.name.name} {`);
    for (const field of entity.fields) {
      const tsType = resolveTypeToTS(field);
      const optional = field.optional ? '?' : '';
      lines.push(`  ${field.name.name}${optional}: ${tsType};`);
    }
    lines.push('}');
    lines.push('');

    // Generate create input type (exclude immutable/auto fields)
    const createFields = entity.fields.filter(f => {
      const annots = f.annotations ?? [];
      const isImmutable = annots.some(a => a.name.name === 'immutable');
      const isId = f.name.name === 'id';
      const isTimestamp = f.name.name === 'created_at' || f.name.name === 'updated_at';
      return !isId && !isTimestamp && !isImmutable;
    });

    if (createFields.length > 0) {
      lines.push(`export interface Create${entity.name.name}Input {`);
      for (const field of createFields) {
        const tsType = resolveTypeToTS(field);
        const optional = field.optional ? '?' : '';
        lines.push(`  ${field.name.name}${optional}: ${tsType};`);
      }
      lines.push('}');
      lines.push('');
    }
  }

  // Generate behavior input/output types
  for (const behavior of domain.behaviors) {
    if (behavior.input?.fields?.length) {
      lines.push(`export interface ${behavior.name.name}Input {`);
      for (const field of behavior.input.fields) {
        const tsType = resolveTypeToTS(field);
        const optional = field.optional ? '?' : '';
        lines.push(`  ${field.name.name}${optional}: ${tsType};`);
      }
      lines.push('}');
      lines.push('');
    }
  }

  return {
    path: 'src/types.ts',
    content: lines.join('\n'),
    layer: 'backend',
  };
}

function resolveTypeToTS(field: { type?: TypeDefinition }): string {
  const typeDef = field.type;
  if (!typeDef) return 'unknown';

  switch (typeDef.kind) {
    case 'PrimitiveType':
      return islTypeToTS(typeDef.name);
    case 'ReferenceType':
      return islTypeToTS(typeDef.name.parts.map(p => p.name).join('.'));
    case 'ListType':
      return resolveTypeToTS({ type: typeDef.element }) + '[]';
    case 'OptionalType':
      return resolveTypeToTS({ type: typeDef.inner }) + ' | null';
    default:
      return 'unknown';
  }
}

// â”€â”€â”€ Route Files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function generateRouteFile(api: ApiBlock, domain: Domain, stack: ShipStack): GeneratedFile {
  const lines: string[] = [];
  const basePath = api.basePath?.value ?? '/api';

  lines.push('// =============================================================================');
  lines.push(`// API Routes â€” Generated from ISL domain "${domain.name.name}"`);
  lines.push('// DO NOT EDIT â€” This file is auto-generated by isl ship');
  lines.push('// =============================================================================');
  lines.push('');
  lines.push("import { Router, Request, Response, NextFunction } from 'express';");
  lines.push("import { PrismaClient } from '@prisma/client';");
  lines.push("import { contractMiddleware } from './contracts.js';");
  lines.push('');
  lines.push('const router = Router();');
  lines.push('const prisma = new PrismaClient();');
  lines.push('');

  for (const endpoint of api.endpoints) {
    lines.push(...generateEndpointHandler(endpoint, domain));
    lines.push('');
  }

  lines.push('export default router;');

  return {
    path: 'src/routes.ts',
    content: lines.join('\n'),
    layer: 'backend',
  };
}

function generateEndpointHandler(endpoint: EndpointDecl, domain: Domain): string[] {
  const lines: string[] = [];
  const method = endpoint.method.toLowerCase();
  const path = endpoint.path.value;
  const behaviorName = endpoint.behavior?.name;

  // Find linked behavior
  const behavior = behaviorName
    ? domain.behaviors.find(b => b.name.name === behaviorName)
    : undefined;

  // Convert Express-style params
  const expressPath = path.replace(/:(\w+)/g, ':$1');

  lines.push(`// ${endpoint.method} ${path}${behavior ? ` â†’ ${behaviorName}` : ''}`);
  lines.push(`router.${method}('${expressPath}', async (req: Request, res: Response, next: NextFunction) => {`);
  lines.push('  try {');

  if (behavior) {
    // Generate behavior-linked handler
    const inputFields = behavior.input?.fields ?? [];
    if (inputFields.length > 0) {
      lines.push('    const input = {');
      for (const field of inputFields) {
        if (method === 'get' || method === 'delete') {
          lines.push(`      ${field.name.name}: req.params.${field.name.name} ?? req.query.${field.name.name},`);
        } else {
          lines.push(`      ${field.name.name}: req.body.${field.name.name},`);
        }
      }
      lines.push('    };');
      lines.push('');
    }

    lines.push(`    // TODO: Implement ${behaviorName} logic`);
    lines.push(`    // const result = await ${toCamelCase(behaviorName!)}Service.execute(input);`);
    lines.push('    res.json({ success: true, data: {} });');
  } else {
    // Generate generic handler
    lines.push(`    // TODO: Implement handler for ${endpoint.method} ${path}`);
    lines.push('    res.json({ success: true });');
  }

  lines.push('  } catch (error) {');
  lines.push('    next(error);');
  lines.push('  }');
  lines.push('});');

  return lines;
}

function generateAutoRoutes(domain: Domain, stack: ShipStack): GeneratedFile {
  const lines: string[] = [];

  lines.push('// =============================================================================');
  lines.push(`// Auto-generated CRUD Routes â€” "${domain.name.name}"`);
  lines.push('// DO NOT EDIT â€” This file is auto-generated by isl ship');
  lines.push('// =============================================================================');
  lines.push('');
  lines.push("import { Router, Request, Response, NextFunction } from 'express';");
  lines.push("import { PrismaClient } from '@prisma/client';");
  lines.push('');
  lines.push('const router = Router();');
  lines.push('const prisma = new PrismaClient();');
  lines.push('');

  for (const entity of domain.entities) {
    const name = entity.name.name;
    const lower = toCamelCase(name);
    const plural = lower + 's';

    lines.push(`// â”€â”€â”€ ${name} CRUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`);
    lines.push('');

    // List
    lines.push(`router.get('/${plural}', async (_req: Request, res: Response) => {`);
    lines.push(`  const items = await prisma.${lower}.findMany();`);
    lines.push('  res.json(items);');
    lines.push('});');
    lines.push('');

    // Get by ID
    lines.push(`router.get('/${plural}/:id', async (req: Request, res: Response) => {`);
    lines.push(`  const item = await prisma.${lower}.findUnique({ where: { id: req.params.id } });`);
    lines.push('  if (!item) return res.status(404).json({ error: "Not found" });');
    lines.push('  res.json(item);');
    lines.push('});');
    lines.push('');

    // Create
    lines.push(`router.post('/${plural}', async (req: Request, res: Response) => {`);
    lines.push(`  const item = await prisma.${lower}.create({ data: req.body });`);
    lines.push('  res.status(201).json(item);');
    lines.push('});');
    lines.push('');

    // Update
    lines.push(`router.patch('/${plural}/:id', async (req: Request, res: Response) => {`);
    lines.push(`  const item = await prisma.${lower}.update({ where: { id: req.params.id }, data: req.body });`);
    lines.push('  res.json(item);');
    lines.push('});');
    lines.push('');

    // Delete
    lines.push(`router.delete('/${plural}/:id', async (req: Request, res: Response) => {`);
    lines.push(`  await prisma.${lower}.delete({ where: { id: req.params.id } });`);
    lines.push('  res.status(204).send();');
    lines.push('});');
    lines.push('');
  }

  lines.push('export default router;');

  return {
    path: 'src/routes.ts',
    content: lines.join('\n'),
    layer: 'backend',
  };
}

// â”€â”€â”€ Services â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function generateServices(domain: Domain): GeneratedFile {
  const lines: string[] = [];

  lines.push('// =============================================================================');
  lines.push(`// Services â€” Generated from ISL domain "${domain.name.name}"`);
  lines.push('// DO NOT EDIT â€” This file is auto-generated by isl ship');
  lines.push('// =============================================================================');
  lines.push('');
  lines.push("import { PrismaClient } from '@prisma/client';");
  lines.push('');
  lines.push('const prisma = new PrismaClient();');
  lines.push('');

  for (const behavior of domain.behaviors) {
    const name = behavior.name.name;
    const inputType = behavior.input?.fields?.length ? `${name}Input` : 'void';

    lines.push(`// â”€â”€â”€ ${name} â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`);
    lines.push(`export async function ${toCamelCase(name)}(input: ${inputType}): Promise<unknown> {`);
    lines.push(`  // TODO: Implement ${name}`);

    // Add precondition comments
    if (behavior.preconditions?.length) {
      lines.push('  // Preconditions:');
      for (const pre of behavior.preconditions) {
        lines.push(`  //   - ${expressionToString(pre)}`);
      }
    }

    lines.push('  throw new Error("Not implemented");');
    lines.push('}');
    lines.push('');
  }

  if (domain.behaviors.length > 0) {
    lines.push('// Re-export input types');
    lines.push("export type { " + domain.behaviors
      .filter(b => b.input?.fields?.length)
      .map(b => `${b.name.name}Input`)
      .join(', ') + " } from './types.js';");
  }

  return {
    path: 'src/services.ts',
    content: lines.join('\n'),
    layer: 'backend',
  };
}

// â”€â”€â”€ Server Entry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function generateServerEntry(domain: Domain, stack: ShipStack): GeneratedFile {
  const lines: string[] = [];
  const domainName = domain.name.name;

  // Find port from config block
  let port = '3000';
  if (domain.config) {
    const portEntry = domain.config.entries.find(e => e.key.name === 'port');
    if (portEntry?.defaultValue?.kind === 'NumberLiteral') {
      port = String(portEntry.defaultValue.value);
    }
  }

  lines.push('// =============================================================================');
  lines.push(`// Server â€” ${domainName}`);
  lines.push('// DO NOT EDIT â€” This file is auto-generated by isl ship');
  lines.push('// =============================================================================');
  lines.push('');
  lines.push("import express from 'express';");
  lines.push("import cors from 'cors';");
  lines.push("import router from './routes.js';");
  lines.push("import { contractMiddleware } from './contracts.js';");
  lines.push("import { errorHandler } from './error-handler.js';");
  lines.push('');
  lines.push('const app = express();');
  lines.push(`const PORT = process.env.PORT ?? ${port};`);
  lines.push('');
  lines.push('// Middleware');
  lines.push('app.use(cors());');
  lines.push('app.use(express.json());');
  lines.push('app.use(contractMiddleware);');
  lines.push('');
  lines.push('// Routes');

  if (domain.apis.length > 0 && domain.apis[0]?.basePath) {
    lines.push(`app.use('${domain.apis[0].basePath.value}', router);`);
  } else {
    lines.push("app.use('/api', router);");
  }

  lines.push('');
  lines.push('// Error handling');
  lines.push('app.use(errorHandler);');
  lines.push('');
  lines.push('app.listen(PORT, () => {');
  lines.push(`  console.log(\`ðŸš€ ${domainName} server running on http://localhost:\${PORT}\`);`);
  lines.push('});');
  lines.push('');
  lines.push('export default app;');

  return {
    path: 'src/server.ts',
    content: lines.join('\n'),
    layer: 'backend',
  };
}

// â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function expressionToString(expr: { kind: string; name?: string; left?: unknown; right?: unknown; op?: string; value?: unknown }): string {
  if (!expr) return '';
  switch (expr.kind) {
    case 'Identifier': return expr.name ?? '';
    case 'MemberExpr': return `${expressionToString(expr as never)}.${expressionToString(expr as never)}`;
    case 'BinaryExpr': return `${expressionToString(expr.left as typeof expr)} ${expr.op ?? ''} ${expressionToString(expr.right as typeof expr)}`;
    case 'StringLiteral': return `"${String(expr.value)}"`;
    case 'NumberLiteral': return String(expr.value);
    case 'BooleanLiteral': return String(expr.value);
    default: return `<${expr.kind}>`;
  }
}
