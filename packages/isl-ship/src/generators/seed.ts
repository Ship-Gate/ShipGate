/**
 * Seed Generator
 *
 * Generates prisma/seed.ts from ISL entities and scenario blocks.
 * Uses @faker-js/faker for realistic data that satisfies ISL constraints.
 */

import type { Domain, Entity, Field } from '@isl-lang/parser';
import type { GeneratedFile, ShipStack } from '../types.js';

const DEMO_PASSWORD = 'demo1234';
const DEMO_USERS = [
  { email: 'admin@demo.com', role: 'ADMIN', name: 'Admin Demo' },
  { email: 'author@demo.com', role: 'AUTHOR', name: 'Author Demo' },
  { email: 'user@demo.com', role: 'USER', name: 'User Demo' },
];

export interface SeedGeneratorOptions {
  /** Records per entity (default 10) */
  recordsPerEntity?: number;
  /** Include scenario-specific fixture records */
  includeScenarioFixtures?: boolean;
}

/**
 * Generate prisma/seed.ts from ISL domain.
 */
export function generateSeed(
  domain: Domain,
  stack: ShipStack,
  options: SeedGeneratorOptions = {}
): GeneratedFile {
  const recordsPerEntity = options.recordsPerEntity ?? 10;
  const includeScenarioFixtures = options.includeScenarioFixtures ?? true;

  const content = generateSeedContent(domain, stack, recordsPerEntity, includeScenarioFixtures);

  return {
    path: 'prisma/seed.ts',
    content,
    layer: 'database',
  };
}

function generateSeedContent(
  domain: Domain,
  _stack: ShipStack,
  recordsPerEntity: number,
  _includeScenarioFixtures: boolean
): string {
  const lines: string[] = [];
  lines.push('// =============================================================================');
  lines.push(`// Prisma Seed — Generated from ISL domain "${domain.name.name}"`);
  lines.push('// DO NOT EDIT — Auto-generated by isl ship / isl seed generate');
  lines.push('// =============================================================================');
  lines.push('');
  lines.push('import { PrismaClient } from "@prisma/client";');
  lines.push('import { faker } from "@faker-js/faker";');
  lines.push('import * as bcrypt from "bcrypt";');
  lines.push('');
  lines.push('const prisma = new PrismaClient();');
  lines.push('');
  lines.push('async function main() {');
  lines.push('  faker.seed(42);');
  lines.push('');

  const userEntity = domain.entities.find((e) =>
    ['User', 'user'].includes(e.name.name)
  );
  const hasUserWithAuth = userEntity && hasEmailAndPassword(userEntity);

  const entityOrder = computeEntityOrder(domain);
  const idMaps = new Map<string, string>();

  if (hasUserWithAuth) {
    lines.push('  // Demo accounts: admin@demo.com, author@demo.com, user@demo.com (password: demo1234)');
    lines.push('  const passwordHash = await bcrypt.hash("demo1234", 10);');
    const userModelName = userEntity!.name.name;
    lines.push(`  const ${userModelName}Ids: string[] = [];`);
    for (const demo of DEMO_USERS) {
      const createArgs = buildUserCreateArgs(userEntity!, demo);
      lines.push(`  const demo${demo.role.toLowerCase()} = await prisma.${userModelName}.upsert({`);
      lines.push(`    where: { email: "${demo.email}" },`);
      lines.push(`    create: { ${createArgs} },`);
      lines.push(`    update: {},`);
      lines.push('  });');
      lines.push(`  ${userModelName}Ids.push(demo${demo.role.toLowerCase()}.id);`);
    }
    // Create additional fake users for FK references (7 more to reach 10)
    for (let i = 0; i < 7; i++) {
      const createArgs = buildFakeUserCreateArgs(userEntity!);
      lines.push(`  const fakeUser${i} = await prisma.${userModelName}.create({`);
      lines.push(`    data: { ${createArgs} },`);
      lines.push('  });');
      lines.push(`  ${userModelName}Ids.push(fakeUser${i}.id);`);
    }
    idMaps.set(userModelName, `${userModelName}Ids`);
    lines.push('');
  }

  for (const entity of entityOrder) {
    const modelName = entity.name.name;
    if (hasUserWithAuth && (modelName === 'User' || modelName === 'user')) {
      continue;
    }

    const varName = modelName.toLowerCase() + 'Ids';
    lines.push(`  const ${varName}: string[] = [];`);
    idMaps.set(modelName, varName);

    const count = recordsPerEntity;
    for (let i = 0; i < count; i++) {
      const dataExpr = buildRecordDataExpr(entity, domain, idMaps, userEntity, i);
      lines.push(`  const rec${modelName}${i} = await prisma.${modelName}.create({`);
      lines.push(`    data: ${dataExpr},`);
      lines.push('  });');
      lines.push(`  ${varName}.push(rec${modelName}${i}.id);`);
    }
    lines.push('');
  }

  lines.push('  console.log("Seed completed.");');
  lines.push('}');
  lines.push('');
  lines.push('main()');
  lines.push('  .catch((e) => {');
  lines.push('    console.error(e);');
  lines.push('    process.exit(1);');
  lines.push('  })');
  lines.push('  .finally(async () => {');
  lines.push('    await prisma.$disconnect();');
  lines.push('  });');

  return lines.join('\n');
}

function hasEmailAndPassword(entity: Entity): boolean {
  const names = entity.fields.map((f) => f.name.name.toLowerCase());
  return (
    names.includes('email') &&
    (names.includes('password') || names.includes('passwordhash'))
  );
}

function buildUserCreateArgs(
  entity: Entity,
  demo: { email: string; role: string; name: string }
): string {
  const parts: string[] = [];
  for (const field of entity.fields) {
    const name = field.name.name;
    if (name === 'id') continue;
    if (name.toLowerCase() === 'email') {
      parts.push(`${name}: "${demo.email}"`);
    } else if (
      name.toLowerCase() === 'passwordhash' ||
      name.toLowerCase() === 'password'
    ) {
      parts.push(`${name}: passwordHash`);
    } else if (name.toLowerCase() === 'role') {
      parts.push(`${name}: "${demo.role}"`);
    } else if (name.toLowerCase() === 'name') {
      parts.push(`${name}: "${demo.name}"`);
    } else if (name.toLowerCase() === 'username') {
      parts.push(`${name}: "${demo.email.split('@')[0]}"`);
    } else if (name === 'createdAt' || name === 'created_at') {
      parts.push(`${name}: new Date()`);
    } else if (name === 'updatedAt' || name === 'updated_at') {
      parts.push(`${name}: new Date()`);
    }
  }
  return parts.join(', ');
}

function buildFakeUserCreateArgs(entity: Entity): string {
  const parts: string[] = [];
  for (const field of entity.fields) {
    const name = field.name.name;
    if (name === 'id') continue;
    const val = fakerValueForField(field, entity, new Map(), undefined);
    parts.push(`${name}: ${val}`);
  }
  return parts.join(', ');
}

function buildRecordDataExpr(
  entity: Entity,
  domain: Domain,
  idMaps: Map<string, string>,
  userEntity: Entity | undefined,
  index: number
): string {
  const parts: string[] = [];

  for (const field of entity.fields) {
    const name = field.name.name;
    const refAnn = field.annotations?.find((a) => a.name.name === 'references');
    const refEntity =
      refAnn?.value && refAnn.value.kind === 'Identifier'
        ? refAnn.value.name
        : refAnn?.value
          ? String(refAnn.value)
          : null;

    if (name === 'id') continue;
    if (name === 'createdAt' || name === 'created_at') {
      parts.push(`${name}: faker.date.recent({ days: 30 })`);
      continue;
    }
    if (name === 'updatedAt' || name === 'updated_at') {
      parts.push(`${name}: new Date()`);
      continue;
    }

    if (refEntity && idMaps.has(refEntity)) {
      const refIds = idMaps.get(refEntity)!;
      parts.push(`${name}: ${refIds}[${index % 10}] ?? ${refIds}[0]`);
      continue;
    }

    const val = fakerValueForField(field, entity, idMaps, userEntity);
    parts.push(`${name}: ${val}`);
  }

  return '{ ' + parts.join(', ') + ' }';
}

function fakerValueForField(
  field: Field,
  entity: Entity,
  idMaps: Map<string, string>,
  userEntity: Entity | undefined
): string {
  const name = field.name.name.toLowerCase();
  const baseType = getBaseType(field.type);
  const constraints = getConstraints(field.type);

  if (name.includes('email')) return 'faker.internet.email()';
  if (name.includes('name') && !name.includes('filename'))
    return 'faker.person.fullName()';
  if (name.includes('title'))
    return 'faker.lorem.sentence({ min: 3, max: 8 })';
  if (name.includes('description')) return 'faker.lorem.paragraph()';
  if (
    name.includes('image') ||
    name.includes('avatar') ||
    name.includes('photo') ||
    name.includes('url')
  ) {
    return `"https://picsum.photos/seed/${entity.name.name}${field.name.name}/400/300"`;
  }
  if (name.includes('url') && !name.includes('image'))
    return 'faker.internet.url()';
  if (name.includes('status')) {
    return 'faker.helpers.arrayElement(["active", "pending", "completed", "archived"])';
  }
  if (name.includes('priority')) {
    const min = (constraints.min as number) ?? 1;
    const max = (constraints.max as number) ?? 5;
    return `faker.number.int({ min: ${min}, max: ${max} })`;
  }

  switch (baseType) {
    case 'String':
      return stringFaker(constraints);
    case 'Int':
      return intFaker(constraints);
    case 'Float':
    case 'Decimal':
      return floatFaker(constraints);
    case 'Boolean':
      return 'faker.datatype.boolean()';
    case 'DateTime':
    case 'Timestamp':
      return 'faker.date.recent({ days: 90 })';
    case 'UUID':
      return 'faker.string.uuid()';
    default:
      return 'faker.lorem.word()';
  }
}

function stringFaker(constraints: Record<string, unknown>): string {
  const minLen = (constraints.min_length as number) ?? 1;
  const maxLen = (constraints.max_length as number) ?? 255;
  if (maxLen <= 10)
    return `faker.string.alphanumeric({ length: ${Math.min(maxLen, 10)} })`;
  return `faker.lorem.sentence({ min: ${Math.max(1, minLen)}, max: ${Math.min(maxLen, 50)} })`;
}

function intFaker(constraints: Record<string, unknown>): string {
  const min = (constraints.min as number) ?? 0;
  const max = (constraints.max as number) ?? 1000;
  return `faker.number.int({ min: ${min}, max: ${max} })`;
}

function floatFaker(constraints: Record<string, unknown>): string {
  const min = (constraints.min as number) ?? 0;
  const max = (constraints.max as number) ?? 1000;
  return `faker.number.float({ min: ${min}, max: ${max}, fractionDigits: 2 })`;
}

function getBaseType(typeDef: unknown): string {
  if (!typeDef || typeof typeDef !== 'object') return 'String';
  const t = typeDef as { kind?: string; base?: unknown; inner?: unknown };
  if (t.kind === 'ConstrainedType' && t.base) return getBaseType(t.base);
  if (t.kind === 'OptionalType' && t.inner) return getBaseType(t.inner);
  if (t.kind === 'PrimitiveType')
    return (typeDef as { name: string }).name ?? 'String';
  if (t.kind === 'ReferenceType') return 'String';
  return 'String';
}

function getConstraints(typeDef: unknown): Record<string, unknown> {
  const out: Record<string, unknown> = {};
  if (!typeDef || typeof typeDef !== 'object') return out;
  const t = typeDef as {
    kind?: string;
    constraints?: Array<{ name?: { name?: string }; value?: { value?: unknown } }>;
    base?: unknown;
  };
  if (t.kind === 'ConstrainedType' && t.constraints) {
    for (const c of t.constraints) {
      const constraintName =
        typeof c.name === 'string' ? c.name : c.name?.name;
      const v =
        c.value && typeof c.value === 'object' && 'value' in c.value
          ? (c.value as { value: unknown }).value
          : c.value;
      if (typeof constraintName === 'string') out[constraintName] = v;
    }
  }
  if (t.kind === 'ConstrainedType' && t.base) {
    Object.assign(out, getConstraints(t.base));
  }
  return out;
}

function computeEntityOrder(domain: Domain): Entity[] {
  const entities = [...domain.entities];
  const refs = new Map<string, string>();
  for (const e of entities) {
    for (const f of e.fields) {
      const ann = f.annotations?.find((a) => a.name.name === 'references');
      if (ann?.value) {
        const target =
          ann.value.kind === 'Identifier' ? ann.value.name : String(ann.value);
        refs.set(e.name.name, target);
      }
    }
  }
  const sorted: Entity[] = [];
  const added = new Set<string>();
  const add = (name: string) => {
    if (added.has(name)) return;
    const dep = refs.get(name);
    if (dep && !added.has(dep)) add(dep);
    const ent = entities.find((e) => e.name.name === name);
    if (ent) {
      sorted.push(ent);
      added.add(name);
    }
  };
  for (const e of entities) add(e.name.name);
  return sorted;
}
