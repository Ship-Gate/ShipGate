/**
 * Config & ISL Templates
 *
 * Generates .shipgate.yml configuration and ISL specs
 * based on detected project profile and patterns.
 */

import type { ProjectProfile, DetectedPattern } from './detect.js';

// ─────────────────────────────────────────────────────────────────────────────
// .shipgate.yml Generation
// ─────────────────────────────────────────────────────────────────────────────

export interface ShipGateYmlOptions {
  criticalDirs: string[];
  testPattern: string;
  language: ProjectProfile['language'];
}

/**
 * Generate .shipgate.yml content with smart defaults.
 */
export function generateShipGateYml(options: ShipGateYmlOptions): string {
  const { criticalDirs, testPattern, language } = options;

  const requireIslLines = criticalDirs
    .map((dir) => `    - ${dir}/**`)
    .join('\n');

  const ignorePatterns: string[] = [];

  // Test patterns
  if (language === 'typescript' || language === 'javascript') {
    ignorePatterns.push('    - "**/*.test.ts"');
    ignorePatterns.push('    - "**/*.spec.ts"');
    ignorePatterns.push('    - "**/*.test.js"');
    ignorePatterns.push('    - "**/*.spec.js"');
  } else if (language === 'python') {
    ignorePatterns.push('    - "**/test_*.py"');
    ignorePatterns.push('    - "**/*_test.py"');
    ignorePatterns.push('    - "**/conftest.py"');
  } else if (language === 'go') {
    ignorePatterns.push('    - "**/*_test.go"');
  } else {
    ignorePatterns.push(`    - "**/${testPattern}"`);
  }

  // Common ignores (defaults include node_modules, dist, .next, etc.)
  ignorePatterns.push('    - src/generated/**');

  const requireSection = criticalDirs.length > 0
    ? `  require_isl:\n${requireIslLines}`
    : '  # require_isl:\n  #   - src/auth/**\n  #   - src/payments/**';

  const detectedComments = criticalDirs
    .map((dir) => {
      const name = dir.split('/').pop() ?? dir;
      return `    # Detected: ${name} handlers`;
    })
    .join('\n');

  return `# .shipgate.yml — Generated by shipgate init
# Docs: https://shipgate.dev/docs/config
version: 1

ci:
  fail_on: error
${requireSection}${detectedComments ? '\n' + detectedComments : ''}
  ignore:
${ignorePatterns.join('\n')}
  specless_mode: "on"

scanning:
  hallucinations: true
  fake_features: true
  secrets: true
  vulnerabilities: true

generate:
  output: .shipgate/specs
  min_confidence: 0.3
`;
}

// ─────────────────────────────────────────────────────────────────────────────
// ISL Spec Templates (pattern-based)
// ─────────────────────────────────────────────────────────────────────────────

const ISL_TEMPLATES: Record<string, { behaviors: number; template: string }> = {
  'auth-login': {
    behaviors: 1,
    template: `domain AuthLogin {
  version: "1.0.0"

  entity User {
    id: String
    email: String
    passwordHash: String [secret]
  }

  entity Session {
    token: String
    userId: String
    expiresAt: Timestamp
  }

  behavior Login {
    input {
      email: String
      password: String
    }

    output {
      success: Session
      errors {
        INVALID_CREDENTIALS "Invalid email or password"
        ACCOUNT_LOCKED "Account is temporarily locked"
      }
    }

    preconditions {
      input.email != ""
      input.password != ""
    }

    postconditions {
      success implies result.token != ""
      success implies result.expiresAt > now()
      INVALID_CREDENTIALS implies User.lookup(input.email) == null or not passwordMatches(input.password)
    }

    invariants {
      password_never_logged: "password must never appear in logs"
    }
  }
}
`,
  },

  'user-registration': {
    behaviors: 1,
    template: `domain UserRegistration {
  version: "1.0.0"

  entity User {
    id: String
    email: String [unique]
    username: String [unique]
    passwordHash: String [secret]
    createdAt: Timestamp

    lifecycle {
      created -> active
    }
  }

  behavior Register {
    input {
      email: String
      username: String
      password: String
    }

    output {
      success: User
      errors {
        EMAIL_TAKEN "Email already registered"
        INVALID_EMAIL "Email format is invalid"
        WEAK_PASSWORD "Password does not meet requirements"
      }
    }

    preconditions {
      input.email != ""
      input.password.length >= 8
    }

    postconditions {
      success implies result.email == input.email
      success implies result.username == input.username
      success implies result.passwordHash != input.password
    }

    invariants {
      password_never_stored_plain: "password must be hashed before storage"
    }
  }
}
`,
  },

  'jwt-token': {
    behaviors: 2,
    template: `domain JWTToken {
  version: "1.0.0"

  entity Token {
    token: String
    subject: String
    expiresAt: Timestamp
    claims: Map
  }

  behavior CreateToken {
    input {
      subject: String
      claims: Map
      expiresIn: Duration
    }

    output {
      success: Token
      errors {
        INVALID_SUBJECT "Subject must not be empty"
      }
    }

    preconditions {
      input.subject != ""
    }

    postconditions {
      success implies result.token != ""
      success implies result.subject == input.subject
      success implies result.expiresAt > now()
    }
  }

  behavior VerifyToken {
    input {
      token: String
    }

    output {
      success: Token
      errors {
        EXPIRED "Token has expired"
        INVALID "Token signature is invalid"
        MALFORMED "Token format is invalid"
      }
    }

    preconditions {
      input.token != ""
    }

    postconditions {
      success implies result.expiresAt > now()
    }
  }
}
`,
  },

  'password-hash': {
    behaviors: 2,
    template: `domain PasswordHash {
  version: "1.0.0"

  behavior HashPassword {
    input {
      password: String
    }

    output {
      success: String
      errors {
        EMPTY_PASSWORD "Password must not be empty"
      }
    }

    preconditions {
      input.password != ""
      input.password.length >= 8
    }

    postconditions {
      success implies result != input.password
      success implies result.length > 0
    }

    invariants {
      no_plaintext: "plaintext password must never be stored or logged"
    }
  }

  behavior VerifyPassword {
    input {
      password: String
      hash: String
    }

    output {
      success: Boolean
    }

    preconditions {
      input.password != ""
      input.hash != ""
    }
  }
}
`,
  },

  'payment-processing': {
    behaviors: 1,
    template: `domain PaymentProcessing {
  version: "1.0.0"

  entity Payment {
    id: String
    amount: Decimal
    currency: String
    status: String
    createdAt: Timestamp
  }

  behavior ChargePayment {
    input {
      amount: Decimal
      currency: String
      source: String
    }

    output {
      success: Payment
      errors {
        INSUFFICIENT_FUNDS "Payment source has insufficient funds"
        INVALID_AMOUNT "Amount must be positive"
        PAYMENT_DECLINED "Payment was declined by provider"
      }
    }

    preconditions {
      input.amount > 0
      input.currency != ""
      input.source != ""
    }

    postconditions {
      success implies result.amount == input.amount
      success implies result.currency == input.currency
      success implies result.status == "succeeded"
    }

    temporal {
      completes_within 30s
    }

    invariants {
      idempotent: "duplicate charges for same source must be prevented"
    }
  }
}
`,
  },

  'rate-limiting': {
    behaviors: 1,
    template: `domain RateLimiting {
  version: "1.0.0"

  behavior CheckRateLimit {
    input {
      key: String
      limit: Int
      window: Duration
    }

    output {
      success: Boolean
      errors {
        RATE_EXCEEDED "Rate limit exceeded"
      }
    }

    preconditions {
      input.key != ""
      input.limit > 0
    }

    postconditions {
      RATE_EXCEEDED implies result == false
    }

    temporal {
      completes_within 50ms
    }

    security {
      rate_limit 100 per minute
    }
  }
}
`,
  },

  'session-management': {
    behaviors: 2,
    template: `domain SessionManagement {
  version: "1.0.0"

  entity Session {
    id: String
    userId: String
    expiresAt: Timestamp
    createdAt: Timestamp
  }

  behavior CreateSession {
    input {
      userId: String
    }

    output {
      success: Session
      errors {
        INVALID_USER "User does not exist"
      }
    }

    preconditions {
      input.userId != ""
    }

    postconditions {
      success implies result.userId == input.userId
      success implies result.expiresAt > now()
    }
  }

  behavior InvalidateSession {
    input {
      sessionId: String
    }

    output {
      success: Boolean
      errors {
        NOT_FOUND "Session not found"
      }
    }

    preconditions {
      input.sessionId != ""
    }
  }
}
`,
  },

  'subscription-management': {
    behaviors: 1,
    template: `domain SubscriptionManagement {
  version: "1.0.0"

  entity Subscription {
    id: String
    userId: String
    planId: String
    status: String
    currentPeriodEnd: Timestamp
  }

  behavior CreateSubscription {
    input {
      userId: String
      planId: String
      paymentSource: String
    }

    output {
      success: Subscription
      errors {
        INVALID_PLAN "Plan does not exist"
        PAYMENT_FAILED "Initial payment failed"
      }
    }

    preconditions {
      input.userId != ""
      input.planId != ""
    }

    postconditions {
      success implies result.userId == input.userId
      success implies result.planId == input.planId
      success implies result.status == "active"
    }
  }
}
`,
  },

  'refund-processing': {
    behaviors: 1,
    template: `domain RefundProcessing {
  version: "1.0.0"

  entity Refund {
    id: String
    paymentId: String
    amount: Decimal
    status: String
    createdAt: Timestamp
  }

  behavior ProcessRefund {
    input {
      paymentId: String
      amount: Decimal
      reason: String
    }

    output {
      success: Refund
      errors {
        PAYMENT_NOT_FOUND "Original payment not found"
        ALREADY_REFUNDED "Payment has already been refunded"
        AMOUNT_EXCEEDS "Refund amount exceeds original payment"
      }
    }

    preconditions {
      input.paymentId != ""
      input.amount > 0
    }

    postconditions {
      success implies result.paymentId == input.paymentId
      success implies result.amount == input.amount
      success implies result.status == "succeeded"
    }
  }
}
`,
  },
};

// ─────────────────────────────────────────────────────────────────────────────
// ISL Generation
// ─────────────────────────────────────────────────────────────────────────────

export interface GeneratedISLSpec {
  /** Relative file path for the generated .isl file */
  filePath: string;
  /** ISL content */
  content: string;
  /** Number of behaviors in the spec */
  behaviors: number;
  /** Confidence score */
  confidence: number;
  /** Pattern name */
  pattern: string;
}

/**
 * Generate ISL spec files for detected patterns.
 * Groups patterns by directory and generates one spec per unique pattern.
 */
export function generateISLSpecs(patterns: DetectedPattern[]): GeneratedISLSpec[] {
  const specs: GeneratedISLSpec[] = [];
  const seenPatterns = new Set<string>();

  for (const p of patterns) {
    if (seenPatterns.has(p.pattern)) continue;
    seenPatterns.add(p.pattern);

    const template = ISL_TEMPLATES[p.pattern];
    if (!template) continue;

    // Derive ISL file path from source file
    const parts = p.file.split('/');
    const dir = parts.slice(0, -1).join('/');
    const baseName = p.pattern.replace(/-/g, '-');
    const islPath = dir ? `${dir}/${baseName}.isl` : `${baseName}.isl`;

    specs.push({
      filePath: islPath,
      content: template.template,
      behaviors: template.behaviors,
      confidence: p.confidence,
      pattern: p.pattern,
    });
  }

  return specs;
}

/**
 * Get available ISL template pattern names.
 */
export function getAvailablePatterns(): string[] {
  return Object.keys(ISL_TEMPLATES);
}
