// ============================================================================
// UI Generator — Orchestrator
// Takes an ISL DomainDeclaration, produces GeneratedUIFile[]
// ============================================================================

import type * as AST from '@isl-lang/isl-core';
import type { GenerateUIOptions, GeneratedUIFile } from './types.js';
import { mapDomain } from './mapper.js';
import {
  emitTypes,
  emitValidationFn,
  emitEntityForm,
  emitBehaviorForm,
  emitListView,
  emitDetailView,
  emitApp,
} from './emitters/index.js';

/**
 * Generate React UI files from an ISL DomainDeclaration.
 */
export function generateUI(options: GenerateUIOptions): GeneratedUIFile[] {
  const model = mapDomain(options.domain);
  const files: GeneratedUIFile[] = [];

  // 1. Shared TS types
  files.push({
    path: 'types.ts',
    content: emitTypes(model),
  });

  // 2. Validation functions (one per entity + one per behavior)
  const validationParts: string[] = [];
  validationParts.push('// Auto-generated by @isl-lang/ui-generator — DO NOT EDIT');
  validationParts.push('');

  for (const entity of model.entities) {
    const editableFields = entity.fields.filter((f) => !f.immutable && !f.hidden);
    if (editableFields.length > 0) {
      validationParts.push(emitValidationFn(`validate${entity.name}`, editableFields));
      validationParts.push('');
    }
  }

  for (const behavior of model.behaviors) {
    if (behavior.inputFields.length > 0) {
      validationParts.push(
        emitValidationFn(`validate${behavior.name}`, behavior.inputFields, behavior.validation),
      );
      validationParts.push('');
    }
  }

  files.push({
    path: 'validation.ts',
    content: validationParts.join('\n'),
  });

  // 3. Per-entity: List, Detail, Form
  for (const entity of model.entities) {
    files.push({ path: `${entity.name}List.tsx`, content: emitListView(entity) });
    files.push({ path: `${entity.name}Detail.tsx`, content: emitDetailView(entity) });

    const editableFields = entity.fields.filter((f) => !f.immutable && !f.hidden);
    if (editableFields.length > 0) {
      files.push({ path: `${entity.name}Form.tsx`, content: emitEntityForm(entity) });
    }
  }

  // 4. Per-behavior: Form
  for (const behavior of model.behaviors) {
    if (behavior.inputFields.length > 0) {
      files.push({
        path: `${behavior.name}Form.tsx`,
        content: emitBehaviorForm(behavior),
      });
    }
  }

  // 5. App shell (with optional routing)
  files.push({
    path: 'App.tsx',
    content: emitApp(model, options.includeRouting ?? false),
  });

  return files;
}
