/**
 * Job Summary Generator
 * 
 * Generates GitHub Actions job summary with verification results.
 */

import * as core from '@actions/core';

import type { ActionInputs } from './inputs.js';
import type { ActionReport, Diagnostic } from './reporter.js';
import { formatDuration } from './reporter.js';
import { getVerdictEmoji, getVerdictDescription } from './verifier.js';

// ============================================================================
// Summary Generator
// ============================================================================

/**
 * Generate GitHub Actions job summary
 */
export async function generateJobSummary(
  report: ActionReport,
  inputs: ActionInputs
): Promise<void> {
  const summary = core.summary;

  // Header
  summary.addHeading('ISL Verification Results', 1);

  // Verdict badge
  const verdictBadge = getVerdictBadge(report.verdict, report.score);
  summary.addRaw(verdictBadge + '\n\n');

  // Main metrics table
  summary.addHeading('Summary', 2);
  summary.addTable([
    [
      { data: 'Metric', header: true },
      { data: 'Value', header: true },
    ],
    ['Verdict', `${getVerdictEmoji(report.verdict)} ${report.verdict.toUpperCase()}`],
    ['Score', `${report.score}/100`],
    ['Errors', report.errors.length.toString()],
    ['Warnings', report.warnings.length.toString()],
    ['Specs Checked', report.specsChecked.toString()],
    ['Duration', formatDuration(report.duration)],
  ]);

  // Coverage section
  if (report.coverage.preconditions > 0 || report.coverage.postconditions > 0) {
    summary.addHeading('Coverage', 2);
    summary.addTable([
      [
        { data: 'Type', header: true },
        { data: 'Coverage', header: true },
        { data: 'Progress', header: true },
      ],
      ['Preconditions', `${report.coverage.preconditions}%`, getProgressBar(report.coverage.preconditions)],
      ['Postconditions', `${report.coverage.postconditions}%`, getProgressBar(report.coverage.postconditions)],
      ['Invariants', `${report.coverage.invariants}%`, getProgressBar(report.coverage.invariants)],
      ['Temporal', `${report.coverage.temporal}%`, getProgressBar(report.coverage.temporal)],
    ]);
  }

  // Errors section
  if (report.errors.length > 0) {
    summary.addHeading('Errors', 2);
    summary.addRaw(formatDiagnosticsTable(report.errors.slice(0, 10)));
    
    if (report.errors.length > 10) {
      summary.addRaw(`\n<details><summary>Show ${report.errors.length - 10} more errors</summary>\n\n`);
      summary.addRaw(formatDiagnosticsTable(report.errors.slice(10)));
      summary.addRaw('\n</details>\n');
    }
  }

  // Warnings section
  if (report.warnings.length > 0) {
    summary.addHeading('Warnings', 2);
    summary.addRaw(formatDiagnosticsTable(report.warnings.slice(0, 5)));
    
    if (report.warnings.length > 5) {
      summary.addRaw(`\n<details><summary>Show ${report.warnings.length - 5} more warnings</summary>\n\n`);
      summary.addRaw(formatDiagnosticsTable(report.warnings.slice(5)));
      summary.addRaw('\n</details>\n');
    }
  }

  // Configuration section
  summary.addHeading('Configuration', 2);
  summary.addTable([
    [
      { data: 'Setting', header: true },
      { data: 'Value', header: true },
    ],
    ['Specs Pattern', `\`${inputs.specs}\``],
    ['Implementation', inputs.implementation ? `\`${inputs.implementation}\`` : '_Not provided_'],
    ['Check Only', inputs.checkOnly ? 'Yes' : 'No'],
    ['Fail on Warning', inputs.failOnWarning ? 'Yes' : 'No'],
    ['Fail Threshold', inputs.failThreshold > 0 ? `${inputs.failThreshold}` : '_Not set_'],
  ]);

  // Footer
  summary.addSeparator();
  summary.addRaw(`\n_Generated by ISL Verify Action at ${new Date().toISOString()}_\n`);

  // Write the summary
  await summary.write();
}

/**
 * Get a verdict badge for the summary
 */
function getVerdictBadge(verdict: string, score: number): string {
  const color = getVerdictColor(verdict);
  const encodedVerdict = encodeURIComponent(verdict.toUpperCase());
  const encodedScore = encodeURIComponent(`${score}%`);
  
  return `![Verdict](https://img.shields.io/badge/ISL-${encodedVerdict}-${color}?style=for-the-badge) ![Score](https://img.shields.io/badge/Score-${encodedScore}-${color}?style=for-the-badge)`;
}

/**
 * Get color for verdict badge
 */
function getVerdictColor(verdict: string): string {
  switch (verdict.toLowerCase()) {
    case 'verified':
      return 'brightgreen';
    case 'checked':
      return 'green';
    case 'risky':
      return 'yellow';
    case 'unsafe':
    case 'failed':
      return 'red';
    default:
      return 'lightgrey';
  }
}

/**
 * Get a progress bar for coverage
 */
function getProgressBar(percentage: number): string {
  const filled = Math.round(percentage / 10);
  const empty = 10 - filled;
  
  let bar = '';
  for (let i = 0; i < filled; i++) {
    bar += 'ðŸŸ©';
  }
  for (let i = 0; i < empty; i++) {
    bar += 'â¬œ';
  }
  
  return bar;
}

/**
 * Format diagnostics as a markdown table
 */
function formatDiagnosticsTable(diagnostics: Diagnostic[]): string {
  if (diagnostics.length === 0) {
    return '_No issues found_\n';
  }

  const rows = diagnostics.map(diag => {
    const icon = diag.severity === 'error' ? 'âŒ' : diag.severity === 'warning' ? 'âš ï¸' : 'â„¹ï¸';
    const location = `\`${diag.file}:${diag.line}:${diag.column}\``;
    const code = `\`${diag.code}\``;
    const message = escapeMarkdown(diag.message);
    
    return `| ${icon} | ${code} | ${location} | ${message} |`;
  });

  return `| | Code | Location | Message |
|---|------|----------|---------|
${rows.join('\n')}
`;
}

/**
 * Escape markdown special characters
 */
function escapeMarkdown(text: string): string {
  return text
    .replace(/\|/g, '\\|')
    .replace(/\n/g, ' ')
    .substring(0, 100) + (text.length > 100 ? '...' : '');
}

/**
 * Generate a simple text summary (for logs)
 */
export function generateTextSummary(report: ActionReport): string {
  const lines: string[] = [
    'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•',
    '                    ISL Verification Summary                ',
    'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•',
    '',
    `  Verdict:         ${getVerdictEmoji(report.verdict)} ${report.verdict.toUpperCase()}`,
    `  Score:           ${report.score}/100`,
    `  Specs Checked:   ${report.specsChecked}`,
    `  Errors:          ${report.errors.length}`,
    `  Warnings:        ${report.warnings.length}`,
    `  Duration:        ${formatDuration(report.duration)}`,
    '',
  ];

  if (report.coverage.preconditions > 0) {
    lines.push('  Coverage:');
    lines.push(`    Preconditions:  ${report.coverage.preconditions}%`);
    lines.push(`    Postconditions: ${report.coverage.postconditions}%`);
    lines.push(`    Invariants:     ${report.coverage.invariants}%`);
    lines.push(`    Temporal:       ${report.coverage.temporal}%`);
    lines.push('');
  }

  lines.push('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

  return lines.join('\n');
}

/**
 * Create summary for pull request comment
 */
export function generatePRComment(report: ActionReport): string {
  const emoji = getVerdictEmoji(report.verdict);
  const verdict = report.verdict.toUpperCase();

  let comment = `## ${emoji} ISL Verification: ${verdict}\n\n`;
  
  comment += `| Metric | Value |\n|--------|-------|\n`;
  comment += `| Score | ${report.score}/100 |\n`;
  comment += `| Errors | ${report.errors.length} |\n`;
  comment += `| Warnings | ${report.warnings.length} |\n`;
  comment += `| Files Checked | ${report.specsChecked} |\n\n`;

  if (report.errors.length > 0) {
    comment += `### Errors\n\n`;
    for (const error of report.errors.slice(0, 5)) {
      comment += `- **${error.code}** in \`${error.file}:${error.line}\`: ${error.message}\n`;
    }
    if (report.errors.length > 5) {
      comment += `\n_...and ${report.errors.length - 5} more errors_\n`;
    }
    comment += '\n';
  }

  if (report.warnings.length > 0 && report.errors.length === 0) {
    comment += `### Warnings\n\n`;
    for (const warning of report.warnings.slice(0, 3)) {
      comment += `- **${warning.code}** in \`${warning.file}:${warning.line}\`: ${warning.message}\n`;
    }
    if (report.warnings.length > 3) {
      comment += `\n_...and ${report.warnings.length - 3} more warnings_\n`;
    }
  }

  return comment;
}
