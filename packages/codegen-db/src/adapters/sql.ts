/**
 * Raw SQL Schema Generator
 */

import type {
  DatabaseAdapterGenerator,
  GeneratorContext,
  GeneratedFile,
  NormalizedEntity,
  NormalizedEnum,
  NormalizedField,
  DefaultValue,
} from '../types.js';

export class SQLGenerator implements DatabaseAdapterGenerator {
  generateSchema(context: GeneratorContext): GeneratedFile[] {
    const { entities, enums, options } = context;
    const provider = options.provider || 'postgresql';

    const lines: string[] = [];

    // Header comment
    lines.push('-- Generated by @intentos/codegen-db');
    lines.push(`-- Provider: ${provider}`);
    lines.push(`-- Generated at: ${new Date().toISOString()}`);
    lines.push('');

    // Drop existing tables (in reverse order for foreign keys)
    lines.push('-- Drop existing tables');
    for (const entity of [...entities].reverse()) {
      lines.push(`DROP TABLE IF EXISTS "${entity.tableName}" CASCADE;`);
    }
    lines.push('');

    // Drop existing types (for PostgreSQL)
    if (provider === 'postgresql' && enums.length > 0) {
      lines.push('-- Drop existing types');
      for (const enumDef of enums) {
        lines.push(`DROP TYPE IF EXISTS "${enumDef.dbName}" CASCADE;`);
      }
      lines.push('');
    }

    // Generate enums (PostgreSQL only)
    if (provider === 'postgresql' && enums.length > 0) {
      lines.push('-- Create enum types');
      for (const enumDef of enums) {
        lines.push(...this.generateEnum(enumDef, provider));
      }
      lines.push('');
    }

    // Generate tables
    lines.push('-- Create tables');
    for (const entity of entities) {
      lines.push(...this.generateTable(entity, context));
      lines.push('');
    }

    // Generate indexes
    lines.push('-- Create indexes');
    for (const entity of entities) {
      lines.push(...this.generateIndexes(entity, context));
    }

    return [{
      path: `schema.${this.getProviderExtension(provider)}`,
      content: lines.join('\n'),
      type: 'sql',
    }];
  }

  getFileExtension(): string {
    return 'sql';
  }

  private getProviderExtension(provider: string): string {
    switch (provider) {
      case 'postgresql':
        return 'pgsql';
      case 'mysql':
        return 'mysql';
      case 'sqlite':
        return 'sqlite';
      default:
        return 'sql';
    }
  }

  private generateEnum(enumDef: NormalizedEnum, provider: string): string[] {
    const lines: string[] = [];

    if (provider === 'postgresql') {
      const values = enumDef.values.map(v => `'${v}'`).join(', ');
      lines.push(`CREATE TYPE "${enumDef.dbName}" AS ENUM (${values});`);
    }

    return lines;
  }

  private generateTable(entity: NormalizedEntity, context: GeneratorContext): string[] {
    const lines: string[] = [];
    const provider = context.options.provider || 'postgresql';

    lines.push(`CREATE TABLE "${entity.tableName}" (`);

    const columnDefs: string[] = [];

    // Generate columns
    for (const field of entity.fields) {
      columnDefs.push(`  ${this.generateColumn(field, context)}`);
    }

    // Add soft delete column if enabled
    if (context.options.softDelete) {
      columnDefs.push(`  "deleted_at" ${this.getTimestampType(provider)} NULL`);
    }

    // Add audit columns if enabled
    if (context.options.auditFields) {
      columnDefs.push(`  "created_by" VARCHAR(255) NULL`);
      columnDefs.push(`  "updated_by" VARCHAR(255) NULL`);
    }

    // Add primary key constraint
    const pkFields = entity.fields.filter(f => f.primaryKey);
    if (pkFields.length > 0) {
      const pkColumns = pkFields.map(f => `"${f.columnName}"`).join(', ');
      columnDefs.push(`  PRIMARY KEY (${pkColumns})`);
    }

    // Add unique constraints
    for (const unique of entity.uniqueConstraints) {
      const columns = unique.fields.map(f => `"${f}"`).join(', ');
      const constraintName = unique.name || `${entity.tableName}_${unique.fields.join('_')}_key`;
      columnDefs.push(`  CONSTRAINT "${constraintName}" UNIQUE (${columns})`);
    }

    lines.push(columnDefs.join(',\n'));
    lines.push(');');

    return lines;
  }

  private generateColumn(field: NormalizedField, context: GeneratorContext): string {
    const provider = context.options.provider || 'postgresql';
    const parts: string[] = [];

    // Column name
    parts.push(`"${field.columnName}"`);

    // Data type
    parts.push(this.mapToSqlType(field, provider));

    // NOT NULL
    if (!field.nullable && !field.primaryKey) {
      parts.push('NOT NULL');
    }

    // Default value
    if (field.defaultValue && !field.primaryKey) {
      const defaultSql = this.formatDefaultValue(field.defaultValue, field, provider);
      if (defaultSql) {
        parts.push(`DEFAULT ${defaultSql}`);
      }
    }

    // Auto-generate for primary keys
    if (field.primaryKey && field.autoGenerate) {
      if (field.type.scalarType === 'UUID' && provider === 'postgresql') {
        parts.push('DEFAULT gen_random_uuid()');
      } else if (field.type.scalarType === 'Int') {
        // Handled by SERIAL/AUTO_INCREMENT type
      }
    }

    // UNIQUE (inline for single column)
    if (field.unique && !field.primaryKey) {
      parts.push('UNIQUE');
    }

    return parts.join(' ');
  }

  private mapToSqlType(field: NormalizedField, provider: string): string {
    // Handle enums
    if (field.type.kind === 'enum') {
      if (provider === 'postgresql') {
        return `"${field.type.enumName?.toLowerCase() || field.type.name.toLowerCase()}"`;
      } else if (provider === 'mysql') {
        // MySQL uses inline ENUM
        return `VARCHAR(50)`; // Simplified - could generate actual ENUM
      } else {
        return 'TEXT';
      }
    }

    const scalarType = field.type.scalarType || 'String';

    // Handle auto-increment integers
    if (field.primaryKey && field.autoGenerate && scalarType === 'Int') {
      switch (provider) {
        case 'postgresql':
          return 'SERIAL';
        case 'mysql':
          return 'INT AUTO_INCREMENT';
        case 'sqlite':
          return 'INTEGER';
        default:
          return 'SERIAL';
      }
    }

    // Type mappings by provider
    const mappings: Record<string, Record<string, string>> = {
      postgresql: {
        String: this.getVarcharType(field, 'postgresql'),
        Int: 'INTEGER',
        Float: 'REAL',
        Boolean: 'BOOLEAN',
        DateTime: 'TIMESTAMP',
        UUID: 'UUID',
        BigInt: 'BIGINT',
        Decimal: this.getDecimalType(field),
        Json: 'JSONB',
        Bytes: 'BYTEA',
      },
      mysql: {
        String: this.getVarcharType(field, 'mysql'),
        Int: 'INT',
        Float: 'FLOAT',
        Boolean: 'TINYINT(1)',
        DateTime: 'DATETIME',
        UUID: 'VARCHAR(36)',
        BigInt: 'BIGINT',
        Decimal: this.getDecimalType(field),
        Json: 'JSON',
        Bytes: 'BLOB',
      },
      sqlite: {
        String: 'TEXT',
        Int: 'INTEGER',
        Float: 'REAL',
        Boolean: 'INTEGER',
        DateTime: 'TEXT',
        UUID: 'TEXT',
        BigInt: 'INTEGER',
        Decimal: 'REAL',
        Json: 'TEXT',
        Bytes: 'BLOB',
      },
    };

    return mappings[provider]?.[scalarType] || 'TEXT';
  }

  private getVarcharType(field: NormalizedField, provider: string): string {
    const length = field.constraints.maxLength || 255;
    
    if (provider === 'sqlite') {
      return 'TEXT';
    }

    return `VARCHAR(${length})`;
  }

  private getDecimalType(field: NormalizedField): string {
    const precision = field.constraints.precision || 10;
    const scale = field.constraints.scale || 2;
    return `DECIMAL(${precision}, ${scale})`;
  }

  private getTimestampType(provider: string): string {
    switch (provider) {
      case 'postgresql':
        return 'TIMESTAMP';
      case 'mysql':
        return 'DATETIME';
      case 'sqlite':
        return 'TEXT';
      default:
        return 'TIMESTAMP';
    }
  }

  private formatDefaultValue(
    defaultValue: DefaultValue,
    field: NormalizedField,
    provider: string
  ): string | null {
    switch (defaultValue.kind) {
      case 'literal':
        if (typeof defaultValue.value === 'string') {
          return `'${defaultValue.value}'`;
        } else if (typeof defaultValue.value === 'boolean') {
          if (provider === 'postgresql') {
            return defaultValue.value ? 'TRUE' : 'FALSE';
          } else {
            return defaultValue.value ? '1' : '0';
          }
        } else if (defaultValue.value === null) {
          return 'NULL';
        }
        return String(defaultValue.value);

      case 'function':
        switch (defaultValue.function) {
          case 'now':
            switch (provider) {
              case 'postgresql':
                return 'CURRENT_TIMESTAMP';
              case 'mysql':
                return 'CURRENT_TIMESTAMP';
              case 'sqlite':
                return "datetime('now')";
              default:
                return 'CURRENT_TIMESTAMP';
            }
          case 'uuid':
            if (provider === 'postgresql') {
              return 'gen_random_uuid()';
            }
            return null;
          default:
            return null;
        }

      default:
        return null;
    }
  }

  private generateIndexes(entity: NormalizedEntity, context: GeneratorContext): string[] {
    const lines: string[] = [];

    for (const index of entity.indexes) {
      if (index.unique) {
        continue; // Handled in table definition
      }

      const indexName = index.name || `idx_${entity.tableName}_${index.fields.join('_')}`;
      const columns = index.fields.map(f => `"${f}"`).join(', ');

      lines.push(`CREATE INDEX "${indexName}" ON "${entity.tableName}" (${columns});`);
    }

    return lines;
  }
}
