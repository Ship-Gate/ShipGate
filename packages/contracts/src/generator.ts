/**
 * ISL Smart Contract Generator
 * 
 * Generates Solidity code from ISL contract specifications
 */

import type {
  Contract,
  StateVariable,
  ContractFunction,
  ContractEvent,
  Modifier,
  ERC20Config,
  ERC721Config,
  ERC1155Config,
  AccessControl,
  StakingConfig,
  GovernorConfig,
} from './types';

/**
 * Generate Solidity code from contract definition
 */
export function generateSolidity(contract: Contract): string {
  const lines: string[] = [];

  // SPDX license
  lines.push(`// SPDX-License-Identifier: ${contract.license ?? 'MIT'}`);
  lines.push(`pragma solidity ^0.8.20;`);
  lines.push('');

  // Imports
  if (contract.dependencies) {
    for (const dep of contract.dependencies) {
      lines.push(`import "${dep}";`);
    }
    lines.push('');
  }

  // Contract documentation
  if (contract.description) {
    lines.push('/**');
    lines.push(` * @title ${contract.name}`);
    lines.push(` * @notice ${contract.description}`);
    lines.push(` * @dev Generated by ISL Contracts v${contract.version}`);
    lines.push(' */');
  }

  // Contract declaration
  lines.push(`contract ${contract.name} {`);

  // State variables
  if (contract.state.length > 0) {
    lines.push('    // State Variables');
    for (const state of contract.state) {
      lines.push(generateStateVariable(state));
    }
    lines.push('');
  }

  // Events
  if (contract.events.length > 0) {
    lines.push('    // Events');
    for (const event of contract.events) {
      lines.push(generateEvent(event));
    }
    lines.push('');
  }

  // Modifiers
  if (contract.modifiers.length > 0) {
    lines.push('    // Modifiers');
    for (const modifier of contract.modifiers) {
      lines.push(generateModifier(modifier));
    }
    lines.push('');
  }

  // Functions
  if (contract.functions.length > 0) {
    lines.push('    // Functions');
    for (const fn of contract.functions) {
      lines.push(generateFunction(fn));
      lines.push('');
    }
  }

  // Invariant checks (as internal functions)
  if (contract.invariants.length > 0) {
    lines.push('    // Invariant Checks');
    lines.push('    function _checkInvariants() internal view {');
    for (const inv of contract.invariants) {
      lines.push(`        require(${inv.expression}, "${inv.name} violated");`);
    }
    lines.push('    }');
  }

  lines.push('}');

  return lines.join('\n');
}

/**
 * Generate state variable declaration
 */
function generateStateVariable(state: StateVariable): string {
  const parts: string[] = ['    '];

  if (state.constant) parts.push('constant ');
  if (state.immutable) parts.push('immutable ');

  parts.push(`${state.type} ${state.visibility} ${state.name}`);

  if (state.initialValue) {
    parts.push(` = ${state.initialValue}`);
  }

  parts.push(';');

  if (state.description) {
    return `    /// @notice ${state.description}\n${parts.join('')}`;
  }

  return parts.join('');
}

/**
 * Generate event declaration
 */
function generateEvent(event: ContractEvent): string {
  const params = event.params.map(p => {
    const indexed = p.indexed ? ' indexed' : '';
    return `${p.type}${indexed} ${p.name}`;
  }).join(', ');

  return `    event ${event.name}(${params});`;
}

/**
 * Generate modifier declaration
 */
function generateModifier(modifier: Modifier): string {
  const params = modifier.params
    ? `(${modifier.params.map(p => `${p.type} ${p.name}`).join(', ')})`
    : '';

  return `    modifier ${modifier.name}${params} {
        ${modifier.body}
    }`;
}

/**
 * Generate function declaration
 */
function generateFunction(fn: ContractFunction): string {
  const lines: string[] = [];

  // Documentation
  if (fn.description) {
    lines.push(`    /// @notice ${fn.description}`);
    for (const param of fn.params) {
      if (param.description) {
        lines.push(`    /// @param ${param.name} ${param.description}`);
      }
    }
  }

  // Function signature
  const params = fn.params.map(p => `${p.type} ${p.name}`).join(', ');
  const returns = fn.returns.length > 0
    ? ` returns (${fn.returns.map(r => `${r.type} ${r.name}`).join(', ')})`
    : '';
  const modifiers = fn.modifiers ? ` ${fn.modifiers.join(' ')}` : '';

  lines.push(`    function ${fn.name}(${params}) ${fn.visibility} ${fn.mutability}${modifiers}${returns} {`);

  // Preconditions
  if (fn.preconditions) {
    for (const pre of fn.preconditions) {
      lines.push(`        require(${pre}, "${fn.name}: precondition failed");`);
    }
  }

  // Body
  if (fn.body) {
    lines.push(`        ${fn.body}`);
  }

  // Postconditions (using assert for invariants)
  if (fn.postconditions) {
    for (const post of fn.postconditions) {
      lines.push(`        assert(${post}); // postcondition`);
    }
  }

  lines.push('    }');

  return lines.join('\n');
}

/**
 * Generate ERC20 token contract
 */
export function generateERC20(config: ERC20Config): string {
  const imports = ['@openzeppelin/contracts/token/ERC20/ERC20.sol'];

  if (config.mintable) imports.push('@openzeppelin/contracts/access/Ownable.sol');
  if (config.burnable) imports.push('@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol');
  if (config.pausable) imports.push('@openzeppelin/contracts/security/Pausable.sol');
  if (config.capped) imports.push('@openzeppelin/contracts/token/ERC20/extensions/ERC20Capped.sol');
  if (config.permit) imports.push('@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol');
  if (config.snapshots) imports.push('@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol');

  const inheritance = ['ERC20'];
  if (config.mintable) inheritance.push('Ownable');
  if (config.burnable) inheritance.push('ERC20Burnable');
  if (config.pausable) inheritance.push('Pausable');
  if (config.capped) inheritance.push('ERC20Capped');
  if (config.permit) inheritance.push('ERC20Permit');

  return `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

${imports.map(i => `import "${i}";`).join('\n')}

contract ${config.name.replace(/\s/g, '')}Token is ${inheritance.join(', ')} {
    constructor() ERC20("${config.name}", "${config.symbol}") {
        ${config.initialSupply ? `_mint(msg.sender, ${config.initialSupply} * 10 ** decimals());` : ''}
    }

    function decimals() public pure override returns (uint8) {
        return ${config.decimals};
    }
${config.mintable ? `
    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
` : ''}
${config.pausable ? `
    function pause() public onlyOwner {
        _pause();
    }

    function unpause() public onlyOwner {
        _unpause();
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override whenNotPaused {
        super._beforeTokenTransfer(from, to, amount);
    }
` : ''}
}`;
}

/**
 * Generate ERC721 NFT contract
 */
export function generateERC721(config: ERC721Config): string {
  return `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
${config.enumerable ? 'import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";' : ''}
${config.burnable ? 'import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";' : ''}
${config.pausable ? 'import "@openzeppelin/contracts/security/Pausable.sol";' : ''}
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract ${config.name.replace(/\s/g, '')}NFT is ERC721${config.enumerable ? ', ERC721Enumerable' : ''}${config.burnable ? ', ERC721Burnable' : ''}${config.pausable ? ', Pausable' : ''}, Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIdCounter;

    ${config.maxSupply ? `uint256 public constant MAX_SUPPLY = ${config.maxSupply};` : ''}
    ${config.baseURI ? `string private _baseTokenURI = "${config.baseURI}";` : ''}

    constructor() ERC721("${config.name}", "${config.symbol}") {}

    function safeMint(address to) public onlyOwner {
        ${config.maxSupply ? `require(_tokenIdCounter.current() < MAX_SUPPLY, "Max supply reached");` : ''}
        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();
        _safeMint(to, tokenId);
    }

    function _baseURI() internal view override returns (string memory) {
        return _baseTokenURI;
    }

    function setBaseURI(string memory newBaseURI) public onlyOwner {
        _baseTokenURI = newBaseURI;
    }
${config.royalties ? `
    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address receiver, uint256 royaltyAmount) {
        return (${config.royalties.recipient}, (salePrice * ${config.royalties.percentage}) / 10000);
    }
` : ''}
}`;
}

/**
 * Generate staking contract
 */
export function generateStaking(config: StakingConfig): string {
  return `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract StakingRewards is ReentrancyGuard, Ownable {
    using SafeERC20 for IERC20;

    IERC20 public immutable stakingToken;
    IERC20 public immutable rewardToken;
    
    uint256 public rewardRate = ${config.rewardRate};
    ${config.lockPeriod ? `uint256 public lockPeriod = ${config.lockPeriod};` : ''}
    ${config.maxStake ? `uint256 public maxStake = ${config.maxStake};` : ''}
    
    uint256 public lastUpdateTime;
    uint256 public rewardPerTokenStored;
    
    mapping(address => uint256) public userRewardPerTokenPaid;
    mapping(address => uint256) public rewards;
    mapping(address => uint256) public balances;
    mapping(address => uint256) public stakeTimes;
    
    uint256 public totalStaked;
    
    event Staked(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 reward);
    
    constructor(address _stakingToken, address _rewardToken) {
        stakingToken = IERC20(_stakingToken);
        rewardToken = IERC20(_rewardToken);
    }
    
    modifier updateReward(address account) {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = block.timestamp;
        if (account != address(0)) {
            rewards[account] = earned(account);
            userRewardPerTokenPaid[account] = rewardPerTokenStored;
        }
        _;
    }
    
    function rewardPerToken() public view returns (uint256) {
        if (totalStaked == 0) return rewardPerTokenStored;
        return rewardPerTokenStored + (
            (block.timestamp - lastUpdateTime) * rewardRate * 1e18 / totalStaked
        );
    }
    
    function earned(address account) public view returns (uint256) {
        return (balances[account] * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18) + rewards[account];
    }
    
    function stake(uint256 amount) external nonReentrant updateReward(msg.sender) {
        require(amount > 0, "Cannot stake 0");
        ${config.maxStake ? `require(balances[msg.sender] + amount <= maxStake, "Exceeds max stake");` : ''}
        
        totalStaked += amount;
        balances[msg.sender] += amount;
        stakeTimes[msg.sender] = block.timestamp;
        
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
        emit Staked(msg.sender, amount);
    }
    
    function withdraw(uint256 amount) external nonReentrant updateReward(msg.sender) {
        require(amount > 0, "Cannot withdraw 0");
        require(balances[msg.sender] >= amount, "Insufficient balance");
        ${config.lockPeriod ? `require(block.timestamp >= stakeTimes[msg.sender] + lockPeriod, "Still locked");` : ''}
        
        totalStaked -= amount;
        balances[msg.sender] -= amount;
        
        stakingToken.safeTransfer(msg.sender, amount);
        emit Withdrawn(msg.sender, amount);
    }
    
    function claimReward() external nonReentrant updateReward(msg.sender) {
        uint256 reward = rewards[msg.sender];
        if (reward > 0) {
            rewards[msg.sender] = 0;
            rewardToken.safeTransfer(msg.sender, reward);
            emit RewardPaid(msg.sender, reward);
        }
    }
}`;
}
