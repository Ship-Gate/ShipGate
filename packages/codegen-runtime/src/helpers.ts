/**
 * Runtime Helper Generation
 * 
 * Generates helper classes and functions for runtime verification.
 */

/**
 * Generate runtime helper code
 */
export function generateRuntimeHelpers(): string {
  return `/**
 * Runtime Verification Helpers
 * Auto-generated by @isl-lang/codegen-runtime
 */

// ============================================================================
// Error Classes
// ============================================================================

export class PreconditionError extends Error {
  type = 'precondition' as const;
  behavior: string;
  condition: string;
  context?: Record<string, unknown>;

  constructor(behavior: string, condition: string, context?: Record<string, unknown>) {
    super(\`Precondition failed in \${behavior}: \${condition}\`);
    this.name = 'PreconditionError';
    this.behavior = behavior;
    this.condition = condition;
    this.context = context;
  }
}

export class PostconditionError extends Error {
  type = 'postcondition' as const;
  behavior: string;
  condition: string;
  context?: Record<string, unknown>;

  constructor(behavior: string, condition: string, context?: Record<string, unknown>) {
    super(\`Postcondition failed in \${behavior}: \${condition}\`);
    this.name = 'PostconditionError';
    this.behavior = behavior;
    this.condition = condition;
    this.context = context;
  }
}

export class InvariantError extends Error {
  type = 'invariant' as const;
  behavior: string;
  condition: string;
  context?: Record<string, unknown>;

  constructor(behavior: string, condition: string, context?: Record<string, unknown>) {
    super(\`Invariant violated in \${behavior}: \${condition}\`);
    this.name = 'InvariantError';
    this.behavior = behavior;
    this.condition = condition;
    this.context = context;
  }
}

export type VerificationError = PreconditionError | PostconditionError | InvariantError;

// ============================================================================
// Entity Store (for entity existence checks)
// ============================================================================

export interface EntityStore {
  has(entityType: string, id: unknown): boolean;
  get(entityType: string, id: unknown): unknown | undefined;
  count(entityType: string): number;
  set(entityType: string, id: unknown, value: unknown): void;
}

export class InMemoryEntityStore implements EntityStore {
  private data = new Map<string, Map<unknown, unknown>>();

  has(entityType: string, id: unknown): boolean {
    return this.data.get(entityType)?.has(id) ?? false;
  }

  get(entityType: string, id: unknown): unknown | undefined {
    return this.data.get(entityType)?.get(id);
  }

  count(entityType: string): number {
    return this.data.get(entityType)?.size ?? 0;
  }

  set(entityType: string, id: unknown, value: unknown): void {
    if (!this.data.has(entityType)) {
      this.data.set(entityType, new Map());
    }
    this.data.get(entityType)!.set(id, value);
  }

  clear(): void {
    this.data.clear();
  }
}

// ============================================================================
// Deep Clone for old() state capture
// ============================================================================

export function deepClone<T>(obj: T): T {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  if (Array.isArray(obj)) {
    return obj.map(deepClone) as T;
  }
  
  if (obj instanceof Date) {
    return new Date(obj.getTime()) as T;
  }
  
  if (obj instanceof Map) {
    return new Map([...obj].map(([k, v]) => [k, deepClone(v)])) as T;
  }
  
  if (obj instanceof Set) {
    return new Set([...obj].map(deepClone)) as T;
  }
  
  const cloned = {} as T;
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      cloned[key] = deepClone(obj[key]);
    }
  }
  return cloned;
}

// ============================================================================
// Verification Reporter
// ============================================================================

export interface VerificationViolation {
  type: 'precondition' | 'postcondition' | 'invariant';
  behavior: string;
  condition: string;
  passed: boolean;
}

export interface VerificationReport {
  behavior: string;
  preconditions: { total: number; passed: number };
  postconditions: { total: number; passed: number };
  invariants: { total: number; passed: number };
  violations: VerificationViolation[];
  success: boolean;
}

export function createVerificationReporter() {
  const violations: VerificationViolation[] = [];
  
  return {
    record(violation: VerificationViolation) {
      violations.push(violation);
    },
    
    report(behavior: string): VerificationReport {
      const pre = violations.filter(v => v.type === 'precondition' && v.behavior === behavior);
      const post = violations.filter(v => v.type === 'postcondition' && v.behavior === behavior);
      const inv = violations.filter(v => v.type === 'invariant' && v.behavior === behavior);
      
      return {
        behavior,
        preconditions: { total: pre.length, passed: pre.filter(v => v.passed).length },
        postconditions: { total: post.length, passed: post.filter(v => v.passed).length },
        invariants: { total: inv.length, passed: inv.filter(v => v.passed).length },
        violations: violations.filter(v => !v.passed && v.behavior === behavior),
        success: violations.filter(v => !v.passed && v.behavior === behavior).length === 0,
      };
    },
    
    clear() {
      violations.length = 0;
    },
  };
}

// ============================================================================
// Runtime Configuration
// ============================================================================

export interface RuntimeVerificationConfig {
  /** Mode: development (all checks), production (critical only), test (assertions) */
  mode: 'development' | 'production' | 'test';
  /** Whether to throw on failures */
  throwOnFailure: boolean;
  /** Custom error handler */
  onError?: (error: VerificationError) => void;
  /** Entity store for existence checks */
  entityStore?: EntityStore;
}

const defaultConfig: RuntimeVerificationConfig = {
  mode: 'development',
  throwOnFailure: true,
};

let currentConfig = { ...defaultConfig };

export function configureRuntimeVerification(config: Partial<RuntimeVerificationConfig>): void {
  currentConfig = { ...currentConfig, ...config };
}

export function getRuntimeConfig(): RuntimeVerificationConfig {
  return currentConfig;
}

export function resetRuntimeConfig(): void {
  currentConfig = { ...defaultConfig };
}
`;
}
