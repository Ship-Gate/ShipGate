/**
 * Runtime Verification Wrapper Generator
 * 
 * Generates TypeScript code that wraps implementations with runtime verification.
 */

import type { Domain, Behavior, Expression } from '@isl-lang/parser';
import type { GenerateOptions, GeneratedFile } from './types.js';
import { compileAssertions } from './expression-compiler.js';
import { generateRuntimeHelpers } from './helpers.js';

/**
 * Generate runtime verification wrappers for an ISL domain
 */
export function generate(domain: Domain, options: GenerateOptions = {}): GeneratedFile[] {
  const files: GeneratedFile[] = [];
  const domainName = domain.name.name.toLowerCase();
  const includeHelpers = options.includeHelpers ?? true;
  const includeComments = options.includeComments ?? true;
  const mode = options.mode ?? 'development';
  
  // Generate helpers file
  if (includeHelpers) {
    files.push({
      path: `${domainName}/helpers.ts`,
      content: generateRuntimeHelpers(),
      type: 'helpers',
    });
  }
  
  // Generate types file
  files.push({
    path: `${domainName}/types.ts`,
    content: generateTypes(domain, includeComments),
    type: 'types',
  });
  
  // Generate wrapper for each behavior
  for (const behavior of domain.behaviors) {
    files.push({
      path: `${domainName}/${toKebabCase(behavior.name.name)}.wrapper.ts`,
      content: generateBehavior(behavior, domain, { ...options, mode }),
      type: 'wrapper',
    });
  }
  
  // Generate index file
  files.push({
    path: `${domainName}/index.ts`,
    content: generateIndex(domain),
    type: 'index',
  });
  
  return files;
}

/**
 * Generate a runtime verification wrapper for a single behavior
 */
export function generateBehavior(
  behavior: Behavior,
  _domain: Domain,
  options: GenerateOptions = {}
): string {
  const lines: string[] = [];
  const behaviorName = behavior.name.name;
  const mode = options.mode ?? 'development';
  const throwOnFailure = options.runtime?.throwOnPreconditionFailure ?? true;
  
  // Imports
  lines.push(`/**`);
  lines.push(` * ${behaviorName} - Runtime Verified Implementation Wrapper`);
  lines.push(` * Auto-generated by @isl-lang/codegen-runtime`);
  lines.push(` */`);
  lines.push('');
  lines.push(`import {`);
  lines.push(`  PreconditionError,`);
  lines.push(`  PostconditionError,`);
  lines.push(`  InvariantError,`);
  lines.push(`  deepClone,`);
  lines.push(`  type EntityStore,`);
  lines.push(`  InMemoryEntityStore,`);
  lines.push(`} from './helpers.js';`);
  lines.push(`import type { ${behaviorName}Input, ${behaviorName}Output } from './types.js';`);
  lines.push('');
  
  // Input type from behavior
  const inputFields = behavior.input?.fields ?? [];
  const inputType = inputFields.length > 0 ? `${behaviorName}Input` : 'void';
  
  // Output type
  const outputType = behavior.output?.success ? `${behaviorName}Output` : 'void';
  
  // Implementation type
  lines.push(`/** Implementation function type for ${behaviorName} */`);
  lines.push(`export type ${behaviorName}Impl = (input: ${inputType}, context?: VerificationContext) => Promise<${outputType}>;`);
  lines.push('');
  
  // Context type
  lines.push(`/** Verification context for runtime checks */`);
  lines.push(`export interface VerificationContext {`);
  lines.push(`  entityStore?: EntityStore;`);
  lines.push(`  skipPreconditions?: boolean;`);
  lines.push(`  skipPostconditions?: boolean;`);
  lines.push(`  skipInvariants?: boolean;`);
  lines.push(`}`);
  lines.push('');
  
  // Generate the wrapper function
  lines.push(`/**`);
  lines.push(` * Create a verified wrapper for ${behaviorName}`);
  lines.push(` * `);
  lines.push(` * @param implementation - The actual implementation function`);
  lines.push(` * @returns A wrapped function that verifies pre/postconditions`);
  lines.push(` */`);
  lines.push(`export function create${behaviorName}Wrapper(`);
  lines.push(`  implementation: ${behaviorName}Impl`);
  lines.push(`): ${behaviorName}Impl {`);
  lines.push(`  return async function verified${behaviorName}(`);
  lines.push(`    __input: ${inputType},`);
  lines.push(`    context: VerificationContext = {}`);
  lines.push(`  ): Promise<${outputType}> {`);
  lines.push(`    const __entityStore = context.entityStore ?? new InMemoryEntityStore();`);
  lines.push('');
  
  // Preconditions
  if (behavior.preconditions && behavior.preconditions.length > 0 && mode !== 'production') {
    lines.push(`    // ═══════════════════════════════════════════════════════════════════`);
    lines.push(`    // PRECONDITION CHECKS`);
    lines.push(`    // ═══════════════════════════════════════════════════════════════════`);
    lines.push(`    if (!context.skipPreconditions) {`);
    lines.push(compileAssertions(behavior.preconditions, 'precondition', behaviorName, throwOnFailure));
    lines.push(`    }`);
    lines.push('');
  }
  
  // Capture old state for postconditions
  const hasOldExpressions = hasOldReferences(behavior.postconditions ?? []);
  if (hasOldExpressions) {
    lines.push(`    // Capture pre-execution state for old() references`);
    lines.push(`    const __old = {`);
    const oldFields = extractOldFields(behavior.postconditions ?? []);
    for (const field of oldFields) {
      lines.push(`      ${field}: deepClone(__input.${field}),`);
    }
    lines.push(`    };`);
    lines.push('');
  }
  
  // Invariants (before)
  if (behavior.invariants && behavior.invariants.length > 0 && mode !== 'production') {
    lines.push(`    // ═══════════════════════════════════════════════════════════════════`);
    lines.push(`    // INVARIANT CHECKS (before)`);
    lines.push(`    // ═══════════════════════════════════════════════════════════════════`);
    lines.push(`    if (!context.skipInvariants) {`);
    lines.push(compileAssertions(behavior.invariants, 'invariant', behaviorName, throwOnFailure));
    lines.push(`    }`);
    lines.push('');
  }
  
  // Call implementation
  lines.push(`    // ═══════════════════════════════════════════════════════════════════`);
  lines.push(`    // EXECUTE IMPLEMENTATION`);
  lines.push(`    // ═══════════════════════════════════════════════════════════════════`);
  lines.push(`    const __result = await implementation(__input, context);`);
  lines.push('');
  
  // Postconditions
  if (behavior.postconditions && behavior.postconditions.length > 0 && mode !== 'production') {
    lines.push(`    // ═══════════════════════════════════════════════════════════════════`);
    lines.push(`    // POSTCONDITION CHECKS`);
    lines.push(`    // ═══════════════════════════════════════════════════════════════════`);
    lines.push(`    if (!context.skipPostconditions) {`);
    
    for (const postcond of behavior.postconditions) {
      const condName = typeof postcond.condition === 'string' 
        ? postcond.condition 
        : postcond.condition.name;
      
      if (postcond.predicates && postcond.predicates.length > 0) {
        lines.push(`      // ${condName} postconditions`);
        lines.push(compileAssertions(postcond.predicates, 'postcondition', behaviorName, throwOnFailure));
      }
    }
    
    lines.push(`    }`);
    lines.push('');
  }
  
  // Invariants (after)
  if (behavior.invariants && behavior.invariants.length > 0 && mode !== 'production') {
    lines.push(`    // ═══════════════════════════════════════════════════════════════════`);
    lines.push(`    // INVARIANT CHECKS (after)`);
    lines.push(`    // ═══════════════════════════════════════════════════════════════════`);
    lines.push(`    if (!context.skipInvariants) {`);
    lines.push(compileAssertions(behavior.invariants, 'invariant', behaviorName, throwOnFailure));
    lines.push(`    }`);
    lines.push('');
  }
  
  lines.push(`    return __result;`);
  lines.push(`  };`);
  lines.push(`}`);
  lines.push('');
  
  // Export convenience function
  lines.push(`/**`);
  lines.push(` * Wrap an existing ${behaviorName} implementation with verification`);
  lines.push(` */`);
  lines.push(`export function wrap${behaviorName}(impl: ${behaviorName}Impl): ${behaviorName}Impl {`);
  lines.push(`  return create${behaviorName}Wrapper(impl);`);
  lines.push(`}`);
  
  return lines.join('\n');
}

/**
 * Generate types for a domain
 */
function generateTypes(domain: Domain, includeComments: boolean): string {
  const lines: string[] = [];
  
  lines.push(`/**`);
  lines.push(` * Types for ${domain.name.name}`);
  lines.push(` * Auto-generated by @isl-lang/codegen-runtime`);
  lines.push(` */`);
  lines.push('');
  
  // Entity types
  for (const entity of domain.entities) {
    if (includeComments) {
      lines.push(`/** ${entity.name.name} entity */`);
    }
    lines.push(`export interface ${entity.name.name} {`);
    for (const field of entity.fields ?? []) {
      const tsType = mapToTSType(field.type);
      const optional = field.optional ? '?' : '';
      lines.push(`  ${field.name.name}${optional}: ${tsType};`);
    }
    lines.push(`}`);
    lines.push('');
  }
  
  // Behavior input/output types
  for (const behavior of domain.behaviors) {
    const behaviorName = behavior.name.name;
    
    // Input type
    if (behavior.input?.fields && behavior.input.fields.length > 0) {
      if (includeComments) {
        lines.push(`/** Input for ${behaviorName} */`);
      }
      lines.push(`export interface ${behaviorName}Input {`);
      for (const field of behavior.input.fields) {
        const tsType = mapToTSType(field.type);
        const optional = field.optional ? '?' : '';
        lines.push(`  ${field.name.name}${optional}: ${tsType};`);
      }
      lines.push(`}`);
      lines.push('');
    } else {
      lines.push(`export type ${behaviorName}Input = void;`);
      lines.push('');
    }
    
    // Output type
    if (behavior.output?.success) {
      lines.push(`export type ${behaviorName}Output = ${mapToTSType(behavior.output.success)};`);
    } else {
      lines.push(`export type ${behaviorName}Output = void;`);
    }
    lines.push('');
  }
  
  return lines.join('\n');
}

/**
 * Generate index file
 */
function generateIndex(domain: Domain): string {
  const lines: string[] = [];
  
  lines.push(`/**`);
  lines.push(` * ${domain.name.name} - Runtime Verified Exports`);
  lines.push(` * Auto-generated by @isl-lang/codegen-runtime`);
  lines.push(` */`);
  lines.push('');
  lines.push(`export * from './helpers.js';`);
  lines.push(`export * from './types.js';`);
  lines.push('');
  
  for (const behavior of domain.behaviors) {
    const kebab = toKebabCase(behavior.name.name);
    lines.push(`export * from './${kebab}.wrapper.js';`);
  }
  
  return lines.join('\n');
}

// ============================================================================
// Helpers
// ============================================================================

function mapToTSType(typeRef: unknown): string {
  if (!typeRef) return 'unknown';
  
  if (typeof typeRef === 'object' && typeRef !== null) {
    const t = typeRef as Record<string, unknown>;
    
    if (t.kind === 'PrimitiveType' || t.kind === 'ReferenceType') {
      const name = (t.name as { name?: string })?.name ?? (t.name as string);
      const typeMap: Record<string, string> = {
        'String': 'string',
        'Int': 'number',
        'Integer': 'number',
        'Float': 'number',
        'Decimal': 'number',
        'Boolean': 'boolean',
        'Bool': 'boolean',
        'UUID': 'string',
        'Timestamp': 'Date',
        'DateTime': 'Date',
      };
      return typeMap[name] ?? name ?? 'unknown';
    }
    
    if ('name' in t) {
      const name = typeof t.name === 'string' ? t.name : (t.name as { name?: string })?.name;
      if (name) {
        const typeMap: Record<string, string> = {
          'String': 'string',
          'Int': 'number',
          'Boolean': 'boolean',
          'UUID': 'string',
        };
        return typeMap[name] ?? name;
      }
    }
  }
  
  return 'unknown';
}

function hasOldReferences(postconditions: { predicates?: Expression[] }[]): boolean {
  for (const p of postconditions) {
    for (const pred of p.predicates ?? []) {
      if (containsOld(pred)) return true;
    }
  }
  return false;
}

function containsOld(expr: Expression): boolean {
  if (expr.kind === 'OldExpr') return true;
  
  // Recursively check sub-expressions
  if ('left' in expr && expr.left) {
    if (containsOld(expr.left as Expression)) return true;
  }
  if ('right' in expr && expr.right) {
    if (containsOld(expr.right as Expression)) return true;
  }
  if ('operand' in expr && expr.operand) {
    if (containsOld(expr.operand as Expression)) return true;
  }
  if ('object' in expr && expr.object) {
    if (containsOld(expr.object as Expression)) return true;
  }
  
  return false;
}

function extractOldFields(postconditions: { predicates?: Expression[] }[]): string[] {
  const fields = new Set<string>();
  
  for (const p of postconditions) {
    for (const pred of p.predicates ?? []) {
      extractOldFieldsFromExpr(pred, fields);
    }
  }
  
  return [...fields];
}

function extractOldFieldsFromExpr(expr: Expression, fields: Set<string>): void {
  if (expr.kind === 'OldExpr') {
    // Try to extract the field name from old(x.field) or old(field)
    const inner = (expr as { expression: Expression }).expression;
    if (inner.kind === 'MemberExpr') {
      const obj = (inner as { object: Expression }).object;
      if (obj.kind === 'Identifier') {
        fields.add((obj as { name: string }).name);
      }
    } else if (inner.kind === 'Identifier') {
      fields.add((inner as { name: string }).name);
    }
  }
  
  // Recursively check sub-expressions
  if ('left' in expr && expr.left) {
    extractOldFieldsFromExpr(expr.left as Expression, fields);
  }
  if ('right' in expr && expr.right) {
    extractOldFieldsFromExpr(expr.right as Expression, fields);
  }
  if ('operand' in expr && expr.operand) {
    extractOldFieldsFromExpr(expr.operand as Expression, fields);
  }
  if ('object' in expr && expr.object) {
    extractOldFieldsFromExpr(expr.object as Expression, fields);
  }
}

function toKebabCase(str: string): string {
  return str.replace(/([A-Z])/g, '-$1').toLowerCase().replace(/^-/, '');
}
