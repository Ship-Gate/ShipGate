/**
 * Generation Step
 *
 * Generates verification artifacts (tests, types, etc.) from the ISL AST.
 * This is a stub implementation - actual generation is handled by codegen packages.
 */

import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import * as os from 'node:os';
import type { Domain } from '@isl-lang/parser';
import type { GenerateStepResult, PipelineState } from '../pipelineTypes.js';

/**
 * Generate a stub test file for verification
 *
 * @param ast - The Domain AST
 * @param tempDir - Directory to write to
 * @returns Path to generated file
 */
async function generateStubTestFile(ast: Domain, tempDir: string): Promise<string> {
  const domainName = ast.name?.value || 'unnamed';
  const fileName = `${domainName.toLowerCase()}.stub.ts`;
  const filePath = path.join(tempDir, fileName);

  const content = `/**
 * Stub test file for ${domainName}
 * Generated by ISL Pipeline
 */

// Domain: ${domainName}
// Version: ${ast.version?.value || 'unknown'}

export const domainName = '${domainName}';
export const entityCount = ${ast.entities.length};
export const behaviorCount = ${ast.behaviors.length};
export const invariantCount = ${ast.invariants.length};

// Entity names
export const entities = [
${ast.entities.map((e) => `  '${e.name?.value || 'unnamed'}',`).join('\n')}
];

// Behavior names
export const behaviors = [
${ast.behaviors.map((b) => `  '${b.name?.value || 'unnamed'}',`).join('\n')}
];
`;

  await fs.writeFile(filePath, content, 'utf-8');
  return filePath;
}

/**
 * Create a temporary directory for generated files
 *
 * @param prefix - Directory name prefix
 * @returns Path to created directory
 */
async function createTempDirectory(prefix: string): Promise<string> {
  const tempBase = os.tmpdir();
  const dirName = `${prefix}-${Date.now()}`;
  const tempDir = path.join(tempBase, dirName);
  await fs.mkdir(tempDir, { recursive: true });
  return tempDir;
}

/**
 * Run the generation step
 *
 * In a real implementation, this would use the codegen packages to generate
 * tests, types, and other artifacts. This stub implementation creates
 * a temporary directory with basic metadata files.
 *
 * @param state - Current pipeline state
 * @returns Generation step result
 */
export async function runGenerateStep(state: PipelineState): Promise<GenerateStepResult> {
  const startTime = performance.now();
  const warnings: string[] = [];
  const filesGenerated: string[] = [];

  try {
    if (!state.ast) {
      return {
        stepName: 'generate',
        success: false,
        error: 'No AST available for generation',
        durationMs: performance.now() - startTime,
        warnings,
      };
    }

    // Don't generate files in dry run mode
    if (state.options.dryRun) {
      warnings.push('Dry run mode - skipping file generation');
      return {
        stepName: 'generate',
        success: true,
        data: {
          filesGenerated: [],
        },
        durationMs: performance.now() - startTime,
        warnings,
      };
    }

    // Create temp directory for generated files
    const tempDir = await createTempDirectory('isl-pipeline');
    warnings.push(`Generated files in temporary directory: ${tempDir}`);

    // Generate stub test file
    const testFile = await generateStubTestFile(state.ast, tempDir);
    filesGenerated.push(testFile);

    // Generate metadata JSON
    const metadataFile = path.join(tempDir, 'metadata.json');
    const metadata = {
      domainName: state.ast.name?.value,
      version: state.ast.version?.value,
      entityCount: state.ast.entities.length,
      behaviorCount: state.ast.behaviors.length,
      invariantCount: state.ast.invariants.length,
      generatedAt: new Date().toISOString(),
    };
    await fs.writeFile(metadataFile, JSON.stringify(metadata, null, 2), 'utf-8');
    filesGenerated.push(metadataFile);

    return {
      stepName: 'generate',
      success: true,
      data: {
        filesGenerated,
        tempDir,
      },
      durationMs: performance.now() - startTime,
      warnings,
    };
  } catch (error) {
    return {
      stepName: 'generate',
      success: false,
      error: error instanceof Error ? error.message : String(error),
      durationMs: performance.now() - startTime,
      warnings,
    };
  }
}
