/**
 * Markdown Report Generator
 *
 * Produces clean, professional Markdown verification reports suitable
 * for GitHub PR comments, documentation, and conversion to PDF.
 */

import type {
  ReportData,
  ReportFileResult,
  ReportScope,
  ReportVerdict,
  TrendDataPoint,
} from './reportTypes.js';

// ─────────────────────────────────────────────────────────────────────────────
// Verdict Formatting
// ─────────────────────────────────────────────────────────────────────────────

const VERDICT_EMOJI: Record<ReportVerdict, string> = {
  SHIP: '\u2705',    // green check
  WARN: '\u26A0\uFE0F',  // warning
  NO_SHIP: '\u274C', // red X
};

const VERDICT_LABEL: Record<ReportVerdict, string> = {
  SHIP: 'SHIP',
  WARN: 'WARN',
  NO_SHIP: 'NO_SHIP',
};

function formatScore(score: number): string {
  return (score * 100).toFixed(0);
}

function formatDuration(ms: number): string {
  if (ms < 1000) return `${ms}ms`;
  return `${(ms / 1000).toFixed(1)}s`;
}

// ─────────────────────────────────────────────────────────────────────────────
// Markdown Builder
// ─────────────────────────────────────────────────────────────────────────────

/** Generate a Markdown verification report */
export function generateMarkdownReport(
  data: ReportData,
  scope: ReportScope = 'full',
  options?: { includeRecommendations?: boolean; includeTrends?: boolean; title?: string },
): string {
  const lines: string[] = [];
  const title = options?.title ?? 'ShipGate Verification Report';

  // Header
  lines.push(`# ${title}`);
  lines.push('');
  lines.push(`**Repository:** ${data.repository.repository}`);
  lines.push(`**Branch:** ${data.repository.branch}`);
  if (data.repository.commit) {
    lines.push(`**Commit:** \`${data.repository.commit}\``);
  }
  lines.push(`**Date:** ${formatDate(data.generatedAt)}`);
  lines.push(
    `**Verdict:** ${VERDICT_EMOJI[data.verdict]} ${VERDICT_LABEL[data.verdict]} (Score: ${formatScore(data.score)})`,
  );
  lines.push('');

  // Summary table
  lines.push(...renderSummaryTable(data));

  // Failures section
  const failures = data.files.filter((f) => f.status === 'FAIL');
  if (failures.length > 0) {
    lines.push('## Failures');
    lines.push('');
    for (const file of failures) {
      lines.push(...renderFileDetail(file));
    }
  }

  // Warnings section (full and summary scope)
  if (scope !== 'failures-only') {
    const warnings = data.files.filter((f) => f.status === 'WARN');
    if (warnings.length > 0) {
      lines.push('## Warnings');
      lines.push('');
      for (const file of warnings) {
        lines.push(...renderFileDetail(file));
      }
    }
  }

  // Passing files (full scope only)
  if (scope === 'full') {
    const passing = data.files.filter((f) => f.status === 'PASS');
    if (passing.length > 0) {
      lines.push('## Passing');
      lines.push('');
      lines.push(...renderPassingTable(passing));
    }
  }

  // Coverage trend
  if (
    options?.includeTrends !== false &&
    data.trends &&
    data.trends.length > 0
  ) {
    lines.push(...renderTrends(data.trends));
  }

  // Recommendations
  if (
    options?.includeRecommendations !== false &&
    data.recommendations.length > 0
  ) {
    lines.push('## Recommendations');
    lines.push('');
    for (const rec of data.recommendations) {
      const target = rec.target ? ` (\`${rec.target}\`)` : '';
      lines.push(`${rec.priority}. ${rec.text}${target}`);
    }
    lines.push('');
  }

  // Footer
  lines.push('---');
  lines.push(
    `*Generated by ShipGate in ${formatDuration(data.duration)} | Mode: ${data.mode}*`,
  );
  lines.push('');

  return lines.join('\n');
}

// ─────────────────────────────────────────────────────────────────────────────
// Section Renderers
// ─────────────────────────────────────────────────────────────────────────────

function renderSummaryTable(data: ReportData): string[] {
  const lines: string[] = [];
  lines.push('## Summary');
  lines.push('');
  lines.push('| Metric | Value |');
  lines.push('|--------|-------|');
  lines.push(`| Files Verified | ${data.coverage.totalFiles} |`);
  lines.push(
    `| ISL Coverage | ${data.coverage.coveragePercent}% (${data.coverage.specCoveredFiles}/${data.coverage.totalFiles}) |`,
  );
  lines.push(`| Passing | ${data.coverage.passingFiles} |`);
  lines.push(`| Warnings | ${data.coverage.warningFiles} |`);
  lines.push(`| Failures | ${data.coverage.failingFiles} |`);
  lines.push(`| Duration | ${formatDuration(data.duration)} |`);
  lines.push('');
  return lines;
}

function renderFileDetail(file: ReportFileResult): string[] {
  const lines: string[] = [];
  const scoreStr = formatScore(file.score);
  lines.push(
    `### \`${file.file}\` \u2014 ${file.status} (Score: ${scoreStr})`,
  );
  lines.push(`**Method:** ${file.method}`);

  if (file.finding) {
    lines.push(`**Finding:** ${file.finding}`);
    lines.push('');
    lines.push(file.finding);
  }

  if (file.blockers.length > 0) {
    lines.push('');
    lines.push('**Blockers:**');
    for (const b of file.blockers) {
      lines.push(`- ${b}`);
    }
  }

  if (file.recommendation) {
    lines.push('');
    lines.push(`**Recommendation:** ${file.recommendation}`);
  }

  lines.push('');
  return lines;
}

function renderPassingTable(files: ReportFileResult[]): string[] {
  const lines: string[] = [];
  lines.push('| File | Method | Score |');
  lines.push('|------|--------|-------|');
  for (const f of files) {
    lines.push(
      `| \`${f.file}\` | ${f.method} | ${formatScore(f.score)} |`,
    );
  }
  lines.push('');
  return lines;
}

function renderTrends(trends: TrendDataPoint[]): string[] {
  const lines: string[] = [];
  lines.push('## Coverage Trend');
  lines.push('');
  lines.push('| Date | Coverage | Score | Label |');
  lines.push('|------|----------|-------|-------|');
  for (const t of trends) {
    const label = t.label ?? '';
    lines.push(
      `| ${formatDate(t.date)} | ${t.coverage}% | ${t.score.toFixed(0)} | ${label} |`,
    );
  }
  lines.push('');
  return lines;
}

// ─────────────────────────────────────────────────────────────────────────────
// Helpers
// ─────────────────────────────────────────────────────────────────────────────

function formatDate(iso: string): string {
  try {
    return new Date(iso).toISOString().split('T')[0] ?? iso;
  } catch {
    return iso;
  }
}
