/**
 * Evidence Report HTML Renderer
 *
 * Generates static HTML reports from evidence-report.json files.
 * Shows score, ship decision, clause results, assumptions, questions, and artifacts.
 */

import type {
  EvidenceReport,
  EvidenceClauseResult,
  RenderOptions,
  GroupedClauses,
  ReportStats,
  ThemeColors,
} from './viewerTypes.js';
import { lightTheme, darkTheme } from './viewerTypes.js';
import {
  generateStyles,
  renderHeader,
  renderScoreCard,
  renderClauseList,
  renderAssumptions,
  renderOpenQuestions,
  renderArtifacts,
  renderFooter,
  wrapInDocument,
} from './templates.js';

/**
 * Default render options
 */
const defaultOptions: Required<RenderOptions> = {
  title: 'Evidence Report',
  includeStyles: true,
  showTimestamp: true,
  collapsePassed: false,
  classPrefix: 'ev',
  artifactBasePath: '.',
  fullDocument: true,
  footerText: 'Generated by ISL Evidence Viewer',
  darkMode: false,
};

/**
 * Groups clause results by their state
 */
export function groupClausesByState(clauses: EvidenceClauseResult[]): GroupedClauses {
  return {
    pass: clauses.filter((c) => c.state === 'PASS'),
    partial: clauses.filter((c) => c.state === 'PARTIAL'),
    fail: clauses.filter((c) => c.state === 'FAIL'),
  };
}

/**
 * Calculates statistics from an evidence report
 */
export function calculateStats(report: EvidenceReport): ReportStats {
  const grouped = groupClausesByState(report.clauseResults);
  
  return {
    totalClauses: report.scoreSummary.totalClauses,
    passCount: grouped.pass.length,
    partialCount: grouped.partial.length,
    failCount: grouped.fail.length,
    passRate: report.scoreSummary.passRate,
    assumptionCount: report.assumptions.length,
    questionCount: report.openQuestions.length,
    artifactCount: report.artifacts.length,
    highPriorityQuestions: report.openQuestions.filter((q) => q.priority === 'high').length,
    criticalAssumptions: report.assumptions.filter((a) => a.impact === 'critical').length,
  };
}

/**
 * Renders an evidence report as HTML
 *
 * @param report - The evidence report to render
 * @param options - Rendering options
 * @returns HTML string
 *
 * @example
 * ```ts
 * import { renderHtml } from './renderHtml.js';
 *
 * const report = JSON.parse(fs.readFileSync('evidence-report.json', 'utf-8'));
 * const html = renderHtml(report, { darkMode: true });
 * fs.writeFileSync('report.html', html);
 * ```
 */
export function renderHtml(
  report: EvidenceReport,
  options: RenderOptions = {}
): string {
  // Merge with defaults
  const opts: Required<RenderOptions> = {
    ...defaultOptions,
    ...options,
    title: options.title ?? report.specName ?? defaultOptions.title,
  };

  const prefix = opts.classPrefix;
  const theme: ThemeColors = opts.darkMode ? darkTheme : lightTheme;
  const grouped = groupClausesByState(report.clauseResults);

  // Generate sections
  const headerHtml = renderHeader(
    opts.title,
    report.specPath,
    report.specFingerprint,
    report.metadata,
    opts.showTimestamp,
    prefix
  );

  const scoreCardHtml = renderScoreCard(report.scoreSummary, prefix, theme);

  // Render clause lists - FAIL first (most important), then PARTIAL, then PASS
  const failListHtml = renderClauseList(grouped.fail, 'Failed Clauses', 'FAIL', prefix);
  const partialListHtml = renderClauseList(grouped.partial, 'Partial Clauses', 'PARTIAL', prefix);
  const passListHtml = renderClauseList(grouped.pass, 'Passed Clauses', 'PASS', prefix);

  const assumptionsHtml = renderAssumptions(report.assumptions, prefix);
  const questionsHtml = renderOpenQuestions(report.openQuestions, prefix);
  const artifactsHtml = renderArtifacts(report.artifacts, prefix, opts.artifactBasePath);
  const footerHtml = renderFooter(opts.footerText, prefix);

  // Optional notes section
  const notesHtml = report.notes
    ? `<div class="${prefix}-section">
        <h3 class="${prefix}-section-title">Notes</h3>
        <div class="${prefix}-item" style="white-space: pre-wrap;">${escapeHtmlForNotes(report.notes)}</div>
      </div>`
    : '';

  // Assemble content
  const content = `
    <div class="${prefix}-report">
      ${headerHtml}
      ${scoreCardHtml}
      ${failListHtml}
      ${partialListHtml}
      ${passListHtml}
      ${assumptionsHtml}
      ${questionsHtml}
      ${artifactsHtml}
      ${notesHtml}
      ${footerHtml}
    </div>
  `;

  // Generate styles
  const styles = opts.includeStyles ? generateStyles(theme, prefix) : '';

  // Return as full document or fragment
  if (opts.fullDocument) {
    return wrapInDocument(content, styles, opts.title);
  }

  return opts.includeStyles
    ? `<style>${styles}</style>${content}`
    : content;
}

/**
 * Escape HTML for notes (preserves newlines)
 */
function escapeHtmlForNotes(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

/**
 * Renders a minimal summary card (for embedding in other views)
 *
 * @param report - The evidence report
 * @param options - Rendering options
 * @returns HTML string with just the score card
 */
export function renderSummaryCard(
  report: EvidenceReport,
  options: Pick<RenderOptions, 'classPrefix' | 'darkMode'> = {}
): string {
  const prefix = options.classPrefix ?? 'ev';
  const theme = options.darkMode ? darkTheme : lightTheme;
  
  const styles = generateStyles(theme, prefix);
  const scoreCard = renderScoreCard(report.scoreSummary, prefix, theme);

  return `<style>${styles}</style><div class="${prefix}-report">${scoreCard}</div>`;
}

/**
 * Renders just the clauses section (for partial updates)
 *
 * @param clauses - Array of clause results
 * @param options - Rendering options
 * @returns HTML string with clause lists
 */
export function renderClausesOnly(
  clauses: EvidenceClauseResult[],
  options: Pick<RenderOptions, 'classPrefix' | 'darkMode'> = {}
): string {
  const prefix = options.classPrefix ?? 'ev';
  const theme = options.darkMode ? darkTheme : lightTheme;
  const grouped = groupClausesByState(clauses);

  const styles = generateStyles(theme, prefix);
  const failListHtml = renderClauseList(grouped.fail, 'Failed Clauses', 'FAIL', prefix);
  const partialListHtml = renderClauseList(grouped.partial, 'Partial Clauses', 'PARTIAL', prefix);
  const passListHtml = renderClauseList(grouped.pass, 'Passed Clauses', 'PASS', prefix);

  return `<style>${styles}</style><div class="${prefix}-report">${failListHtml}${partialListHtml}${passListHtml}</div>`;
}

/**
 * Generates a plain text summary (for terminals/logs)
 *
 * @param report - The evidence report
 * @returns Plain text summary
 */
export function renderTextSummary(report: EvidenceReport): string {
  const summary = report.scoreSummary;
  const grouped = groupClausesByState(report.clauseResults);
  
  const lines: string[] = [
    `═══════════════════════════════════════════════════════════`,
    `  ISL EVIDENCE REPORT: ${report.specName ?? 'Unknown Spec'}`,
    `═══════════════════════════════════════════════════════════`,
    ``,
    `  SCORE: ${summary.overallScore}/100  |  DECISION: ${summary.recommendation.toUpperCase()}`,
    `  Confidence: ${summary.confidence}  |  Pass Rate: ${summary.passRate.toFixed(1)}%`,
    ``,
    `  ┌─────────────────────────────────────────────────────────┐`,
    `  │  PASS: ${String(summary.passCount).padStart(3)}  │  PARTIAL: ${String(summary.partialCount).padStart(3)}  │  FAIL: ${String(summary.failCount).padStart(3)}  │`,
    `  └─────────────────────────────────────────────────────────┘`,
    ``,
  ];

  // Add failed clauses
  if (grouped.fail.length > 0) {
    lines.push(`  FAILED CLAUSES (${grouped.fail.length}):`);
    for (const clause of grouped.fail) {
      lines.push(`    ✗ ${clause.clauseId}${clause.message ? `: ${clause.message}` : ''}`);
    }
    lines.push(``);
  }

  // Add partial clauses
  if (grouped.partial.length > 0) {
    lines.push(`  PARTIAL CLAUSES (${grouped.partial.length}):`);
    for (const clause of grouped.partial) {
      lines.push(`    ◐ ${clause.clauseId}${clause.message ? `: ${clause.message}` : ''}`);
    }
    lines.push(``);
  }

  // Add passed clauses (abbreviated)
  if (grouped.pass.length > 0) {
    lines.push(`  PASSED CLAUSES (${grouped.pass.length}):`);
    const displayCount = Math.min(5, grouped.pass.length);
    for (let i = 0; i < displayCount; i++) {
      const clause = grouped.pass[i];
      if (clause) {
        lines.push(`    ✓ ${clause.clauseId}`);
      }
    }
    if (grouped.pass.length > 5) {
      lines.push(`    ... and ${grouped.pass.length - 5} more`);
    }
    lines.push(``);
  }

  // Add assumptions
  if (report.assumptions.length > 0) {
    lines.push(`  ASSUMPTIONS (${report.assumptions.length}):`);
    for (const assumption of report.assumptions) {
      const impact = assumption.impact.toUpperCase().padEnd(8);
      lines.push(`    [${impact}] ${assumption.description}`);
    }
    lines.push(``);
  }

  // Add open questions
  if (report.openQuestions.length > 0) {
    lines.push(`  OPEN QUESTIONS (${report.openQuestions.length}):`);
    for (const question of report.openQuestions) {
      const priority = question.priority.toUpperCase().padEnd(6);
      lines.push(`    [${priority}] ${question.question}`);
    }
    lines.push(``);
  }

  // Add artifacts
  if (report.artifacts.length > 0) {
    lines.push(`  ARTIFACTS (${report.artifacts.length}):`);
    for (const artifact of report.artifacts) {
      const location = artifact.location ?? '(inline)';
      lines.push(`    - ${artifact.name} [${artifact.type}]: ${location}`);
    }
    lines.push(``);
  }

  lines.push(`───────────────────────────────────────────────────────────`);
  lines.push(`  Fingerprint: ${report.specFingerprint.substring(0, 16)}...`);
  lines.push(`  Generated: ${report.metadata.completedAt}`);
  lines.push(`  Duration: ${report.metadata.durationMs}ms`);
  lines.push(`═══════════════════════════════════════════════════════════`);

  return lines.join('\n');
}

// Re-export types
export type { EvidenceReport, RenderOptions, GroupedClauses, ReportStats };
