// ============================================================================
// Go Test Adapter
// Generates executable Go tests (go test)
// ============================================================================

import type * as AST from '@isl-lang/parser';
import type {
  LanguageAdapter,
  ExecutableTestOptions,
  TestBinding,
  PostconditionBinding,
  PreconditionBinding,
  ErrorBinding,
  CompilationContext,
} from '../types.js';

export class GoAdapter implements LanguageAdapter {
  language = 'go' as const;

  generateHeader(options: ExecutableTestOptions, binding: TestBinding): string {
    const packageName = this.toSnakeCase(binding.behaviorName);
    return `// Code generated by @isl-lang/codegen-tests. DO NOT EDIT.
package ${packageName}_test

import (
	"context"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"${options.implementationPath}"
	"${options.implementationPath}/testruntime"
	"${options.implementationPath}/fixtures"
)
`;
  }

  generateSetup(binding: TestBinding): string {
    return `
func setupTest(t *testing.T) (*testruntime.TestContext, *testruntime.StateCapture) {
	t.Helper()
	ctx := testruntime.NewTestContext(map[string][]interface{}{
		// Bind entities to test data
	})
	oldState := ctx.CaptureState()
	return ctx, oldState
}

func createValidInput() *${this.toPascalCase(binding.behaviorName)}Input {
	return fixtures.CreateValid${this.toPascalCase(binding.behaviorName)}Input()
}

func createInvalidInput() *${this.toPascalCase(binding.behaviorName)}Input {
	return fixtures.CreateInvalid${this.toPascalCase(binding.behaviorName)}Input()
}
`;
  }

  generatePostconditionAssertion(
    postcondition: PostconditionBinding,
    binding: TestBinding
  ): string {
    const testName = this.sanitizeTestName(postcondition.description);
    const funcName = this.toPascalCase(binding.behaviorName);
    
    const conditionCheck = postcondition.condition === 'success'
      ? 'result.Success'
      : postcondition.condition === 'error'
        ? '!result.Success'
        : `result.Error == "${postcondition.condition}"`;

    return `
func TestPostcondition_${testName}(t *testing.T) {
	// Arrange
	ctx, oldState := setupTest(t)
	input := createValidInput()

	// Act
	result, err := ${funcName}(context.Background(), input)
	require.NoError(t, err)

	// Assert - postcondition must hold when condition is met
	if ${conditionCheck} {
		testruntime.AssertPostcondition(t, 
			${postcondition.assertionCode},
			"${this.escapeString(postcondition.description)}",
		)
	}
	_ = ctx
	_ = oldState
}
`;
  }

  generatePreconditionTest(
    precondition: PreconditionBinding,
    binding: TestBinding
  ): string {
    const testName = this.sanitizeTestName(precondition.description);
    const funcName = this.toPascalCase(binding.behaviorName);

    return `
func TestPrecondition_Validates_${testName}(t *testing.T) {
	// Arrange - input that violates precondition
	input := createInvalidInput()

	// Act
	result, err := ${funcName}(context.Background(), input)

	// Assert - should reject invalid input
	require.NoError(t, err)
	assert.False(t, result.Success, "Expected rejection of invalid input")
	assert.NotEmpty(t, result.Error, "Expected error message")
}

func TestPrecondition_Accepts_${testName}(t *testing.T) {
	// Arrange
	input := createValidInput()

	// Assert precondition holds for valid input
	testruntime.AssertPrecondition(t,
		${precondition.validationCode},
		"${this.escapeString(precondition.description)}",
	)
}
`;
  }

  generateErrorTest(error: ErrorBinding, binding: TestBinding): string {
    const testName = this.sanitizeTestName(error.name);
    const funcName = this.toPascalCase(binding.behaviorName);

    return `
func TestError_${testName}(t *testing.T) {
	// Arrange - input that triggers ${error.name}
	input := fixtures.Create${this.toPascalCase(error.name)}TriggerInput()

	// Act
	result, err := ${funcName}(context.Background(), input)
	require.NoError(t, err)

	// Assert
	assert.False(t, result.Success)
	assert.Equal(t, "${error.name}", result.Error)
	assert.Equal(t, ${error.retriable}, result.Retriable)
}
`;
  }

  generateViolationTest(
    postcondition: PostconditionBinding,
    binding: TestBinding
  ): string {
    const testName = this.sanitizeTestName(postcondition.description);

    return `
func TestViolation_${testName}(t *testing.T) {
	// This test verifies that our assertion DOES fail when the contract is violated.
	// If this test passes, the contract enforcement is working correctly.

	// Arrange - create a result that violates the contract
	mockResult := &${this.toPascalCase(binding.behaviorName)}Result{
		Success: ${postcondition.condition === 'success' ? 'true' : 'false'},
		// Deliberately violate the postcondition
	}

	// Act & Assert - the assertion should fail
	assert.Panics(t, func() {
		testruntime.AssertPostcondition(t,
			false, // Simulating violated condition
			"${this.escapeString(postcondition.description)}",
		)
	}, "Expected postcondition assertion to fail")
	_ = mockResult
}
`;
  }

  generateTestFile(
    behavior: AST.Behavior,
    domain: AST.Domain,
    binding: TestBinding,
    options: ExecutableTestOptions
  ): string {
    const header = this.generateHeader(options, binding);
    const setup = this.generateSetup(binding);
    const funcName = this.toPascalCase(binding.behaviorName);

    const postconditionTests = binding.postconditions
      .map(p => this.generatePostconditionAssertion(p, binding))
      .join('\n');

    const preconditionTests = binding.preconditions
      .map(p => this.generatePreconditionTest(p, binding))
      .join('\n');

    const errorTests = binding.errors
      .map(e => this.generateErrorTest(e, binding))
      .join('\n');

    return `${header}

/*
 * Executable Tests for ${behavior.name.name}
 *
 * These tests bind to the real implementation and assert contract compliance.
 * Tests WILL FAIL if the implementation violates any postcondition.
 */

${setup}

// =============================================================================
// Precondition Tests
// =============================================================================
${preconditionTests}

// =============================================================================
// Postcondition Tests
// =============================================================================
${postconditionTests}

// =============================================================================
// Error Case Tests
// =============================================================================
${errorTests}

// =============================================================================
// Contract Integration Tests
// =============================================================================

func TestContractIntegration_AllPostconditionsOnSuccess(t *testing.T) {
	// Arrange
	ctx, oldState := setupTest(t)
	input := createValidInput()

	// Act
	result, err := ${funcName}(context.Background(), input)
	require.NoError(t, err)

	// Assert all success postconditions
	if result.Success {
${binding.postconditions
  .filter(p => p.condition === 'success')
  .map(p => `		testruntime.AssertPostcondition(t, ${p.assertionCode}, "${this.escapeString(p.description)}")`)
  .join('\n')}
	}
	_ = ctx
	_ = oldState
}

func TestContractIntegration_AllPostconditionsOnError(t *testing.T) {
	// Arrange - trigger an error
	ctx, oldState := setupTest(t)
	input := createInvalidInput()

	// Act
	result, err := ${funcName}(context.Background(), input)
	require.NoError(t, err)

	// Assert all error postconditions
	if !result.Success {
${binding.postconditions
  .filter(p => p.condition === 'error')
  .map(p => `		testruntime.AssertPostcondition(t, ${p.assertionCode}, "${this.escapeString(p.description)}")`)
  .join('\n')}
	}
	_ = ctx
	_ = oldState
}
`;
  }

  compileExpression(expr: AST.Expression, context: CompilationContext): string {
    switch (expr.kind) {
      case 'Identifier':
        return expr.name;

      case 'StringLiteral':
        return `"${expr.value}"`;

      case 'NumberLiteral':
        return String(expr.value);

      case 'BooleanLiteral':
        return expr.value ? 'true' : 'false';

      case 'NullLiteral':
        return 'nil';

      case 'BinaryExpr':
        return this.compileBinaryExpr(expr, context);

      case 'UnaryExpr':
        return this.compileUnaryExpr(expr, context);

      case 'CallExpr':
        return this.compileCallExpr(expr, context);

      case 'MemberExpr':
        return `${this.compileExpression(expr.object, context)}.${this.toPascalCase(expr.property.name)}`;

      case 'IndexExpr':
        return `${this.compileExpression(expr.object, context)}[${this.compileExpression(expr.index, context)}]`;

      case 'QuantifierExpr':
        return this.compileQuantifierExpr(expr, context);

      case 'OldExpr':
        return this.compileOldExpr(expr, context);

      case 'ResultExpr':
        return expr.property ? `result.${this.toPascalCase(expr.property.name)}` : 'result';

      case 'InputExpr':
        return `input.${this.toPascalCase(expr.property.name)}`;

      default:
        return `/* unsupported: ${(expr as AST.ASTNode).kind} */`;
    }
  }

  private compileBinaryExpr(expr: AST.BinaryExpr, context: CompilationContext): string {
    const left = this.compileExpression(expr.left, context);
    const right = this.compileExpression(expr.right, context);
    
    switch (expr.operator) {
      case '==': return `(${left} == ${right})`;
      case '!=': return `(${left} != ${right})`;
      case 'and': return `(${left} && ${right})`;
      case 'or': return `(${left} || ${right})`;
      case 'implies': return `(!${left} || ${right})`;
      default: return `(${left} ${expr.operator} ${right})`;
    }
  }

  private compileUnaryExpr(expr: AST.UnaryExpr, context: CompilationContext): string {
    const operand = this.compileExpression(expr.operand, context);
    return expr.operator === 'not' ? `!(${operand})` : `${expr.operator}(${operand})`;
  }

  private compileCallExpr(expr: AST.CallExpr, context: CompilationContext): string {
    const args = expr.arguments.map(a => this.compileExpression(a, context)).join(', ');
    
    if (expr.callee.kind === 'MemberExpr') {
      const obj = expr.callee.object;
      const method = expr.callee.property.name;
      
      if (obj.kind === 'Identifier' && context.entityNames.includes(obj.name)) {
        const prefix = context.inOldExpr ? `oldState.Entities["${obj.name}"]` : `ctx.Entities["${obj.name}"]`;
        switch (method) {
          case 'exists':
            return `testruntime.EntityExists(${prefix}, map[string]interface{}{${args}})`;
          case 'lookup':
            return `testruntime.EntityLookup(${prefix}, map[string]interface{}{${args}})`;
          case 'count':
            return `testruntime.EntityCount(${prefix}, map[string]interface{}{${args}})`;
        }
      }
    }
    
    const callee = this.compileExpression(expr.callee, context);
    return `${callee}(${args})`;
  }

  private compileQuantifierExpr(expr: AST.QuantifierExpr, context: CompilationContext): string {
    const collection = this.compileExpression(expr.collection, context);
    const variable = expr.variable.name;
    const predicate = this.compileExpression(expr.predicate, context);

    switch (expr.quantifier) {
      case 'all':
        return `testruntime.All(${collection}, func(${variable} interface{}) bool { return ${predicate} })`;
      case 'any':
        return `testruntime.Any(${collection}, func(${variable} interface{}) bool { return ${predicate} })`;
      case 'none':
        return `!testruntime.Any(${collection}, func(${variable} interface{}) bool { return ${predicate} })`;
      case 'count':
        return `testruntime.Count(${collection}, func(${variable} interface{}) bool { return ${predicate} })`;
      default:
        return `testruntime.Filter(${collection}, func(${variable} interface{}) bool { return ${predicate} })`;
    }
  }

  private compileOldExpr(expr: AST.OldExpr, context: CompilationContext): string {
    const oldContext = { ...context, inOldExpr: true };
    return this.compileExpression(expr.expression, oldContext);
  }

  private toPascalCase(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  private toSnakeCase(str: string): string {
    return str.replace(/([A-Z])/g, '_$1').toLowerCase().replace(/^_/, '');
  }

  private sanitizeTestName(str: string): string {
    return str
      .replace(/[^a-zA-Z0-9]/g, '_')
      .replace(/_+/g, '_')
      .replace(/^_|_$/g, '')
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }

  private escapeString(str: string): string {
    return str.replace(/"/g, '\\"').replace(/\n/g, '\\n');
  }
}
