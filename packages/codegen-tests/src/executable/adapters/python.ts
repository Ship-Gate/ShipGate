// ============================================================================
// Python Test Adapter
// Generates executable Python tests (pytest/unittest)
// ============================================================================

import type * as AST from '@isl-lang/parser';
import type {
  LanguageAdapter,
  ExecutableTestOptions,
  TestBinding,
  PostconditionBinding,
  PreconditionBinding,
  ErrorBinding,
  CompilationContext,
} from '../types.js';

export class PythonAdapter implements LanguageAdapter {
  language = 'python' as const;
  private framework: 'pytest' | 'unittest';

  constructor(framework: 'pytest' | 'unittest' = 'pytest') {
    this.framework = framework;
  }

  generateHeader(options: ExecutableTestOptions, binding: TestBinding): string {
    const imports = this.framework === 'pytest'
      ? `import pytest`
      : `import unittest`;

    return `"""
Executable Tests for ${binding.behaviorName}
Generated by @isl-lang/codegen-tests
"""

${imports}
from typing import Any, Dict, Optional

from ${options.implementationPath.replace(/\//g, '.')} import ${this.toSnakeCase(binding.implementationName)}
from ${options.implementationPath.replace(/\//g, '.')}.types import ${binding.inputType.implType}, ${binding.outputType.implType}
from .helpers.test_runtime import (
    TestContext,
    StateCapture,
    assert_postcondition,
    assert_precondition,
    OldProxy,
)
from .fixtures import (
    create_valid_${this.toSnakeCase(binding.behaviorName)}_input,
    create_invalid_${this.toSnakeCase(binding.behaviorName)}_input,
)
`;
  }

  generateSetup(binding: TestBinding): string {
    if (this.framework === 'pytest') {
      return `
@pytest.fixture
def ctx():
    """Test context with entity bindings"""
    return TestContext({
        # Bind entities to test data
    })


@pytest.fixture
def valid_input():
    """Valid input for ${binding.behaviorName}"""
    return create_valid_${this.toSnakeCase(binding.behaviorName)}_input()


@pytest.fixture
def old_state(ctx):
    """Captured state before execution"""
    return ctx.capture_state()
`;
    }

    // unittest style
    return `
class Test${binding.behaviorName}(unittest.TestCase):
    def setUp(self):
        self.ctx = TestContext({
            # Bind entities to test data
        })
        self.valid_input = create_valid_${this.toSnakeCase(binding.behaviorName)}_input()
        self.old_state = self.ctx.capture_state()

    def tearDown(self):
        self.ctx.reset()
`;
  }

  generatePostconditionAssertion(
    postcondition: PostconditionBinding,
    binding: TestBinding
  ): string {
    const testName = this.toSnakeCase(postcondition.description).substring(0, 50);
    const funcName = this.toSnakeCase(binding.implementationName);
    
    const conditionCheck = postcondition.condition === 'success'
      ? 'result.success'
      : postcondition.condition === 'error'
        ? 'not result.success'
        : `result.error == "${postcondition.condition}"`;

    if (this.framework === 'pytest') {
      return `
def test_postcondition_${testName}(ctx, valid_input, old_state):
    """Postcondition: ${this.escapeString(postcondition.description)}"""
    # Arrange
    input_data = valid_input

    # Act
    result = ${funcName}(input_data)

    # Assert - postcondition must hold when condition is met
    if ${conditionCheck}:
        assert_postcondition(
            ${postcondition.assertionCode},
            "${this.escapeString(postcondition.description)}",
            {"input": input_data, "result": result, "old_state": old_state}
        )
`;
    }

    // unittest style
    return `
    def test_postcondition_${testName}(self):
        """Postcondition: ${this.escapeString(postcondition.description)}"""
        # Arrange
        input_data = self.valid_input

        # Act
        result = ${funcName}(input_data)

        # Assert - postcondition must hold when condition is met
        if ${conditionCheck}:
            assert_postcondition(
                ${postcondition.assertionCode},
                "${this.escapeString(postcondition.description)}",
                {"input": input_data, "result": result, "old_state": self.old_state}
            )
`;
  }

  generatePreconditionTest(
    precondition: PreconditionBinding,
    binding: TestBinding
  ): string {
    const testName = this.toSnakeCase(precondition.description).substring(0, 50);
    const funcName = this.toSnakeCase(binding.implementationName);

    if (this.framework === 'pytest') {
      return `
def test_precondition_validates_${testName}():
    """Should validate precondition: ${this.escapeString(precondition.description)}"""
    # Arrange - input that violates precondition
    invalid_input = create_invalid_${this.toSnakeCase(binding.behaviorName)}_input()

    # Act
    result = ${funcName}(invalid_input)

    # Assert - should reject invalid input
    assert not result.success, "Expected rejection of invalid input"
    assert result.error is not None, "Expected error message"


def test_precondition_accepts_${testName}():
    """Should accept valid input for precondition: ${this.escapeString(precondition.description)}"""
    # Arrange
    valid_input = create_valid_${this.toSnakeCase(binding.behaviorName)}_input()

    # Assert precondition holds for valid input
    assert_precondition(
        ${precondition.validationCode},
        "${this.escapeString(precondition.description)}",
        valid_input
    )
`;
    }

    // unittest style
    return `
    def test_precondition_validates_${testName}(self):
        """Should validate precondition: ${this.escapeString(precondition.description)}"""
        # Arrange - input that violates precondition
        invalid_input = create_invalid_${this.toSnakeCase(binding.behaviorName)}_input()

        # Act
        result = ${funcName}(invalid_input)

        # Assert - should reject invalid input
        self.assertFalse(result.success, "Expected rejection of invalid input")
        self.assertIsNotNone(result.error, "Expected error message")

    def test_precondition_accepts_${testName}(self):
        """Should accept valid input for precondition: ${this.escapeString(precondition.description)}"""
        # Assert precondition holds for valid input
        assert_precondition(
            ${precondition.validationCode},
            "${this.escapeString(precondition.description)}",
            self.valid_input
        )
`;
  }

  generateErrorTest(error: ErrorBinding, binding: TestBinding): string {
    const testName = this.toSnakeCase(error.name);
    const funcName = this.toSnakeCase(binding.implementationName);

    if (this.framework === 'pytest') {
      return `
def test_error_${testName}():
    """Should return ${error.name} when ${this.escapeString(error.when)}"""
    # Arrange - input that triggers ${error.name}
    input_data = create_${testName}_trigger_input()

    # Act
    result = ${funcName}(input_data)

    # Assert
    assert not result.success
    assert result.error == "${error.name}"
    assert result.retriable == ${error.retriable ? 'True' : 'False'}
`;
    }

    // unittest style
    return `
    def test_error_${testName}(self):
        """Should return ${error.name} when ${this.escapeString(error.when)}"""
        # Arrange - input that triggers ${error.name}
        input_data = create_${testName}_trigger_input()

        # Act
        result = ${funcName}(input_data)

        # Assert
        self.assertFalse(result.success)
        self.assertEqual(result.error, "${error.name}")
        self.assertEqual(result.retriable, ${error.retriable ? 'True' : 'False'})
`;
  }

  generateViolationTest(
    postcondition: PostconditionBinding,
    binding: TestBinding
  ): string {
    const testName = this.toSnakeCase(postcondition.description).substring(0, 50);

    if (this.framework === 'pytest') {
      return `
def test_violation_${testName}():
    """
    VIOLATION TEST: should fail when "${this.escapeString(postcondition.description)}" is violated
    
    This test verifies that our assertion DOES fail when the contract is violated.
    If this test passes, the contract enforcement is working correctly.
    """
    # Arrange - create a result that violates the contract
    mock_result = type('MockResult', (), {
        'success': ${postcondition.condition === 'success' ? 'True' : 'False'},
        # Deliberately violate the postcondition
    })()

    # Act & Assert - the assertion should fail
    with pytest.raises(AssertionError, match=r"Postcondition violated"):
        assert_postcondition(
            False,  # Simulating violated condition
            "${this.escapeString(postcondition.description)}",
            {"input": {}, "result": mock_result}
        )
`;
    }

    // unittest style
    return `
    def test_violation_${testName}(self):
        """
        VIOLATION TEST: should fail when "${this.escapeString(postcondition.description)}" is violated
        """
        # Arrange - create a result that violates the contract
        mock_result = type('MockResult', (), {
            'success': ${postcondition.condition === 'success' ? 'True' : 'False'},
        })()

        # Act & Assert - the assertion should fail
        with self.assertRaises(AssertionError):
            assert_postcondition(
                False,  # Simulating violated condition
                "${this.escapeString(postcondition.description)}",
                {"input": {}, "result": mock_result}
            )
`;
  }

  generateTestFile(
    behavior: AST.Behavior,
    domain: AST.Domain,
    binding: TestBinding,
    options: ExecutableTestOptions
  ): string {
    const header = this.generateHeader(options, binding);
    const setup = this.generateSetup(binding);
    const funcName = this.toSnakeCase(binding.implementationName);

    const postconditionTests = binding.postconditions
      .map(p => this.generatePostconditionAssertion(p, binding))
      .join('\n');

    const preconditionTests = binding.preconditions
      .map(p => this.generatePreconditionTest(p, binding))
      .join('\n');

    const errorTests = binding.errors
      .map(e => this.generateErrorTest(e, binding))
      .join('\n');

    if (this.framework === 'pytest') {
      return `${header}

${setup}

# =============================================================================
# Precondition Tests
# =============================================================================
${preconditionTests}

# =============================================================================
# Postcondition Tests
# =============================================================================
${postconditionTests}

# =============================================================================
# Error Case Tests
# =============================================================================
${errorTests}

# =============================================================================
# Contract Integration Tests
# =============================================================================

def test_contract_all_postconditions_on_success(ctx, valid_input, old_state):
    """All success postconditions should hold"""
    # Arrange
    input_data = valid_input

    # Act
    result = ${funcName}(input_data)

    # Assert all success postconditions
    if result.success:
${binding.postconditions
  .filter(p => p.condition === 'success')
  .map(p => `        assert_postcondition(${p.assertionCode}, "${this.escapeString(p.description)}", {"input": input_data, "result": result, "old_state": old_state})`)
  .join('\n')}


def test_contract_all_postconditions_on_error(ctx, old_state):
    """All error postconditions should hold"""
    # Arrange - trigger an error
    input_data = create_invalid_${this.toSnakeCase(binding.behaviorName)}_input()

    # Act
    result = ${funcName}(input_data)

    # Assert all error postconditions
    if not result.success:
${binding.postconditions
  .filter(p => p.condition === 'error')
  .map(p => `        assert_postcondition(${p.assertionCode}, "${this.escapeString(p.description)}", {"input": input_data, "result": result, "old_state": old_state})`)
  .join('\n')}
`;
    }

    // unittest style
    return `${header}

${setup}

    # =========================================================================
    # Precondition Tests
    # =========================================================================
${preconditionTests}

    # =========================================================================
    # Postcondition Tests
    # =========================================================================
${postconditionTests}

    # =========================================================================
    # Error Case Tests
    # =========================================================================
${errorTests}

    # =========================================================================
    # Contract Integration Tests
    # =========================================================================

    def test_contract_all_postconditions_on_success(self):
        """All success postconditions should hold"""
        result = ${funcName}(self.valid_input)
        if result.success:
${binding.postconditions
  .filter(p => p.condition === 'success')
  .map(p => `            assert_postcondition(${p.assertionCode}, "${this.escapeString(p.description)}", {"input": self.valid_input, "result": result, "old_state": self.old_state})`)
  .join('\n')}

    def test_contract_all_postconditions_on_error(self):
        """All error postconditions should hold"""
        invalid_input = create_invalid_${this.toSnakeCase(binding.behaviorName)}_input()
        result = ${funcName}(invalid_input)
        if not result.success:
${binding.postconditions
  .filter(p => p.condition === 'error')
  .map(p => `            assert_postcondition(${p.assertionCode}, "${this.escapeString(p.description)}", {"input": invalid_input, "result": result, "old_state": self.old_state})`)
  .join('\n')}


if __name__ == "__main__":
    unittest.main()
`;
  }

  compileExpression(expr: AST.Expression, context: CompilationContext): string {
    switch (expr.kind) {
      case 'Identifier':
        return expr.name;

      case 'StringLiteral':
        return `"${expr.value}"`;

      case 'NumberLiteral':
        return String(expr.value);

      case 'BooleanLiteral':
        return expr.value ? 'True' : 'False';

      case 'NullLiteral':
        return 'None';

      case 'BinaryExpr':
        return this.compileBinaryExpr(expr, context);

      case 'UnaryExpr':
        return this.compileUnaryExpr(expr, context);

      case 'CallExpr':
        return this.compileCallExpr(expr, context);

      case 'MemberExpr':
        return `${this.compileExpression(expr.object, context)}.${this.toSnakeCase(expr.property.name)}`;

      case 'IndexExpr':
        return `${this.compileExpression(expr.object, context)}[${this.compileExpression(expr.index, context)}]`;

      case 'QuantifierExpr':
        return this.compileQuantifierExpr(expr, context);

      case 'OldExpr':
        return this.compileOldExpr(expr, context);

      case 'ResultExpr':
        return expr.property ? `result.${this.toSnakeCase(expr.property.name)}` : 'result';

      case 'InputExpr':
        return `input_data.${this.toSnakeCase(expr.property.name)}`;

      case 'LambdaExpr':
        return `lambda ${expr.params.map(p => p.name).join(', ')}: ${this.compileExpression(expr.body, context)}`;

      case 'ListExpr':
        return `[${expr.elements.map(e => this.compileExpression(e, context)).join(', ')}]`;

      default:
        return `# unsupported: ${(expr as AST.ASTNode).kind}`;
    }
  }

  private compileBinaryExpr(expr: AST.BinaryExpr, context: CompilationContext): string {
    const left = this.compileExpression(expr.left, context);
    const right = this.compileExpression(expr.right, context);
    
    switch (expr.operator) {
      case '==': return `(${left} == ${right})`;
      case '!=': return `(${left} != ${right})`;
      case 'and': return `(${left} and ${right})`;
      case 'or': return `(${left} or ${right})`;
      case 'implies': return `(not ${left} or ${right})`;
      default: return `(${left} ${expr.operator} ${right})`;
    }
  }

  private compileUnaryExpr(expr: AST.UnaryExpr, context: CompilationContext): string {
    const operand = this.compileExpression(expr.operand, context);
    return expr.operator === 'not' ? `not (${operand})` : `${expr.operator}(${operand})`;
  }

  private compileCallExpr(expr: AST.CallExpr, context: CompilationContext): string {
    const args = expr.arguments.map(a => this.compileExpression(a, context)).join(', ');
    
    if (expr.callee.kind === 'MemberExpr') {
      const obj = expr.callee.object;
      const method = expr.callee.property.name;
      
      if (obj.kind === 'Identifier' && context.entityNames.includes(obj.name)) {
        const prefix = context.inOldExpr ? `old_state.entities["${obj.name}"]` : `ctx.entities["${obj.name}"]`;
        return `${prefix}.${this.toSnakeCase(method)}(${args})`;
      }
    }
    
    const callee = this.compileExpression(expr.callee, context);
    return `${callee}(${args})`;
  }

  private compileQuantifierExpr(expr: AST.QuantifierExpr, context: CompilationContext): string {
    const collection = this.compileExpression(expr.collection, context);
    const variable = expr.variable.name;
    const predicate = this.compileExpression(expr.predicate, context);

    switch (expr.quantifier) {
      case 'all':
        return `all(${predicate} for ${variable} in ${collection})`;
      case 'any':
        return `any(${predicate} for ${variable} in ${collection})`;
      case 'none':
        return `not any(${predicate} for ${variable} in ${collection})`;
      case 'count':
        return `sum(1 for ${variable} in ${collection} if ${predicate})`;
      default:
        return `[${variable} for ${variable} in ${collection} if ${predicate}]`;
    }
  }

  private compileOldExpr(expr: AST.OldExpr, context: CompilationContext): string {
    const oldContext = { ...context, inOldExpr: true };
    return this.compileExpression(expr.expression, oldContext);
  }

  private toSnakeCase(str: string): string {
    return str
      .replace(/([A-Z])/g, '_$1')
      .toLowerCase()
      .replace(/^_/, '')
      .replace(/[^a-z0-9_]/g, '_')
      .replace(/_+/g, '_');
  }

  private escapeString(str: string): string {
    return str.replace(/"/g, '\\"').replace(/\n/g, '\\n');
  }
}
