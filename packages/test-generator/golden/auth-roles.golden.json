[
  {
    "path": "./__snapshots__/AssignRole.snapshot.ts",
    "content": "import { describe, it, expect } from 'vitest';\nimport { AssignRole } from '../src/AssignRole';\nimport type { AssignRoleInput } from '../src/types';\n\ndescribe('AssignRole - Snapshot Tests', () => {\n  it('should match snapshot for structured output', async () => {\n    const input: AssignRoleInput = {\n      // TODO: Fill in test input\n    } as AssignRoleInput;\n    \n    const result = await AssignRole(input);\n    \n    // Snapshot test for structured output\n    expect(result).toMatchSnapshot();\n  });\n});"
  },
  {
    "path": "./__snapshots__/CheckPermission.snapshot.ts",
    "content": "import { describe, it, expect } from 'vitest';\nimport { CheckPermission } from '../src/CheckPermission';\nimport type { CheckPermissionInput } from '../src/types';\n\ndescribe('CheckPermission - Snapshot Tests', () => {\n  it('should match snapshot for structured output', async () => {\n    const input: CheckPermissionInput = {\n      // TODO: Fill in test input\n    } as CheckPermissionInput;\n    \n    const result = await CheckPermission(input);\n    \n    // Snapshot test for structured output\n    expect(result).toMatchSnapshot();\n  });\n});"
  },
  {
    "path": "./__snapshots__/Login.snapshot.ts",
    "content": "import { describe, it, expect } from 'vitest';\nimport { Login } from '../src/Login';\nimport type { LoginInput } from '../src/types';\n\ndescribe('Login - Snapshot Tests', () => {\n  it('should match snapshot for structured output', async () => {\n    const input: LoginInput = {\n      // TODO: Fill in test input\n    } as LoginInput;\n    \n    const result = await Login(input);\n    \n    // Snapshot test for structured output\n    expect(result).toMatchSnapshot();\n  });\n});"
  },
  {
    "path": "./__snapshots__/Register.snapshot.ts",
    "content": "import { describe, it, expect } from 'vitest';\nimport { Register } from '../src/Register';\nimport type { RegisterInput } from '../src/types';\n\ndescribe('Register - Snapshot Tests', () => {\n  it('should match snapshot for structured output', async () => {\n    const input: RegisterInput = {\n      // TODO: Fill in test input\n    } as RegisterInput;\n    \n    const result = await Register(input);\n    \n    // Snapshot test for structured output\n    expect(result).toMatchSnapshot();\n  });\n});"
  },
  {
    "path": "./AssignRole.test.ts",
    "content": "import { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { AssignRole } from '../src/AssignRole';\nimport type { AssignRoleInput, AssignRoleResult } from '../src/types';\nimport { createValidInputForAssignRole, createInvalidInputForAssignRole } from './helpers/test-utils';\nimport { User, Session, Permission } from './helpers/fixtures';\n\n/**\n * Tests for AssignRole behavior\n * Domain: AuthRoles\n * Detected strategy: auth\n * Assign a role to a user (admin only)\n */\ndescribe('AssignRole', () => {\n  // Test setup\n  let validInput: AssignRoleInput;\n  \n  beforeEach(() => {\n    validInput = createValidInputForAssignRole();\n  });\n\n  afterEach(() => {\n    // Cleanup if needed\n  });\n\ndescribe('Preconditions', () => {\n\n    it('User should not already exist', async () => {\n      // Verify user doesn't already exist for registration\n      const existingUser = await User.findByEmail(input.email);\n      expect(existingUser).toBeNull();\n    });\n  \n\n    it('User should not already exist', async () => {\n      // Verify user doesn't already exist for registration\n      const existingUser = await User.findByEmail(input.email);\n      expect(existingUser).toBeNull();\n    });\n  \n\n    it('Precondition: (User.lookup(actor_id).role in /* unsupported: ListExpr */)', async () => {\n      expect((User.lookup(actor_id).role in /* unsupported: ListExpr */)).toBe(true);\n    });\n  \n\n  });\n\ndescribe('Postconditions', () => {\n\n    it('Postcondition (success): (User.lookup(target_user_id).role === input.new...', async () => {\n      expect((User.lookup(target_user_id).role === input.new_role)).toBe(true);\n    });\n  \n\n  });\n\ndescribe('Error Cases', () => {\n\n    it('Should return FORBIDDEN when Actor does not have permission to assign roles', async () => {\n      const result = await AssignRole(inputForFORBIDDEN());\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('FORBIDDEN');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n    it('Should return USER_NOT_FOUND when Target user does not exist', async () => {\n      const result = await AssignRole(inputForUSER_NOT_FOUND());\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('USER_NOT_FOUND');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n    it('Should return CANNOT_SELF_PROMOTE when User cannot change their own role to a higher level', async () => {\n      const result = await AssignRole(inputForCANNOT_SELF_PROMOTE());\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('CANNOT_SELF_PROMOTE');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n    it('Should return ESCALATION_BLOCKED when Cannot assign role higher than actor\\'s own role', async () => {\n      const result = await AssignRole(inputForESCALATION_BLOCKED());\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('ESCALATION_BLOCKED');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n  });\n\ndescribe('Invariants', () => {\n\n    it('should maintain invariant 1', async () => {\n      const result = await AssignRole(validInput);\n      // Invariant: verify sensitive data handling\n      // This is typically verified through code review or security testing\n      expect(result).toBeDefined();\n    });\n    \n  });\n\n  // No scenarios defined\n\n  // Property-based tests: Install @isl-lang/isl-pbt to enable\n  // describe('Property-Based Tests', () => {\n  //   it('should satisfy all preconditions and postconditions', async () => {\n  //     const { runPBT } = await import('@isl-lang/isl-pbt');\n  //     const report = await runPBT(domain, 'AssignRole', implementation, {\n  //       numTests: 100,\n  //       seed: 12345,\n  //     });\n  //     expect(report.success).toBe(true);\n  //   });\n  // });\n});"
  },
  {
    "path": "./CheckPermission.test.ts",
    "content": "import { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { CheckPermission } from '../src/CheckPermission';\nimport type { CheckPermissionInput, CheckPermissionResult } from '../src/types';\nimport { createValidInputForCheckPermission, createInvalidInputForCheckPermission } from './helpers/test-utils';\nimport { User, Session, Permission } from './helpers/fixtures';\n\n/**\n * Tests for CheckPermission behavior\n * Domain: AuthRoles\n * Detected strategy: auth\n * Check if a user has permission for a resource action\n */\ndescribe('CheckPermission', () => {\n  // Test setup\n  let validInput: CheckPermissionInput;\n  \n  beforeEach(() => {\n    validInput = createValidInputForCheckPermission();\n  });\n\n  afterEach(() => {\n    // Cleanup if needed\n  });\n\ndescribe('Preconditions', () => {\n\n    it('User should not already exist', async () => {\n      // Verify user doesn't already exist for registration\n      const existingUser = await User.findByEmail(input.email);\n      expect(existingUser).toBeNull();\n    });\n  \n\n  });\n\ndescribe('Postconditions', () => {\n\n    it('Postcondition (success): ((User.lookup(user_id).role === SUPER_ADMIN) ||...', async () => {\n      expect(((User.lookup(user_id).role === SUPER_ADMIN) || ((result.allowed === (true - result.allowed)) === Permission.exists_for(User.lookup(user_id).role, input.resource, input.action)))).toBe(true);\n    });\n  \n\n  });\n\ndescribe('Error Cases', () => {\n\n    it('Should return USER_NOT_FOUND when User does not exist', async () => {\n      const result = await CheckPermission(inputForUSER_NOT_FOUND());\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('USER_NOT_FOUND');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n  });\n\n  // No invariants defined\n\n  // No scenarios defined\n\n  // Property-based tests: Install @isl-lang/isl-pbt to enable\n  // describe('Property-Based Tests', () => {\n  //   it('should satisfy all preconditions and postconditions', async () => {\n  //     const { runPBT } = await import('@isl-lang/isl-pbt');\n  //     const report = await runPBT(domain, 'CheckPermission', implementation, {\n  //       numTests: 100,\n  //       seed: 12345,\n  //     });\n  //     expect(report.success).toBe(true);\n  //   });\n  // });\n});"
  },
  {
    "path": "./helpers/fixtures.ts",
    "content": "// Test fixtures for AuthRoles\n// Auto-generated by @isl-lang/test-generator\n\n\nexport const userFixture = {\n  id: '00000000-0000-0000-0000-000000000001',\n  email: 'test-value',\n  password_hash: 'test-value',\n  role: createRole(),\n  status: createAccountStatus(),\n  failed_login_count: 1,\n  last_login_at: undefined,\n  created_at: new Date(),\n};\n\nexport function createUser(overrides?: Partial<typeof userFixture>) {\n  return { ...userFixture, ...overrides };\n}\n\nexport const User = {\n  findById: async (id: string) => createUser({ id }),\n  findByEmail: async (email: string) => createUser({ email } as Partial<typeof userFixture>),\n  exists: async (criteria: Record<string, unknown>) => true,\n  count: async (criteria?: Record<string, unknown>) => 1,\n};\n\n\nexport const sessionFixture = {\n  id: '00000000-0000-0000-0000-000000000001',\n  user_id: '00000000-0000-0000-0000-000000000001',\n  token: 'test-value',\n  expires_at: new Date(),\n  revoked: true,\n  created_at: new Date(),\n};\n\nexport function createSession(overrides?: Partial<typeof sessionFixture>) {\n  return { ...sessionFixture, ...overrides };\n}\n\nexport const Session = {\n  findById: async (id: string) => createSession({ id }),\n  findByEmail: async (email: string) => createSession({ email } as Partial<typeof sessionFixture>),\n  exists: async (criteria: Record<string, unknown>) => true,\n  count: async (criteria?: Record<string, unknown>) => 1,\n};\n\n\nexport const permissionFixture = {\n  id: '00000000-0000-0000-0000-000000000001',\n  role: createRole(),\n  resource: 'test-value',\n  action: 'test-value',\n};\n\nexport function createPermission(overrides?: Partial<typeof permissionFixture>) {\n  return { ...permissionFixture, ...overrides };\n}\n\nexport const Permission = {\n  findById: async (id: string) => createPermission({ id }),\n  findByEmail: async (email: string) => createPermission({ email } as Partial<typeof permissionFixture>),\n  exists: async (criteria: Record<string, unknown>) => true,\n  count: async (criteria?: Record<string, unknown>) => 1,\n};"
  },
  {
    "path": "./helpers/test-utils.ts",
    "content": "// Test utilities for AuthRoles\n// Auto-generated by @isl-lang/test-generator\n\nimport type { RegisterInput } from '../src/types';\nimport type { LoginInput } from '../src/types';\nimport type { AssignRoleInput } from '../src/types';\nimport type { CheckPermissionInput } from '../src/types';\nimport type { LogoutInput } from '../src/types';\n\n\nexport function createValidInputForRegister(): RegisterInput {\n  return {\n    email: 'test-value',\n    password: 'test-value',\n    confirm_password: 'test-value',\n  };\n}\n\nexport function createInvalidInputForRegister(): RegisterInput {\n  return {\n    email: '',\n    password: '',\n    confirm_password: '',\n  };\n}\n\n\nexport function createValidInputForLogin(): LoginInput {\n  return {\n    email: 'test-value',\n    password: 'test-value',\n  };\n}\n\nexport function createInvalidInputForLogin(): LoginInput {\n  return {\n    email: '',\n    password: '',\n  };\n}\n\n\nexport function createValidInputForAssignRole(): AssignRoleInput {\n  return {\n    actor_id: '00000000-0000-0000-0000-000000000001',\n    target_user_id: '00000000-0000-0000-0000-000000000001',\n    new_role: createRole(),\n  };\n}\n\nexport function createInvalidInputForAssignRole(): AssignRoleInput {\n  return {\n    actor_id: 'invalid-uuid',\n    target_user_id: 'invalid-uuid',\n    new_role: null as unknown,\n  };\n}\n\n\nexport function createValidInputForCheckPermission(): CheckPermissionInput {\n  return {\n    user_id: '00000000-0000-0000-0000-000000000001',\n    resource: 'test-value',\n    action: 'test-value',\n  };\n}\n\nexport function createInvalidInputForCheckPermission(): CheckPermissionInput {\n  return {\n    user_id: 'invalid-uuid',\n    resource: '',\n    action: '',\n  };\n}\n\n\nexport function createValidInputForLogout(): LogoutInput {\n  return {\n    session_id: '00000000-0000-0000-0000-000000000001',\n  };\n}\n\nexport function createInvalidInputForLogout(): LogoutInput {\n  return {\n    session_id: 'invalid-uuid',\n  };\n}\n\n\nexport function createInputViolating(condition: string): unknown {\n  // Override this based on the condition being violated\n  return {};\n}\n\nexport function captureState(): Record<string, unknown> {\n  return {\n    timestamp: Date.now(),\n  };\n}"
  },
  {
    "path": "./Login.test.ts",
    "content": "import { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { Login } from '../src/Login';\nimport type { LoginInput, LoginResult } from '../src/types';\nimport { createValidInputForLogin, createInvalidInputForLogin } from './helpers/test-utils';\nimport { User, Session, Permission } from './helpers/fixtures';\n\n/**\n * Tests for Login behavior\n * Domain: AuthRoles\n * Detected strategy: auth\n * Authenticate and create a session\n */\ndescribe('Login', () => {\n  // Test setup\n  let validInput: LoginInput;\n  \n  beforeEach(() => {\n    validInput = createValidInputForLogin();\n  });\n\n  afterEach(() => {\n    // Cleanup if needed\n  });\n\ndescribe('Preconditions', () => {\n\n    it('Email must be provided and non-empty', async () => {\n      expect(input.email).toBeDefined();\n      expect(input.email.length).toBeGreaterThan(0);\n    });\n  \n\n    it('Should throw for invalid email format', async () => {\n      await expect(behavior(invalidEmailInput)).rejects.toMatchObject({ code: 'INVALID_EMAIL' });\n    });\n  \n\n    it('Password must be at least 1 characters', async () => {\n      expect(input.password.length).toBeGreaterThanOrEqual(1);\n    });\n  \n\n    it('Should reject weak passwords', async () => {\n      await expect(behavior({ ...validInput, password: 'short' })).rejects.toMatchObject({ code: 'WEAK_PASSWORD' });\n    });\n  \n\n  });\n\ndescribe('Postconditions', () => {\n\n    it('Session should be created and active', async () => {\n      expect(result.session).toBeDefined();\n      expect(result.session.id).toBeDefined();\n      expect(result.session.revoked).toBe(false);\n    });\n  \n\n    it('Session should not be expired', async () => {\n      expect(new Date(result.session.expires_at).getTime()).toBeGreaterThan(Date.now());\n    });\n  \n\n    it('Account should be locked after max failed attempts', async () => {\n      const user = await User.findByEmail(input.email);\n      if (user.failed_login_attempts >= 10) {\n        expect(result.success).toBe(false);\n        expect(result.error).toBe('ACCOUNT_LOCKED');\n      }\n    });\n  \n\n    it('Account should be locked after max failed attempts', async () => {\n      const user = await User.findByEmail(input.email);\n      if (user.failed_login_attempts >= 10) {\n        expect(result.success).toBe(false);\n        expect(result.error).toBe('ACCOUNT_LOCKED');\n      }\n    });\n  \n\n  });\n\ndescribe('Error Cases', () => {\n\n    it('Should return INVALID_CREDENTIALS for wrong password', async () => {\n      const wrongPasswordInput = { ...validInput, password: 'wrong_password' };\n      const result = await Login(wrongPasswordInput);\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('INVALID_CREDENTIALS');\n      expect(result.retriable).toBe(true);\n    });\n  \n\n    it('Should return ACCOUNT_LOCKED after max failed attempts', async () => {\n      // After 10 failed attempts\n      const result = await Login(validInput);\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('ACCOUNT_LOCKED');\n      expect(result.retriable).toBe(true);\n      expect(result.retryAfter).toBeDefined();\n    });\n  \n\n    it('Should return ACCOUNT_SUSPENDED when Account has been suspended by admin', async () => {\n      const result = await Login(inputForACCOUNT_SUSPENDED());\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('ACCOUNT_SUSPENDED');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n    it('Should return NOT_VERIFIED when Account email not yet verified', async () => {\n      const result = await Login(inputForNOT_VERIFIED());\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('NOT_VERIFIED');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n  });\n\ndescribe('Invariants', () => {\n\n    it('should maintain invariant 1', async () => {\n      const result = await Login(validInput);\n      // Invariant: verify sensitive data handling\n      // This is typically verified through code review or security testing\n      expect(result).toBeDefined();\n    });\n    \n  });\n\n  // No scenarios defined\n\n  // Property-based tests: Install @isl-lang/isl-pbt to enable\n  // describe('Property-Based Tests', () => {\n  //   it('should satisfy all preconditions and postconditions', async () => {\n  //     const { runPBT } = await import('@isl-lang/isl-pbt');\n  //     const report = await runPBT(domain, 'Login', implementation, {\n  //       numTests: 100,\n  //       seed: 12345,\n  //     });\n  //     expect(report.success).toBe(true);\n  //   });\n  // });\n});"
  },
  {
    "path": "./Logout.test.ts",
    "content": "import { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { Logout } from '../src/Logout';\nimport type { LogoutInput, LogoutResult } from '../src/types';\nimport { createValidInputForLogout, createInvalidInputForLogout } from './helpers/test-utils';\nimport { User, Session, Permission } from './helpers/fixtures';\n\n/**\n * Tests for Logout behavior\n * Domain: AuthRoles\n * Detected strategy: auth\n * Revoke a session\n */\ndescribe('Logout', () => {\n  // Test setup\n  let validInput: LogoutInput;\n  \n  beforeEach(() => {\n    validInput = createValidInputForLogout();\n  });\n\n  afterEach(() => {\n    // Cleanup if needed\n  });\n\ndescribe('Preconditions', () => {\n\n    it('Precondition: Session.exists(session_id)', async () => {\n      expect(Session.exists(session_id)).toBe(true);\n    });\n  \n\n  });\n\ndescribe('Postconditions', () => {\n\n    it('Session should be created and active', async () => {\n      expect(result.session).toBeDefined();\n      expect(result.session.id).toBeDefined();\n      expect(result.session.revoked).toBe(false);\n    });\n  \n\n    it('Session should not be expired', async () => {\n      expect(new Date(result.session.expires_at).getTime()).toBeGreaterThan(Date.now());\n    });\n  \n\n  });\n\ndescribe('Error Cases', () => {\n\n    it('Should return SESSION_NOT_FOUND for non-existent session', async () => {\n      const nonExistentSession = { session_id: '00000000-0000-0000-0000-000000000000' };\n      const result = await Logout(nonExistentSession);\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('SESSION_NOT_FOUND');\n    });\n  \n\n  });\n\n  // No invariants defined\n\n  // No scenarios defined\n\n  // Property-based tests: Install @isl-lang/isl-pbt to enable\n  // describe('Property-Based Tests', () => {\n  //   it('should satisfy all preconditions and postconditions', async () => {\n  //     const { runPBT } = await import('@isl-lang/isl-pbt');\n  //     const report = await runPBT(domain, 'Logout', implementation, {\n  //       numTests: 100,\n  //       seed: 12345,\n  //     });\n  //     expect(report.success).toBe(true);\n  //   });\n  // });\n});"
  },
  {
    "path": "./Register.test.ts",
    "content": "import { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { Register } from '../src/Register';\nimport type { RegisterInput, RegisterResult } from '../src/types';\nimport { createValidInputForRegister, createInvalidInputForRegister } from './helpers/test-utils';\nimport { User, Session, Permission } from './helpers/fixtures';\n\n/**\n * Tests for Register behavior\n * Domain: AuthRoles\n * Detected strategy: auth\n * Register a new user account\n */\ndescribe('Register', () => {\n  // Test setup\n  let validInput: RegisterInput;\n  \n  beforeEach(() => {\n    validInput = createValidInputForRegister();\n  });\n\n  afterEach(() => {\n    // Cleanup if needed\n  });\n\ndescribe('Preconditions', () => {\n\n    it('Email must be provided and non-empty', async () => {\n      expect(input.email).toBeDefined();\n      expect(input.email.length).toBeGreaterThan(0);\n    });\n  \n\n    it('Should throw for invalid email format', async () => {\n      await expect(behavior(invalidEmailInput)).rejects.toMatchObject({ code: 'INVALID_EMAIL' });\n    });\n  \n\n    it('Password must be at least 12 characters', async () => {\n      expect(input.password.length).toBeGreaterThanOrEqual(12);\n    });\n  \n\n    it('Should reject weak passwords', async () => {\n      await expect(behavior({ ...validInput, password: 'short' })).rejects.toMatchObject({ code: 'WEAK_PASSWORD' });\n    });\n  \n\n    it('Precondition: (password === confirm_password)', async () => {\n      expect((password === confirm_password)).toBe(true);\n    });\n  \n\n    it('User should not already exist', async () => {\n      // Verify user doesn't already exist for registration\n      const existingUser = await User.findByEmail(input.email);\n      expect(existingUser).toBeNull();\n    });\n  \n\n  });\n\ndescribe('Postconditions', () => {\n\n    it('User status should be updated', async () => {\n      const updatedUser = await User.findById(result.id);\n      expect(updatedUser.status).toBe('ACTIVE');\n    });\n  \n\n  });\n\ndescribe('Error Cases', () => {\n\n    it('Should return EMAIL_TAKEN when A user with this email already exists', async () => {\n      const result = await Register(inputForEMAIL_TAKEN());\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('EMAIL_TAKEN');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n    it('Should return PASSWORDS_MISMATCH when Password and confirmation do not match', async () => {\n      const result = await Register(inputForPASSWORDS_MISMATCH());\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('PASSWORDS_MISMATCH');\n      expect(result.retriable).toBe(true);\n    });\n  \n\n    it('Should return WEAK_PASSWORD for insufficient password', async () => {\n      const weakPasswordInput = { ...validInput, password: '123' };\n      const result = await Register(weakPasswordInput);\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('WEAK_PASSWORD');\n      expect(result.retriable).toBe(true);\n    });\n  \n\n  });\n\ndescribe('Invariants', () => {\n\n    it('should maintain invariant 1', async () => {\n      const result = await Register(validInput);\n      // Invariant: verify sensitive data handling\n      // This is typically verified through code review or security testing\n      expect(result).toBeDefined();\n    });\n    \n  });\n\n  // No scenarios defined\n\n  // Property-based tests: Install @isl-lang/isl-pbt to enable\n  // describe('Property-Based Tests', () => {\n  //   it('should satisfy all preconditions and postconditions', async () => {\n  //     const { runPBT } = await import('@isl-lang/isl-pbt');\n  //     const report = await runPBT(domain, 'Register', implementation, {\n  //       numTests: 100,\n  //       seed: 12345,\n  //     });\n  //     expect(report.success).toBe(true);\n  //   });\n  // });\n});"
  },
  {
    "path": "./vitest.config.ts",
    "content": "import { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    include: ['**/*.test.ts'],\n  },\n});"
  }
]