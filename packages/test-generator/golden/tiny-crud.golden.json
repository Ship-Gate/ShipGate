[
  {
    "path": "./__snapshots__/CreateTodo.snapshot.ts",
    "content": "import { describe, it, expect } from 'vitest';\nimport { CreateTodo } from '../src/CreateTodo';\nimport type { CreateTodoInput } from '../src/types';\n\ndescribe('CreateTodo - Snapshot Tests', () => {\n  it('should match snapshot for structured output', async () => {\n    const input: CreateTodoInput = {\n      // TODO: Fill in test input\n    } as CreateTodoInput;\n    \n    const result = await CreateTodo(input);\n    \n    // Snapshot test for structured output\n    expect(result).toMatchSnapshot();\n  });\n});"
  },
  {
    "path": "./__snapshots__/GetTodo.snapshot.ts",
    "content": "import { describe, it, expect } from 'vitest';\nimport { GetTodo } from '../src/GetTodo';\nimport type { GetTodoInput } from '../src/types';\n\ndescribe('GetTodo - Snapshot Tests', () => {\n  it('should match snapshot for structured output', async () => {\n    const input: GetTodoInput = {\n      // TODO: Fill in test input\n    } as GetTodoInput;\n    \n    const result = await GetTodo(input);\n    \n    // Snapshot test for structured output\n    expect(result).toMatchSnapshot();\n  });\n});"
  },
  {
    "path": "./__snapshots__/ListTodos.snapshot.ts",
    "content": "import { describe, it, expect } from 'vitest';\nimport { ListTodos } from '../src/ListTodos';\nimport type { ListTodosInput } from '../src/types';\n\ndescribe('ListTodos - Snapshot Tests', () => {\n  it('should match snapshot for structured output', async () => {\n    const input: ListTodosInput = {\n      // TODO: Fill in test input\n    } as ListTodosInput;\n    \n    const result = await ListTodos(input);\n    \n    // Snapshot test for structured output\n    expect(result).toMatchSnapshot();\n  });\n});"
  },
  {
    "path": "./__snapshots__/UpdateTodo.snapshot.ts",
    "content": "import { describe, it, expect } from 'vitest';\nimport { UpdateTodo } from '../src/UpdateTodo';\nimport type { UpdateTodoInput } from '../src/types';\n\ndescribe('UpdateTodo - Snapshot Tests', () => {\n  it('should match snapshot for structured output', async () => {\n    const input: UpdateTodoInput = {\n      // TODO: Fill in test input\n    } as UpdateTodoInput;\n    \n    const result = await UpdateTodo(input);\n    \n    // Snapshot test for structured output\n    expect(result).toMatchSnapshot();\n  });\n});"
  },
  {
    "path": "./CreateTodo.test.ts",
    "content": "import { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { CreateTodo } from '../src/CreateTodo';\nimport type { CreateTodoInput, CreateTodoResult } from '../src/types';\nimport { createValidInputForCreateTodo, createInvalidInputForCreateTodo } from './helpers/test-utils';\nimport { Todo } from './helpers/fixtures';\n\n/**\n * Tests for CreateTodo behavior\n * Domain: TinyCrud\n * Detected strategy: generic\n * Create a new todo item\n */\ndescribe('CreateTodo', () => {\n  // Test setup\n  let validInput: CreateTodoInput;\n  \n  beforeEach(() => {\n    validInput = createValidInputForCreateTodo();\n  });\n\n  afterEach(() => {\n    // Cleanup if needed\n  });\n\ndescribe('Preconditions', () => {\n\n    it('Precondition: (title.trim().length >= 1)', async () => {\n      // Precondition check\n      expect((title.trim().length >= 1)).toBe(true);\n    });\n  \n\n    it('Should reject when (title.trim().length >= 1) is false', async () => {\n      // Should fail when precondition is violated\n      const invalidInput = createInputViolating('(title.trim().length >= 1)');\n      const result = await CreateTodo(invalidInput);\n      expect(result.success).toBe(false);\n    });\n  \n\n    it('Precondition: (title.length <= 255)', async () => {\n      // Precondition check\n      expect((title.length <= 255)).toBe(true);\n    });\n  \n\n    it('Should reject when (title.length <= 255) is false', async () => {\n      // Should fail when precondition is violated\n      const invalidInput = createInputViolating('(title.length <= 255)');\n      const result = await CreateTodo(invalidInput);\n      expect(result.success).toBe(false);\n    });\n  \n\n  });\n\ndescribe('Postconditions', () => {\n\n    it('Postcondition (success): ((((Todo.exists(result.id) - result.title) === ...', async () => {\n      // Postcondition (success)\n      expect(((((Todo.exists(result.id) - result.title) === (input.title.trim() - result.status)) === (OPEN - result.created_at)) === now()())).toBe(true);\n    });\n  \n\n  });\n\ndescribe('Error Cases', () => {\n\n    it('Should return TITLE_EMPTY when Title is blank or whitespace-only', async () => {\n      // Error case: TITLE_EMPTY\n      const errorInput = createInputForTITLEEMPTY();\n      const result = await CreateTodo(errorInput);\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('TITLE_EMPTY');\n      expect(result.retriable).toBe(true);\n    });\n  \n\n    it('Should return TITLE_TOO_LONG when Title exceeds 255 characters', async () => {\n      // Error case: TITLE_TOO_LONG\n      const errorInput = createInputForTITLETOOLONG();\n      const result = await CreateTodo(errorInput);\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('TITLE_TOO_LONG');\n      expect(result.retriable).toBe(true);\n    });\n  \n\n  });\n\n  // No invariants defined\n\n  // No scenarios defined\n\n  // Property-based tests: Install @isl-lang/isl-pbt to enable\n  // describe('Property-Based Tests', () => {\n  //   it('should satisfy all preconditions and postconditions', async () => {\n  //     const { runPBT } = await import('@isl-lang/isl-pbt');\n  //     const report = await runPBT(domain, 'CreateTodo', implementation, {\n  //       numTests: 100,\n  //       seed: 12345,\n  //     });\n  //     expect(report.success).toBe(true);\n  //   });\n  // });\n});"
  },
  {
    "path": "./DeleteTodo.test.ts",
    "content": "import { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { DeleteTodo } from '../src/DeleteTodo';\nimport type { DeleteTodoInput, DeleteTodoResult } from '../src/types';\nimport { createValidInputForDeleteTodo, createInvalidInputForDeleteTodo } from './helpers/test-utils';\nimport { Todo } from './helpers/fixtures';\n\n/**\n * Tests for DeleteTodo behavior\n * Domain: TinyCrud\n * Detected strategy: generic\n * Permanently delete a todo\n */\ndescribe('DeleteTodo', () => {\n  // Test setup\n  let validInput: DeleteTodoInput;\n  \n  beforeEach(() => {\n    validInput = createValidInputForDeleteTodo();\n  });\n\n  afterEach(() => {\n    // Cleanup if needed\n  });\n\ndescribe('Preconditions', () => {\n\n    it('Precondition: Todo.exists(id)', async () => {\n      // Precondition check\n      expect(Todo.exists(id)).toBe(true);\n    });\n  \n\n    it('Should reject when Todo.exists(id) is false', async () => {\n      // Should fail when precondition is violated\n      const invalidInput = createInputViolating('Todo.exists(id)');\n      const result = await DeleteTodo(invalidInput);\n      expect(result.success).toBe(false);\n    });\n  \n\n  });\n\ndescribe('Postconditions', () => {\n\n    it('Postcondition (success): !(Todo.exists(input.id))', async () => {\n      // Postcondition (success)\n      expect(!(Todo.exists(input.id))).toBe(true);\n    });\n  \n\n  });\n\ndescribe('Error Cases', () => {\n\n    it('Should return NOT_FOUND when No todo with this ID exists', async () => {\n      // Error case: NOT_FOUND\n      const errorInput = createInputForNOTFOUND();\n      const result = await DeleteTodo(errorInput);\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('NOT_FOUND');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n  });\n\n  // No invariants defined\n\n  // No scenarios defined\n\n  // Property-based tests: Install @isl-lang/isl-pbt to enable\n  // describe('Property-Based Tests', () => {\n  //   it('should satisfy all preconditions and postconditions', async () => {\n  //     const { runPBT } = await import('@isl-lang/isl-pbt');\n  //     const report = await runPBT(domain, 'DeleteTodo', implementation, {\n  //       numTests: 100,\n  //       seed: 12345,\n  //     });\n  //     expect(report.success).toBe(true);\n  //   });\n  // });\n});"
  },
  {
    "path": "./GetTodo.test.ts",
    "content": "import { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { GetTodo } from '../src/GetTodo';\nimport type { GetTodoInput, GetTodoResult } from '../src/types';\nimport { createValidInputForGetTodo, createInvalidInputForGetTodo } from './helpers/test-utils';\nimport { Todo } from './helpers/fixtures';\n\n/**\n * Tests for GetTodo behavior\n * Domain: TinyCrud\n * Detected strategy: generic\n * Retrieve a todo by ID\n */\ndescribe('GetTodo', () => {\n  // Test setup\n  let validInput: GetTodoInput;\n  \n  beforeEach(() => {\n    validInput = createValidInputForGetTodo();\n  });\n\n  afterEach(() => {\n    // Cleanup if needed\n  });\n\ndescribe('Preconditions', () => {\n\n    it('Precondition: id.is_valid', async () => {\n      // Precondition check\n      expect(id.is_valid).toBe(true);\n    });\n  \n\n    it('Should reject when id.is_valid is false', async () => {\n      // Should fail when precondition is violated\n      const invalidInput = createInputViolating('id.is_valid');\n      const result = await GetTodo(invalidInput);\n      expect(result.success).toBe(false);\n    });\n  \n\n  });\n\ndescribe('Postconditions', () => {\n\n    it('Postcondition (success): (result.id === input.id)', async () => {\n      // Postcondition (success)\n      expect((result.id === input.id)).toBe(true);\n    });\n  \n\n  });\n\ndescribe('Error Cases', () => {\n\n    it('Should return NOT_FOUND when No todo with this ID exists', async () => {\n      // Error case: NOT_FOUND\n      const errorInput = createInputForNOTFOUND();\n      const result = await GetTodo(errorInput);\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('NOT_FOUND');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n  });\n\n  // No invariants defined\n\n  // No scenarios defined\n\n  // Property-based tests: Install @isl-lang/isl-pbt to enable\n  // describe('Property-Based Tests', () => {\n  //   it('should satisfy all preconditions and postconditions', async () => {\n  //     const { runPBT } = await import('@isl-lang/isl-pbt');\n  //     const report = await runPBT(domain, 'GetTodo', implementation, {\n  //       numTests: 100,\n  //       seed: 12345,\n  //     });\n  //     expect(report.success).toBe(true);\n  //   });\n  // });\n});"
  },
  {
    "path": "./helpers/fixtures.ts",
    "content": "// Test fixtures for TinyCrud\n// Auto-generated by @isl-lang/test-generator\n\n\nexport const todoFixture = {\n  id: '00000000-0000-0000-0000-000000000001',\n  title: {},\n  status: createTodoStatus(),\n  created_at: new Date(),\n  updated_at: new Date(),\n};\n\nexport function createTodo(overrides?: Partial<typeof todoFixture>) {\n  return { ...todoFixture, ...overrides };\n}\n\nexport const Todo = {\n  findById: async (id: string) => createTodo({ id }),\n  findByEmail: async (email: string) => createTodo({ email } as Partial<typeof todoFixture>),\n  exists: async (criteria: Record<string, unknown>) => true,\n  count: async (criteria?: Record<string, unknown>) => 1,\n};"
  },
  {
    "path": "./helpers/test-utils.ts",
    "content": "// Test utilities for TinyCrud\n// Auto-generated by @isl-lang/test-generator\n\nimport type { CreateTodoInput } from '../src/types';\nimport type { GetTodoInput } from '../src/types';\nimport type { UpdateTodoInput } from '../src/types';\nimport type { DeleteTodoInput } from '../src/types';\nimport type { ListTodosInput } from '../src/types';\n\n\nexport function createValidInputForCreateTodo(): CreateTodoInput {\n  return {\n    title: 'test-value',\n  };\n}\n\nexport function createInvalidInputForCreateTodo(): CreateTodoInput {\n  return {\n    title: '',\n  };\n}\n\n\nexport function createValidInputForGetTodo(): GetTodoInput {\n  return {\n    id: '00000000-0000-0000-0000-000000000001',\n  };\n}\n\nexport function createInvalidInputForGetTodo(): GetTodoInput {\n  return {\n    id: 'invalid-uuid',\n  };\n}\n\n\nexport function createValidInputForUpdateTodo(): UpdateTodoInput {\n  return {\n    id: '00000000-0000-0000-0000-000000000001',\n    title: undefined,\n    status: undefined,\n  };\n}\n\nexport function createInvalidInputForUpdateTodo(): UpdateTodoInput {\n  return {\n    id: 'invalid-uuid',\n    title: null as unknown,\n    status: null as unknown,\n  };\n}\n\n\nexport function createValidInputForDeleteTodo(): DeleteTodoInput {\n  return {\n    id: '00000000-0000-0000-0000-000000000001',\n  };\n}\n\nexport function createInvalidInputForDeleteTodo(): DeleteTodoInput {\n  return {\n    id: 'invalid-uuid',\n  };\n}\n\n\nexport function createValidInputForListTodos(): ListTodosInput {\n  return {\n    status: undefined,\n    limit: 1,\n    offset: 1,\n  };\n}\n\nexport function createInvalidInputForListTodos(): ListTodosInput {\n  return {\n    status: null as unknown,\n    limit: -1,\n    offset: -1,\n  };\n}\n\n\nexport function createInputViolating(condition: string): unknown {\n  // Override this based on the condition being violated\n  return {};\n}\n\nexport function captureState(): Record<string, unknown> {\n  return {\n    timestamp: Date.now(),\n  };\n}"
  },
  {
    "path": "./ListTodos.test.ts",
    "content": "import { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { ListTodos } from '../src/ListTodos';\nimport type { ListTodosInput, ListTodosResult } from '../src/types';\nimport { createValidInputForListTodos, createInvalidInputForListTodos } from './helpers/test-utils';\nimport { Todo } from './helpers/fixtures';\n\n/**\n * Tests for ListTodos behavior\n * Domain: TinyCrud\n * Detected strategy: generic\n * List todos with optional status filter\n */\ndescribe('ListTodos', () => {\n  // Test setup\n  let validInput: ListTodosInput;\n  \n  beforeEach(() => {\n    validInput = createValidInputForListTodos();\n  });\n\n  afterEach(() => {\n    // Cleanup if needed\n  });\n\ndescribe('Preconditions', () => {\n\n    it('Precondition: (limit > 0)', async () => {\n      // Precondition check\n      expect((limit > 0)).toBe(true);\n    });\n  \n\n    it('Should reject when (limit > 0) is false', async () => {\n      // Should fail when precondition is violated\n      const invalidInput = createInputViolating('(limit > 0)');\n      const result = await ListTodos(invalidInput);\n      expect(result.success).toBe(false);\n    });\n  \n\n    it('Precondition: (limit <= 100)', async () => {\n      // Precondition check\n      expect((limit <= 100)).toBe(true);\n    });\n  \n\n    it('Should reject when (limit <= 100) is false', async () => {\n      // Should fail when precondition is violated\n      const invalidInput = createInputViolating('(limit <= 100)');\n      const result = await ListTodos(invalidInput);\n      expect(result.success).toBe(false);\n    });\n  \n\n    it('Precondition: (offset >= 0)', async () => {\n      // Precondition check\n      expect((offset >= 0)).toBe(true);\n    });\n  \n\n    it('Should reject when (offset >= 0) is false', async () => {\n      // Should fail when precondition is violated\n      const invalidInput = createInputViolating('(offset >= 0)');\n      const result = await ListTodos(invalidInput);\n      expect(result.success).toBe(false);\n    });\n  \n\n  });\n\ndescribe('Postconditions', () => {\n\n    it('Postcondition (success): (((result.items.length <= (input.limit - input....', async () => {\n      // Postcondition (success)\n      expect((((result.items.length <= (input.limit - input.status)) !== null) || /* unsupported: QuantifierExpr */)).toBe(true);\n    });\n  \n\n  });\n\n  // No error cases defined\n\n  // No invariants defined\n\n  // No scenarios defined\n\n  // Property-based tests: Install @isl-lang/isl-pbt to enable\n  // describe('Property-Based Tests', () => {\n  //   it('should satisfy all preconditions and postconditions', async () => {\n  //     const { runPBT } = await import('@isl-lang/isl-pbt');\n  //     const report = await runPBT(domain, 'ListTodos', implementation, {\n  //       numTests: 100,\n  //       seed: 12345,\n  //     });\n  //     expect(report.success).toBe(true);\n  //   });\n  // });\n});"
  },
  {
    "path": "./UpdateTodo.test.ts",
    "content": "import { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { UpdateTodo } from '../src/UpdateTodo';\nimport type { UpdateTodoInput, UpdateTodoResult } from '../src/types';\nimport { createValidInputForUpdateTodo, createInvalidInputForUpdateTodo } from './helpers/test-utils';\nimport { Todo } from './helpers/fixtures';\n\n/**\n * Tests for UpdateTodo behavior\n * Domain: TinyCrud\n * Detected strategy: generic\n * Update a todo title or status\n */\ndescribe('UpdateTodo', () => {\n  // Test setup\n  let validInput: UpdateTodoInput;\n  \n  beforeEach(() => {\n    validInput = createValidInputForUpdateTodo();\n  });\n\n  afterEach(() => {\n    // Cleanup if needed\n  });\n\ndescribe('Preconditions', () => {\n\n    it('Precondition: Todo.exists(id)', async () => {\n      // Precondition check\n      expect(Todo.exists(id)).toBe(true);\n    });\n  \n\n    it('Should reject when Todo.exists(id) is false', async () => {\n      // Should fail when precondition is violated\n      const invalidInput = createInputViolating('Todo.exists(id)');\n      const result = await UpdateTodo(invalidInput);\n      expect(result.success).toBe(false);\n    });\n  \n\n    it('Precondition: ((title === null) || (title.trim().length >= 1))', async () => {\n      // Precondition check\n      expect(((title === null) || (title.trim().length >= 1))).toBe(true);\n    });\n  \n\n    it('Should reject when ((title === null) || (title... is false', async () => {\n      // Should fail when precondition is violated\n      const invalidInput = createInputViolating('((title === null) || (title...');\n      const result = await UpdateTodo(invalidInput);\n      expect(result.success).toBe(false);\n    });\n  \n\n  });\n\ndescribe('Postconditions', () => {\n\n    it('Postcondition (success): ((((result.id === (input.id - input.title)) !==...', async () => {\n      // Postcondition (success)\n      expect(((((result.id === (input.id - input.title)) !== null) || ((result.title === (input.title.trim() - input.status)) !== null)) || (result.status === ((input.status - result.updated_at) >= /* unsupported: OldExpr */)))).toBe(true);\n    });\n  \n\n  });\n\ndescribe('Error Cases', () => {\n\n    it('Should return NOT_FOUND when No todo with this ID exists', async () => {\n      // Error case: NOT_FOUND\n      const errorInput = createInputForNOTFOUND();\n      const result = await UpdateTodo(errorInput);\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('NOT_FOUND');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n    it('Should return TITLE_EMPTY when Title is blank or whitespace-only', async () => {\n      // Error case: TITLE_EMPTY\n      const errorInput = createInputForTITLEEMPTY();\n      const result = await UpdateTodo(errorInput);\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('TITLE_EMPTY');\n      expect(result.retriable).toBe(true);\n    });\n  \n\n    it('Should return INVALID_TRANSITION when Cannot transition from ARCHIVED to OPEN', async () => {\n      // Error case: INVALID_TRANSITION\n      const errorInput = createInputForINVALIDTRANSITION();\n      const result = await UpdateTodo(errorInput);\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('INVALID_TRANSITION');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n  });\n\ndescribe('Invariants', () => {\n\n    it('should maintain invariant 1', async () => {\n      const result = await UpdateTodo(validInput);\n      // Invariant: verify sensitive data handling\n      // This is typically verified through code review or security testing\n      expect(result).toBeDefined();\n    });\n    \n  });\n\n  // No scenarios defined\n\n  // Property-based tests: Install @isl-lang/isl-pbt to enable\n  // describe('Property-Based Tests', () => {\n  //   it('should satisfy all preconditions and postconditions', async () => {\n  //     const { runPBT } = await import('@isl-lang/isl-pbt');\n  //     const report = await runPBT(domain, 'UpdateTodo', implementation, {\n  //       numTests: 100,\n  //       seed: 12345,\n  //     });\n  //     expect(report.success).toBe(true);\n  //   });\n  // });\n});"
  },
  {
    "path": "./vitest.config.ts",
    "content": "import { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    include: ['**/*.test.ts'],\n  },\n});"
  }
]