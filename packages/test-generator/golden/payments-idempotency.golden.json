[
  {
    "path": "./__snapshots__/GetBalance.snapshot.ts",
    "content": "import { describe, it, expect } from 'vitest';\nimport { GetBalance } from '../src/GetBalance';\nimport type { GetBalanceInput } from '../src/types';\n\ndescribe('GetBalance - Snapshot Tests', () => {\n  it('should match snapshot for structured output', async () => {\n    const input: GetBalanceInput = {\n      // TODO: Fill in test input\n    } as GetBalanceInput;\n    \n    const result = await GetBalance(input);\n    \n    // Snapshot test for structured output\n    expect(result).toMatchSnapshot();\n  });\n});"
  },
  {
    "path": "./__snapshots__/RefundTransaction.snapshot.ts",
    "content": "import { describe, it, expect } from 'vitest';\nimport { RefundTransaction } from '../src/RefundTransaction';\nimport type { RefundTransactionInput } from '../src/types';\n\ndescribe('RefundTransaction - Snapshot Tests', () => {\n  it('should match snapshot for structured output', async () => {\n    const input: RefundTransactionInput = {\n      // TODO: Fill in test input\n    } as RefundTransactionInput;\n    \n    const result = await RefundTransaction(input);\n    \n    // Snapshot test for structured output\n    expect(result).toMatchSnapshot();\n  });\n});"
  },
  {
    "path": "./__snapshots__/TransferFunds.snapshot.ts",
    "content": "import { describe, it, expect } from 'vitest';\nimport { TransferFunds } from '../src/TransferFunds';\nimport type { TransferFundsInput } from '../src/types';\n\ndescribe('TransferFunds - Snapshot Tests', () => {\n  it('should match snapshot for structured output', async () => {\n    const input: TransferFundsInput = {\n      // TODO: Fill in test input\n    } as TransferFundsInput;\n    \n    const result = await TransferFunds(input);\n    \n    // Snapshot test for structured output\n    expect(result).toMatchSnapshot();\n  });\n});"
  },
  {
    "path": "./GetBalance.test.ts",
    "content": "import { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { GetBalance } from '../src/GetBalance';\nimport type { GetBalanceInput, GetBalanceResult } from '../src/types';\nimport { createValidInputForGetBalance, createInvalidInputForGetBalance } from './helpers/test-utils';\nimport { Account, Transaction } from './helpers/fixtures';\n\n/**\n * Tests for GetBalance behavior\n * Domain: PaymentsIdempotency\n * Detected strategy: payments\n * Get current account balance\n */\ndescribe('GetBalance', () => {\n  // Test setup\n  let validInput: GetBalanceInput;\n  \n  beforeEach(() => {\n    validInput = createValidInputForGetBalance();\n  });\n\n  afterEach(() => {\n    // Cleanup if needed\n  });\n\ndescribe('Preconditions', () => {\n\n    it('Precondition: Account.exists(account_id)', async () => {\n      expect(Account.exists(account_id)).toBe(true);\n    });\n  \n\n  });\n\ndescribe('Postconditions', () => {\n\n    it('Postcondition (success): (result.balance === ((Account.lookup(account_id...', async () => {\n      expect((result.balance === ((Account.lookup(account_id).balance - result.balance) >= 0))).toBe(true);\n    });\n  \n\n  });\n\ndescribe('Error Cases', () => {\n\n    it('Should return ACCOUNT_NOT_FOUND when Account does not exist', async () => {\n      const result = await GetBalance(inputForACCOUNT_NOT_FOUND());\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('ACCOUNT_NOT_FOUND');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n  });\n\n  // No invariants defined\n\n  // No scenarios defined\n\n  // Property-based tests: Install @isl-lang/isl-pbt to enable\n  // describe('Property-Based Tests', () => {\n  //   it('should satisfy all preconditions and postconditions', async () => {\n  //     const { runPBT } = await import('@isl-lang/isl-pbt');\n  //     const report = await runPBT(domain, 'GetBalance', implementation, {\n  //       numTests: 100,\n  //       seed: 12345,\n  //     });\n  //     expect(report.success).toBe(true);\n  //   });\n  // });\n});"
  },
  {
    "path": "./helpers/fixtures.ts",
    "content": "// Test fixtures for PaymentsIdempotency\n// Auto-generated by @isl-lang/test-generator\n\n\nexport const accountFixture = {\n  id: '00000000-0000-0000-0000-000000000001',\n  owner_id: '00000000-0000-0000-0000-000000000001',\n  balance: 10.00,\n  currency: createCurrency(),\n  is_active: true,\n  created_at: new Date(),\n};\n\nexport function createAccount(overrides?: Partial<typeof accountFixture>) {\n  return { ...accountFixture, ...overrides };\n}\n\nexport const Account = {\n  findById: async (id: string) => createAccount({ id }),\n  findByEmail: async (email: string) => createAccount({ email } as Partial<typeof accountFixture>),\n  exists: async (criteria: Record<string, unknown>) => true,\n  count: async (criteria?: Record<string, unknown>) => 1,\n};\n\n\nexport const transactionFixture = {\n  id: '00000000-0000-0000-0000-000000000001',\n  idempotency_key: 'test-value',\n  from_account_id: '00000000-0000-0000-0000-000000000001',\n  to_account_id: '00000000-0000-0000-0000-000000000001',\n  amount: 10.00,\n  currency: createCurrency(),\n  status: createTransactionStatus(),\n  created_at: new Date(),\n  completed_at: undefined,\n};\n\nexport function createTransaction(overrides?: Partial<typeof transactionFixture>) {\n  return { ...transactionFixture, ...overrides };\n}\n\nexport const Transaction = {\n  findById: async (id: string) => createTransaction({ id }),\n  findByEmail: async (email: string) => createTransaction({ email } as Partial<typeof transactionFixture>),\n  exists: async (criteria: Record<string, unknown>) => true,\n  count: async (criteria?: Record<string, unknown>) => 1,\n};"
  },
  {
    "path": "./helpers/test-utils.ts",
    "content": "// Test utilities for PaymentsIdempotency\n// Auto-generated by @isl-lang/test-generator\n\nimport type { TransferFundsInput } from '../src/types';\nimport type { RefundTransactionInput } from '../src/types';\nimport type { GetBalanceInput } from '../src/types';\n\n\nexport function createValidInputForTransferFunds(): TransferFundsInput {\n  return {\n    idempotency_key: 'test-value',\n    from_account_id: '00000000-0000-0000-0000-000000000001',\n    to_account_id: '00000000-0000-0000-0000-000000000001',\n    amount: 10.00,\n    currency: createCurrency(),\n  };\n}\n\nexport function createInvalidInputForTransferFunds(): TransferFundsInput {\n  return {\n    idempotency_key: '',\n    from_account_id: 'invalid-uuid',\n    to_account_id: 'invalid-uuid',\n    amount: -1.00,\n    currency: null as unknown,\n  };\n}\n\n\nexport function createValidInputForRefundTransaction(): RefundTransactionInput {\n  return {\n    transaction_id: '00000000-0000-0000-0000-000000000001',\n    reason: 'test-value',\n  };\n}\n\nexport function createInvalidInputForRefundTransaction(): RefundTransactionInput {\n  return {\n    transaction_id: 'invalid-uuid',\n    reason: '',\n  };\n}\n\n\nexport function createValidInputForGetBalance(): GetBalanceInput {\n  return {\n    account_id: '00000000-0000-0000-0000-000000000001',\n  };\n}\n\nexport function createInvalidInputForGetBalance(): GetBalanceInput {\n  return {\n    account_id: 'invalid-uuid',\n  };\n}\n\n\nexport function createInputViolating(condition: string): unknown {\n  // Override this based on the condition being violated\n  return {};\n}\n\nexport function captureState(): Record<string, unknown> {\n  return {\n    timestamp: Date.now(),\n  };\n}"
  },
  {
    "path": "./RefundTransaction.test.ts",
    "content": "import { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { RefundTransaction } from '../src/RefundTransaction';\nimport type { RefundTransactionInput, RefundTransactionResult } from '../src/types';\nimport { createValidInputForRefundTransaction, createInvalidInputForRefundTransaction } from './helpers/test-utils';\nimport { Account, Transaction } from './helpers/fixtures';\n\n/**\n * Tests for RefundTransaction behavior\n * Domain: PaymentsIdempotency\n * Detected strategy: payments\n * Refund a completed transaction\n */\ndescribe('RefundTransaction', () => {\n  // Test setup\n  let validInput: RefundTransactionInput;\n  \n  beforeEach(() => {\n    validInput = createValidInputForRefundTransaction();\n  });\n\n  afterEach(() => {\n    // Cleanup if needed\n  });\n\ndescribe('Preconditions', () => {\n\n    it('Precondition: Transaction.exists(transaction_id)', async () => {\n      expect(Transaction.exists(transaction_id)).toBe(true);\n    });\n  \n\n    it('Precondition: (Transaction.lookup(transaction_id).status === COMPLETED)', async () => {\n      expect((Transaction.lookup(transaction_id).status === COMPLETED)).toBe(true);\n    });\n  \n\n  });\n\ndescribe('Postconditions', () => {\n\n    it('Refund status should be valid', async () => {\n      expect(['COMPLETED', 'PENDING']).toContain(result.status);\n    });\n  \n\n  });\n\ndescribe('Error Cases', () => {\n\n    it('Should return TRANSACTION_NOT_FOUND when Transaction does not exist', async () => {\n      const result = await RefundTransaction(inputForTRANSACTION_NOT_FOUND());\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('TRANSACTION_NOT_FOUND');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n    it('Should return ALREADY_REFUNDED when Transaction has already been refunded', async () => {\n      const result = await RefundTransaction(inputForALREADY_REFUNDED());\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('ALREADY_REFUNDED');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n    it('Should return NOT_COMPLETED when Only completed transactions can be refunded', async () => {\n      const result = await RefundTransaction(inputForNOT_COMPLETED());\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('NOT_COMPLETED');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n    it('Should return INSUFFICIENT_FUNDS when card has insufficient balance', async () => {\n      const insufficientFundsInput = { ...validInput, amount: 999999.99 };\n      const result = await RefundTransaction(insufficientFundsInput);\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('INSUFFICIENT_FUNDS');\n      expect(result.retriable).toBe(true);\n    });\n  \n\n  });\n\ndescribe('Invariants', () => {\n\n    it('should maintain invariant 1', async () => {\n      const result = await RefundTransaction(validInput);\n      // Invariant: verify sensitive data handling\n      // This is typically verified through code review or security testing\n      expect(result).toBeDefined();\n    });\n    \n  });\n\n  // No scenarios defined\n\n  // Property-based tests: Install @isl-lang/isl-pbt to enable\n  // describe('Property-Based Tests', () => {\n  //   it('should satisfy all preconditions and postconditions', async () => {\n  //     const { runPBT } = await import('@isl-lang/isl-pbt');\n  //     const report = await runPBT(domain, 'RefundTransaction', implementation, {\n  //       numTests: 100,\n  //       seed: 12345,\n  //     });\n  //     expect(report.success).toBe(true);\n  //   });\n  // });\n});"
  },
  {
    "path": "./TransferFunds.test.ts",
    "content": "import { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { TransferFunds } from '../src/TransferFunds';\nimport type { TransferFundsInput, TransferFundsResult } from '../src/types';\nimport { createValidInputForTransferFunds, createInvalidInputForTransferFunds } from './helpers/test-utils';\nimport { Account, Transaction } from './helpers/fixtures';\n\n/**\n * Tests for TransferFunds behavior\n * Domain: PaymentsIdempotency\n * Detected strategy: payments\n * Transfer funds between two accounts with idempotency\n */\ndescribe('TransferFunds', () => {\n  // Test setup\n  let validInput: TransferFundsInput;\n  \n  beforeEach(() => {\n    validInput = createValidInputForTransferFunds();\n  });\n\n  afterEach(() => {\n    // Cleanup if needed\n  });\n\ndescribe('Preconditions', () => {\n\n    it('Payment amount must be positive', async () => {\n      expect(input.amount).toBeGreaterThan(0);\n    });\n  \n\n    it('Should reject zero amount', async () => {\n      const zeroAmountInput = { ...validInput, amount: 0 };\n      const result = await TransferFunds(zeroAmountInput);\n      expect(result.success).toBe(false);\n    });\n  \n\n    it('Should reject negative amount', async () => {\n      const negativeAmountInput = { ...validInput, amount: -10 };\n      const result = await TransferFunds(negativeAmountInput);\n      expect(result.success).toBe(false);\n    });\n  \n\n    it('Precondition: (from_account_id !== to_account_id)', async () => {\n      expect((from_account_id !== to_account_id)).toBe(true);\n    });\n  \n\n    it('Precondition: Account.exists(from_account_id)', async () => {\n      expect(Account.exists(from_account_id)).toBe(true);\n    });\n  \n\n    it('Precondition: Account.exists(to_account_id)', async () => {\n      expect(Account.exists(to_account_id)).toBe(true);\n    });\n  \n\n    it('Precondition: Account.lookup(from_account_id).is_active', async () => {\n      expect(Account.lookup(from_account_id).is_active).toBe(true);\n    });\n  \n\n    it('Precondition: Account.lookup(to_account_id).is_active', async () => {\n      expect(Account.lookup(to_account_id).is_active).toBe(true);\n    });\n  \n\n    it('Precondition: (Account.lookup(from_account_id).currency === currency)', async () => {\n      expect((Account.lookup(from_account_id).currency === currency)).toBe(true);\n    });\n  \n\n    it('Precondition: (Account.lookup(to_account_id).currency === currency)', async () => {\n      expect((Account.lookup(to_account_id).currency === currency)).toBe(true);\n    });\n  \n\n    it('Precondition: (Account.lookup(from_account_id).balance >= amount)', async () => {\n      expect((Account.lookup(from_account_id).balance >= amount)).toBe(true);\n    });\n  \n\n  });\n\ndescribe('Postconditions', () => {\n\n    it('Payment status should be COMPLETED or PROCESSING', async () => {\n      expect(['COMPLETED', 'PROCESSING']).toContain(result.status);\n    });\n  \n\n    it('Idempotency key should be preserved', async () => {\n      expect(result.idempotency_key).toEqual(input.idempotency_key);\n    });\n  \n\n    it.skip('NEEDS_IMPL: Retry with same idempotency key should return same result', async () => {\n      // Implementation hint: Implement idempotency verification in integration tests\n      // SCAFFOLD: Verify idempotent behavior on retry\n      const retryResult = await TransferFunds(input);\n      expect(retryResult.id).toEqual(result.id);\n    });\n  \n  });\n\ndescribe('Error Cases', () => {\n\n    it('Should return DUPLICATE_REQUEST when Idempotency key already used â€” returns original result', async () => {\n      const result = await TransferFunds(inputForDUPLICATE_REQUEST());\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('DUPLICATE_REQUEST');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n    it('Should return INSUFFICIENT_FUNDS when card has insufficient balance', async () => {\n      const insufficientFundsInput = { ...validInput, amount: 999999.99 };\n      const result = await TransferFunds(insufficientFundsInput);\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('INSUFFICIENT_FUNDS');\n      expect(result.retriable).toBe(true);\n    });\n  \n\n    it('Should return ACCOUNT_NOT_FOUND when Sender or receiver account does not exist', async () => {\n      const result = await TransferFunds(inputForACCOUNT_NOT_FOUND());\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('ACCOUNT_NOT_FOUND');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n    it('Should return ACCOUNT_INACTIVE when One of the accounts is deactivated', async () => {\n      const result = await TransferFunds(inputForACCOUNT_INACTIVE());\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('ACCOUNT_INACTIVE');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n    it('Should return CURRENCY_MISMATCH when Account currencies do not match transaction currency', async () => {\n      const result = await TransferFunds(inputForCURRENCY_MISMATCH());\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('CURRENCY_MISMATCH');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n    it('Should return SELF_TRANSFER when Cannot transfer to the same account', async () => {\n      const result = await TransferFunds(inputForSELF_TRANSFER());\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('SELF_TRANSFER');\n      expect(result.retriable).toBe(false);\n    });\n  \n\n  });\n\ndescribe('Invariants', () => {\n\n    it('should maintain invariant 1', async () => {\n      const result = await TransferFunds(validInput);\n      // Invariant: verify sensitive data handling\n      // This is typically verified through code review or security testing\n      expect(result).toBeDefined();\n    });\n    \n  });\n\n  // No scenarios defined\n\n  // Property-based tests: Install @isl-lang/isl-pbt to enable\n  // describe('Property-Based Tests', () => {\n  //   it('should satisfy all preconditions and postconditions', async () => {\n  //     const { runPBT } = await import('@isl-lang/isl-pbt');\n  //     const report = await runPBT(domain, 'TransferFunds', implementation, {\n  //       numTests: 100,\n  //       seed: 12345,\n  //     });\n  //     expect(report.success).toBe(true);\n  //   });\n  // });\n});"
  },
  {
    "path": "./vitest.config.ts",
    "content": "import { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    include: ['**/*.test.ts'],\n  },\n});"
  }
]