// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Auth-Login Snapshot > generates correct test structure > auth-login-test 1`] = `
"import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { Login } from '../src/Login';
import type { LoginInput, LoginResult } from '../src/types';
import { createValidInputForLogin, createInvalidInputForLogin } from './helpers/test-utils';
import { User, Session } from './helpers/fixtures';

/**
 * Tests for Login behavior
 * Domain: Auth
 * Detected strategy: auth
 * Authenticate user
 */
describe('Login', () => {
  // Test setup
  let validInput: LoginInput;
  
  beforeEach(() => {
    validInput = createValidInputForLogin();
  });

  afterEach(() => {
    // Cleanup if needed
  });

describe('Preconditions', () => {

    it('Email must be provided and non-empty', async () => {
      expect(input.email).toBeDefined();
      expect(input.email.length).toBeGreaterThan(0);
    });
  

    it('Should throw for invalid email format', async () => {
      await expect(behavior(invalidEmailInput)).rejects.toMatchObject({ code: 'INVALID_EMAIL' });
    });
  

    it('Password must be at least 8 characters', async () => {
      expect(input.password.length).toBeGreaterThanOrEqual(8);
    });
  

    it('Should reject weak passwords', async () => {
      await expect(behavior({ ...validInput, password: 'short' })).rejects.toMatchObject({ code: 'WEAK_PASSWORD' });
    });
  

  });

describe('Postconditions', () => {

    it('Session should be created and active', async () => {
      expect(result.session).toBeDefined();
      expect(result.session.id).toBeDefined();
      expect(result.session.revoked).toBe(false);
    });
  

    it('Session should not be expired', async () => {
      expect(new Date(result.session.expires_at).getTime()).toBeGreaterThan(Date.now());
    });
  

    it('Access token should be present and valid', async () => {
      expect(result.access_token).toBeDefined();
      expect(typeof result.access_token).toBe('string');
      expect(result.access_token.length).toBeGreaterThan(0);
    });
  

  });

describe('Error Cases', () => {

    it('Should return INVALID_CREDENTIALS for wrong password', async () => {
      const wrongPasswordInput = { ...validInput, password: 'wrong_password' };
      const result = await Login(wrongPasswordInput);
      expect(result.success).toBe(false);
      expect(result.error).toBe('INVALID_CREDENTIALS');
      expect(result.retriable).toBe(true);
    });
  

    it('Should return ACCOUNT_LOCKED after max failed attempts', async () => {
      // After 10 failed attempts
      const result = await Login(validInput);
      expect(result.success).toBe(false);
      expect(result.error).toBe('ACCOUNT_LOCKED');
      expect(result.retriable).toBe(true);
      expect(result.retryAfter).toBeDefined();
    });
  

  });

  // No invariants defined
});"
`;

exports[`File-Upload Snapshot > generates correct test structure > file-upload-test 1`] = `
"import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { UploadFile } from '../src/UploadFile';
import type { UploadFileInput, UploadFileResult } from '../src/types';
import { createValidInputForUploadFile, createInvalidInputForUploadFile } from './helpers/test-utils';
import { StoredFile } from './helpers/fixtures';

/**
 * Tests for UploadFile behavior
 * Domain: FileStorage
 * Detected strategy: uploads
 * Upload a file
 */
describe('UploadFile', () => {
  // Test setup
  let validInput: UploadFileInput;
  
  beforeEach(() => {
    validInput = createValidInputForUploadFile();
  });

  afterEach(() => {
    // Cleanup if needed
  });

describe('Preconditions', () => {

    it('File must not be empty', async () => {
      expect(input.file.size).toBeGreaterThan(0);
    });
  

    it('Should reject empty files', async () => {
      const emptyFileInput = { ...validInput, file: { ...validInput.file, size: 0 } };
      const result = await UploadFile(emptyFileInput);
      expect(result.success).toBe(false);
      expect(result.error).toBe('EMPTY_FILE');
    });
  

    it('File size must not exceed 10MB', async () => {
      expect(input.file.size).toBeLessThanOrEqual(10485760);
    });
  

    it('Should reject files exceeding size limit', async () => {
      const largeFileInput = { ...validInput, file: { ...validInput.file, size: 10485761 } };
      const result = await UploadFile(largeFileInput);
      expect(result.success).toBe(false);
      expect(result.error).toBe('FILE_TOO_LARGE');
    });
  

    it('Filename must be provided', async () => {
      expect(input.filename).toBeDefined();
      expect(input.filename.length).toBeGreaterThan(0);
    });
  

    it('Should reject dangerous filenames', async () => {
      // Check for dangerous filenames
      const dangerousFilenames = ['../../../etc/passwd', 'shell.php', '<script>.jpg'];
      for (const dangerous of dangerousFilenames) {
        const result = await UploadFile({ ...validInput, filename: dangerous });
        expect(result.success).toBe(false);
      }
    });
  

  });

describe('Postconditions', () => {

    it('File record should be persisted', async () => {
      expect(result.id).toBeDefined();
      const uploadedFile = await File.findById(result.id);
      expect(uploadedFile).toBeDefined();
    });
  

    it('Filename should be sanitized', async () => {
      expect(result.filename).toBeDefined();
      // Filename should be sanitized (no path traversal, safe characters)
      expect(result.filename).not.toMatch(/[\\\\/<>:"|?*]/);
    });
  

    it('Content type should be preserved', async () => {
      expect(result.content_type).toEqual(input.content_type);
    });
  

    it('File size should match input', async () => {
      expect(result.size).toEqual(input.file.size);
    });
  

    it('Result should contain valid URL', async () => {
      expect(result.url).toBeDefined();
      expect(result.url).not.toBeNull();
      expect(typeof result.url).toBe('string');
      expect(result.url.length).toBeGreaterThan(0);
    });
  

    it('URL should be valid format', async () => {
      // Validate URL format
      expect(() => new URL(result.url)).not.toThrow();
    });
  

    it('URL should be accessible (optional integration test)', async () => {
      // Optionally verify URL is accessible
      // const response = await fetch(result.url, { method: 'HEAD' });
      // expect(response.ok).toBe(true);
    });
  

    it('Checksum should be generated', async () => {
      expect(result.checksum).toBeDefined();
      expect(result.checksum.length).toBeGreaterThan(0);
    });
  

  });

describe('Error Cases', () => {

    it('Should return FILE_TOO_LARGE for oversized files', async () => {
      const largeFileInput = { ...validInput, file: { size: 100 * 1024 * 1024, data: Buffer.alloc(0) } };
      const result = await UploadFile(largeFileInput);
      expect(result.success).toBe(false);
      expect(result.error).toBe('FILE_TOO_LARGE');
      expect(result.retriable).toBe(false);
    });
  

    it('Should return INVALID_TYPE when File type not allowed', async () => {
      const result = await UploadFile(inputForINVALID_TYPE());
      expect(result.success).toBe(false);
      expect(result.error).toBe('INVALID_TYPE');
      expect(result.retriable).toBe(false);
    });
  

    it('Should return EMPTY_FILE for zero-byte files', async () => {
      const emptyFileInput = { ...validInput, file: { size: 0, data: Buffer.alloc(0) } };
      const result = await UploadFile(emptyFileInput);
      expect(result.success).toBe(false);
      expect(result.error).toBe('EMPTY_FILE');
    });
  

  });

  // No invariants defined
});"
`;

exports[`Helper File Snapshots > generates correct fixtures > fixtures 1`] = `
"// Test fixtures for Auth
// Auto-generated by @isl-lang/test-generator


export const userFixture = {
  id: '00000000-0000-0000-0000-000000000001',
  email: 'test-value',
};

export function createUser(overrides?: Partial<typeof userFixture>) {
  return { ...userFixture, ...overrides };
}

export const User = {
  findById: async (id: string) => createUser({ id }),
  findByEmail: async (email: string) => createUser({ email } as Partial<typeof userFixture>),
  exists: async (criteria: Record<string, unknown>) => true,
  count: async (criteria?: Record<string, unknown>) => 1,
};


export const sessionFixture = {
  id: '00000000-0000-0000-0000-000000000001',
  token: 'test-value',
};

export function createSession(overrides?: Partial<typeof sessionFixture>) {
  return { ...sessionFixture, ...overrides };
}

export const Session = {
  findById: async (id: string) => createSession({ id }),
  findByEmail: async (email: string) => createSession({ email } as Partial<typeof sessionFixture>),
  exists: async (criteria: Record<string, unknown>) => true,
  count: async (criteria?: Record<string, unknown>) => 1,
};"
`;

exports[`Helper File Snapshots > generates correct test utilities > test-utils 1`] = `
"// Test utilities for Auth
// Auto-generated by @isl-lang/test-generator

import type { LoginInput } from '../src/types';


export function createValidInputForLogin(): LoginInput {
  return {
    email: 'test-value',
    password: 'test-value',
  };
}

export function createInvalidInputForLogin(): LoginInput {
  return {
    email: '',
    password: '',
  };
}


export function createInputViolating(condition: string): unknown {
  // Override this based on the condition being violated
  return {};
}

export function captureState(): Record<string, unknown> {
  return {
    timestamp: Date.now(),
  };
}"
`;

exports[`Metadata Snapshots > generates correct metadata structure > metadata-structure 1`] = `
{
  "behaviors": [
    {
      "assertions": [
        {
          "description": "Email must be provided and non-empty",
          "pattern": "auth.invalid_email",
          "status": "supported",
        },
        {
          "description": "Should throw for invalid email format",
          "pattern": "auth.invalid_email",
          "status": "supported",
        },
        {
          "description": "Should return INVALID_CREDENTIALS for wrong password",
          "pattern": "auth.invalid_password",
          "status": "supported",
        },
      ],
      "coverage": {
        "coveredInvariants": 0,
        "coveredPostconditions": 0,
        "coveredPreconditions": 1,
        "totalInvariants": 0,
        "totalPostconditions": 0,
        "totalPreconditions": 1,
      },
      "domain": "auth",
      "name": "Login",
    },
  ],
  "domain": "auth",
  "openQuestions": [],
  "stats": {
    "needsImplAssertions": 0,
    "openQuestionsCount": 0,
    "supportedAssertions": 3,
    "totalAssertions": 3,
    "totalBehaviors": 1,
    "unsupportedAssertions": 0,
  },
}
`;

exports[`Payment-Charge Snapshot > generates correct test structure with temporal > payment-charge-test 1`] = `
"import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { ChargePayment } from '../src/ChargePayment';
import type { ChargePaymentInput, ChargePaymentResult } from '../src/types';
import { createValidInputForChargePayment, createInvalidInputForChargePayment } from './helpers/test-utils';
import { Charge, Customer } from './helpers/fixtures';

/**
 * Tests for ChargePayment behavior
 * Domain: Billing
 * Detected strategy: payments
 * Charge a payment
 */
describe('ChargePayment', () => {
  // Test setup
  let validInput: ChargePaymentInput;
  
  beforeEach(() => {
    validInput = createValidInputForChargePayment();
  });

  afterEach(() => {
    // Cleanup if needed
  });

describe('Preconditions', () => {

    it('Payment amount must be positive', async () => {
      expect(input.amount).toBeGreaterThan(0);
    });
  

    it('Should reject zero amount', async () => {
      const zeroAmountInput = { ...validInput, amount: 0 };
      const result = await ChargePayment(zeroAmountInput);
      expect(result.success).toBe(false);
    });
  

    it('Should reject negative amount', async () => {
      const negativeAmountInput = { ...validInput, amount: -10 };
      const result = await ChargePayment(negativeAmountInput);
      expect(result.success).toBe(false);
    });
  

  });

describe('Postconditions', () => {

    it('Payment amount should match input', async () => {
      expect(result.amount).toEqual(input.amount);
    });
  

    it('Payment currency should match input', async () => {
      expect(result.currency).toEqual(input.currency);
    });
  

    it('Payment status should be COMPLETED or PROCESSING', async () => {
      expect(['COMPLETED', 'PROCESSING']).toContain(result.status);
    });
  

  });

describe('Error Cases', () => {

    it('Should return INSUFFICIENT_FUNDS when card has insufficient balance', async () => {
      const insufficientFundsInput = { ...validInput, amount: 999999.99 };
      const result = await ChargePayment(insufficientFundsInput);
      expect(result.success).toBe(false);
      expect(result.error).toBe('INSUFFICIENT_FUNDS');
      expect(result.retriable).toBe(true);
    });
  

    it('Should return INVALID_AMOUNT when Amount not positive', async () => {
      const result = await ChargePayment(inputForINVALID_AMOUNT());
      expect(result.success).toBe(false);
      expect(result.error).toBe('INVALID_AMOUNT');
      expect(result.retriable).toBe(false);
    });
  

    it('Should return CUSTOMER_NOT_FOUND when Customer does not exist', async () => {
      const result = await ChargePayment(inputForCUSTOMER_NOT_FOUND());
      expect(result.success).toBe(false);
      expect(result.error).toBe('CUSTOMER_NOT_FOUND');
      expect(result.retriable).toBe(false);
    });
  

  });

  // No invariants defined
});"
`;

exports[`Rate-Limit Snapshot > generates correct test structure with security and temporal > rate-limit-test 1`] = `
"import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { HandleRequest } from '../src/HandleRequest';
import type { HandleRequestInput, HandleRequestResult } from '../src/types';
import { createValidInputForHandleRequest, createInvalidInputForHandleRequest } from './helpers/test-utils';
import { RateLimitEntry } from './helpers/fixtures';

/**
 * Tests for HandleRequest behavior
 * Domain: APIGateway
 * Detected strategy: webhooks
 * Handle API request with rate limiting
 */
describe('HandleRequest', () => {
  // Test setup
  let validInput: HandleRequestInput;
  
  beforeEach(() => {
    validInput = createValidInputForHandleRequest();
  });

  afterEach(() => {
    // Cleanup if needed
  });

describe('Preconditions', () => {

    it('Precondition: (input.client_id.length > 0)', async () => {
      expect((input.client_id.length > 0)).toBe(true);
    });
  

    it('Precondition: (input.endpoint.length > 0)', async () => {
      expect((input.endpoint.length > 0)).toBe(true);
    });
  

  });

describe('Postconditions', () => {

    it('Postcondition (success): (result.allowed === true)', async () => {
      expect((result.allowed === true)).toBe(true);
    });
  

    it('Postcondition (success): (result.remaining >= 0)', async () => {
      expect((result.remaining >= 0)).toBe(true);
    });
  

    it('Postcondition (RATE_LIMITED): (result.allowed === false)', async () => {
      expect((result.allowed === false)).toBe(true);
    });
  

    it('Postcondition (RATE_LIMITED): (result.remaining === 0)', async () => {
      expect((result.remaining === 0)).toBe(true);
    });
  

  });

describe('Error Cases', () => {

    it('Should return RATE_LIMITED when threshold exceeded', async () => {
      // Send many webhooks rapidly
      const results = await Promise.all(
        Array(100).fill(null).map(() => HandleRequest(validInput))
      );
      const rateLimited = results.filter(r => r.error === 'RATE_LIMITED');
      expect(rateLimited.length).toBeGreaterThan(0);
    });
  

    it('Should return INVALID_ENDPOINT when Endpoint does not exist', async () => {
      const result = await HandleRequest(inputForINVALID_ENDPOINT());
      expect(result.success).toBe(false);
      expect(result.error).toBe('INVALID_ENDPOINT');
      expect(result.retriable).toBe(false);
    });
  

  });

  // No invariants defined
});"
`;

exports[`Synthesis Path Snapshots > generates synthesized test file snapshot > synthesis-auth-login 1`] = `
"// ============================================================================
// Generated Tests for Login
// Domain: Auth
// Generated: TIMESTAMP
// Seed: SEED
// ============================================================================

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';

// Behavior implementation
import { login } from '../src/Login';
import type { LoginInput, LoginResult } from '../src/types';

// Entity mocks
import { User, Session } from './fixtures';

// Test context
let testContext: {
  reset: () => void;
  captureState: () => Record<string, unknown>;
};

beforeEach(() => {
  testContext = {
    reset: () => {
      // Reset entity state
      User.reset?.();
      Session.reset?.();
    },
    captureState: () => ({
      timestamp: Date.now(),
    }),
  };
  testContext.reset();
});

afterEach(() => {
  // Cleanup
});

describe('Login', () => {

  describe('Valid Inputs', () => {

    it('Valid input with typical values within constraints', async () => {
      /**
       * @dataTrace
       * Seed: SEED
       * Strategy: typical_midpoint
       * Generated: TIMESTAMP
       * Constraints:
       *   - email (String): none
       *   - password (String): none
       */
      // Arrange
      const input: LoginInput = {
        email: "test_1uumrw",
        password: "test_bcxaq0",
      };
      
      // Act
      const result = await login(input);
      
      // Assert
      // Primary assertions
      expect(result.data.access_token).not.toBe(null);
      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
      
    });

    it('Seeded random valid input within constraints', async () => {
      /**
       * @dataTrace
       * Seed: SEED
       * Strategy: seeded_random
       * Generated: TIMESTAMP
       * Constraints:
       *   - email (String): none
       *   - password (String): none
       */
      // Arrange
      const input: LoginInput = {
        email: "ku9dljd3",
        password: "79rbjyxvtqa8y3xfz",
      };
      
      // Act
      const result = await login(input);
      
      // Assert
      // Primary assertions
      expect(result.data.access_token).not.toBe(null);
      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
      
    });
  });

  describe('Boundary Cases', () => {

    it('Boundary: email at empty string', async () => {
      /**
       * @dataTrace
       * Seed: SEED
       * Strategy: boundary_empty
       * Generated: TIMESTAMP
       * Constraints:
       *   - email (String): none
       *   - password (String): none
       */
      // Arrange
      const input: LoginInput = {
        email: "",
        password: "test_6z1beq",
      };
      
      // Act
      const result = await login(input);
      
      // Assert
      // Primary assertions
      expect(result.data.access_token).not.toBe(null);
      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
      
    });

    it('Boundary: password at empty string', async () => {
      /**
       * @dataTrace
       * Seed: SEED
       * Strategy: boundary_empty
       * Generated: TIMESTAMP
       * Constraints:
       *   - email (String): none
       *   - password (String): none
       */
      // Arrange
      const input: LoginInput = {
        email: "test_m62eta",
        password: "",
      };
      
      // Act
      const result = await login(input);
      
      // Assert
      // Primary assertions
      expect(result.data.access_token).not.toBe(null);
      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
      
    });
  });

  describe('Invalid Inputs (Negative Tests)', () => {

    it('Invalid: email - null value', async () => {
      /**
       * @dataTrace
       * Seed: SEED
       * Strategy: constraint_violation_null_value
       * Generated: TIMESTAMP
       * Constraints:
       *   - email (String): none
       *   - password (String): none
       */
      // Arrange
      const input: LoginInput = {
        email: null,
        password: "test_rdocmd",
      };
      
      // Act
      const result = await login(input);
      
      // Assert
      // Primary assertions
      expect(result.success).toBe(false);
      
    });

    it('Invalid: password - null value', async () => {
      /**
       * @dataTrace
       * Seed: SEED
       * Strategy: constraint_violation_null_value
       * Generated: TIMESTAMP
       * Constraints:
       *   - email (String): none
       *   - password (String): none
       */
      // Arrange
      const input: LoginInput = {
        email: "test_yvw8xz",
        password: null,
      };
      
      // Act
      const result = await login(input);
      
      // Assert
      // Primary assertions
      expect(result.success).toBe(false);
      
    });

    it('Missing required field: email', async () => {
      /**
       * @dataTrace
       * Seed: SEED
       * Strategy: missing_required_field
       * Generated: TIMESTAMP
       * Constraints:
       *   - email (String): none
       *   - password (String): none
       */
      // Arrange
      const input: LoginInput = {
        password: "test_x73elb",
      };
      
      // Act
      const result = await login(input);
      
      // Assert
      // Primary assertions
      expect(result.success).toBe(false);
      
    });

    it('Missing required field: password', async () => {
      /**
       * @dataTrace
       * Seed: SEED
       * Strategy: missing_required_field
       * Generated: TIMESTAMP
       * Constraints:
       *   - email (String): none
       *   - password (String): none
       */
      // Arrange
      const input: LoginInput = {
        email: "test_1o7q4o",
      };
      
      // Act
      const result = await login(input);
      
      // Assert
      // Primary assertions
      expect(result.success).toBe(false);
      
    });
  });

  describe('Precondition Violations', () => {

    it('Violates precondition: input.email.length > 0', async () => {
      /**
       * @dataTrace
       * Seed: SEED
       * Strategy: precondition_violation_>_violation
       * Generated: TIMESTAMP
       * Constraints:
       *   - email (String): none
       *   - password (String): none
       */
      // Arrange
      const input: LoginInput = {
        email: 0,
        password: "test_dhqoj8",
      };
      
      // Act
      const result = await login(input);
      
      // Assert
      // Primary assertions
      expect(result.success).toBe(false);
      
    });
  });
});

// ============================================================================
// Helper Functions
// ============================================================================

async function captureState(path: string): Promise<unknown> {
  // Implement state capture for old() expressions
  return undefined;
}"
`;

exports[`User-Create Snapshot > generates correct test structure > user-create-test 1`] = `
"import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { CreateUser } from '../src/CreateUser';
import type { CreateUserInput, CreateUserResult } from '../src/types';
import { createValidInputForCreateUser, createInvalidInputForCreateUser } from './helpers/test-utils';
import { User } from './helpers/fixtures';

/**
 * Tests for CreateUser behavior
 * Domain: UserManagement
 * Detected strategy: auth
 * Create a new user account
 */
describe('CreateUser', () => {
  // Test setup
  let validInput: CreateUserInput;
  
  beforeEach(() => {
    validInput = createValidInputForCreateUser();
  });

  afterEach(() => {
    // Cleanup if needed
  });

describe('Preconditions', () => {

    it('Email must be provided and non-empty', async () => {
      expect(input.email).toBeDefined();
      expect(input.email.length).toBeGreaterThan(0);
    });
  

    it('Should throw for invalid email format', async () => {
      await expect(behavior(invalidEmailInput)).rejects.toMatchObject({ code: 'INVALID_EMAIL' });
    });
  

    it('Precondition: (input.name.length > 0)', async () => {
      expect((input.name.length > 0)).toBe(true);
    });
  

    it('Password must be at least 8 characters', async () => {
      expect(input.password.length).toBeGreaterThanOrEqual(8);
    });
  

    it('Should reject weak passwords', async () => {
      await expect(behavior({ ...validInput, password: 'short' })).rejects.toMatchObject({ code: 'WEAK_PASSWORD' });
    });
  

  });

describe('Postconditions', () => {

    it('User status should be updated', async () => {
      const updatedUser = await User.findById(result.id);
      expect(updatedUser.status).toBe('ACTIVE');
    });
  

    it('Postcondition (EMAIL_ALREADY_EXISTS): (User.count() === /* unsupported: OldExpr */)', async () => {
      expect((User.count() === /* unsupported: OldExpr */)).toBe(true);
    });
  

  });

describe('Error Cases', () => {

    it('Should return EMAIL_ALREADY_EXISTS when Email already registered', async () => {
      const result = await CreateUser(inputForEMAIL_ALREADY_EXISTS());
      expect(result.success).toBe(false);
      expect(result.error).toBe('EMAIL_ALREADY_EXISTS');
      expect(result.retriable).toBe(false);
    });
  

    it('Should return INVALID_EMAIL for malformed email', async () => {
      const invalidEmailInput = { ...validInput, email: 'not-an-email' };
      const result = await CreateUser(invalidEmailInput);
      expect(result.success).toBe(false);
      expect(result.error).toBe('INVALID_EMAIL');
      expect(result.retriable).toBe(false);
    });
  

  });

  // No invariants defined
});"
`;
