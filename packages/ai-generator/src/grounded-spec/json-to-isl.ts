/**
 * JSON → ISL Converter
 *
 * Converts the structured GroundedBehavior JSON (AI output) into valid ISL
 * spec text. Annotates speculative rules so downstream tooling can flag them.
 *
 * @module @isl-lang/ai-generator/grounded-spec/json-to-isl
 */

import type {
  GroundedBehavior,
  GroundedCondition,
  GroundedError,
  GroundedEffect,
  SpecConfidenceBudget,
} from './types.js';

// ============================================================================
// Options
// ============================================================================

export interface ISLConvertOptions {
  /** Minimum confidence to include a rule (default 0.4) */
  minConfidence?: number;
  /** Include speculative rules with [speculative] annotation (default true) */
  includeSpeculative?: boolean;
  /** Include confidence comments in output (default true) */
  includeConfidenceComments?: boolean;
  /** Domain name wrapper (default: inferred from first behavior) */
  domainName?: string;
  /** Optional confidence budget to embed as header comment */
  budget?: SpecConfidenceBudget;
}

// ============================================================================
// Main entry
// ============================================================================

/**
 * Convert an array of grounded behaviors into a complete ISL spec string.
 */
export function behaviorsToISL(
  behaviors: GroundedBehavior[],
  options: ISLConvertOptions = {},
): string {
  const {
    minConfidence = 0.4,
    includeSpeculative = true,
    includeConfidenceComments = true,
    domainName,
    budget,
  } = options;

  const lines: string[] = [];

  // Header comment with budget summary
  if (budget) {
    lines.push('// ─── Grounded Spec ───────────────────────────────────────');
    lines.push(`// Overall confidence: ${(budget.overallScore * 100).toFixed(0)}%`);
    lines.push(`// Strong rules: ${budget.strongCount}  Moderate: ${budget.moderateCount}  Weak: ${budget.weakCount}  Speculative: ${budget.speculativeCount}`);
    lines.push('// Generated by evidence-grounded AI — speculative rules flagged');
    lines.push('// ─────────────────────────────────────────────────────────');
    lines.push('');
  }

  // Domain wrapper
  const name = domainName ?? inferDomainName(behaviors);
  lines.push(`domain ${name} {`);
  lines.push('');

  for (const behavior of behaviors) {
    const behaviorLines = behaviorToISL(behavior, {
      minConfidence,
      includeSpeculative,
      includeConfidenceComments,
    });
    // Indent inside domain
    for (const line of behaviorLines) {
      lines.push(line ? `  ${line}` : '');
    }
    lines.push('');
  }

  lines.push('}');

  return lines.join('\n');
}

/**
 * Convert a single GroundedBehavior to ISL lines.
 */
function behaviorToISL(
  behavior: GroundedBehavior,
  opts: { minConfidence: number; includeSpeculative: boolean; includeConfidenceComments: boolean },
): string[] {
  const lines: string[] = [];

  // Behavior header
  lines.push(`behavior ${behavior.name} {`);

  if (behavior.description) {
    lines.push(`  description: "${escapeISLString(behavior.description)}"`);
    lines.push('');
  }

  // Input
  if (behavior.inputs.length > 0) {
    lines.push('  input {');
    for (const inp of behavior.inputs) {
      lines.push(`    ${inp.name}: ${inp.type}`);
    }
    lines.push('  }');
    lines.push('');
  }

  // Output
  if (behavior.output && behavior.output.type !== 'void') {
    lines.push('  output {');
    lines.push(`    success: ${behavior.output.type}`);

    // Error declarations
    const errors = filterByConfidence(behavior.errors, opts);
    if (errors.length > 0) {
      lines.push('    errors {');
      for (const err of errors) {
        const ann = annotationSuffix(err.confidence, opts);
        if (opts.includeConfidenceComments) {
          lines.push(`      // confidence: ${err.confidence.toFixed(2)} | evidence: ${err.evidence.join('; ')}`);
        }
        lines.push(`      ${err.throws}${ann}  // when: ${err.when}`);
      }
      lines.push('    }');
    }

    lines.push('  }');
    lines.push('');
  }

  // Preconditions
  const preconds = filterByConfidence(behavior.preconditions, opts);
  if (preconds.length > 0) {
    lines.push('  preconditions {');
    for (const c of preconds) {
      emitConditionLines(lines, c, opts);
    }
    lines.push('  }');
    lines.push('');
  }

  // Postconditions
  const postconds = filterByConfidence(behavior.postconditions, opts);
  if (postconds.length > 0) {
    lines.push('  postconditions {');
    lines.push('    success implies {');
    for (const c of postconds) {
      emitConditionLines(lines, c, opts, '    ');
    }
    lines.push('    }');
    lines.push('  }');
    lines.push('');
  }

  // Invariants
  const invariants = filterByConfidence(behavior.invariants, opts);
  if (invariants.length > 0) {
    lines.push('  invariants {');
    for (const c of invariants) {
      emitConditionLines(lines, c, opts);
    }
    lines.push('  }');
    lines.push('');
  }

  // Effects as annotations/comments
  const effects = filterByConfidence(behavior.effects, opts);
  if (effects.length > 0) {
    lines.push('  // effects:');
    for (const eff of effects) {
      const ann = eff.confidence < 0.4 ? ' [speculative]' : '';
      lines.push(`  // - ${eff.type}: ${eff.target} (confidence: ${eff.confidence.toFixed(2)})${ann}`);
    }
    lines.push('');
  }

  lines.push('}');

  return lines;
}

// ============================================================================
// Helpers
// ============================================================================

function emitConditionLines(
  lines: string[],
  cond: GroundedCondition,
  opts: { includeConfidenceComments: boolean },
  extraIndent = '',
): void {
  if (opts.includeConfidenceComments) {
    lines.push(`${extraIndent}    // confidence: ${cond.confidence.toFixed(2)} | evidence: ${cond.evidence.join('; ')}`);
  }
  const ann = cond.confidence < 0.4 ? ' [speculative]' : '';
  lines.push(`${extraIndent}    - ${cond.expr}${ann}`);
}

function filterByConfidence<T extends { confidence: number }>(
  items: T[],
  opts: { minConfidence: number; includeSpeculative: boolean },
): T[] {
  return items.filter((item) => {
    if (item.confidence >= opts.minConfidence) return true;
    return opts.includeSpeculative;
  });
}

function annotationSuffix(confidence: number, opts: { includeSpeculative: boolean }): string {
  if (confidence < 0.4 && opts.includeSpeculative) return ' [speculative]';
  return '';
}

function inferDomainName(behaviors: GroundedBehavior[]): string {
  if (behaviors.length === 0) return 'UnknownDomain';
  const first = behaviors[0]!.name;
  // Try to extract a domain-like name: CreateUser → User, ProcessPayment → Payment
  const match = first.match(/^(?:Create|Get|Update|Delete|Find|Process|Handle|Validate)?(\w+)/);
  return match ? `${match[1]}Service` : `${first}Domain`;
}

function escapeISLString(s: string): string {
  return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
}
