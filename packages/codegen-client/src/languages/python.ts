// ============================================================================
// Python Client Generator
// ============================================================================

import type { ClientConfig, ClientMethod, TypeDefinition, GenerateOptions } from '../types';

/**
 * Generate Python API client
 */
export function generatePythonClient(
  config: ClientConfig,
  options: GenerateOptions
): string {
  const lines: string[] = [];

  // Header
  lines.push('"""');
  lines.push('Auto-generated by @isl-lang/codegen-client');
  lines.push('Do not edit manually');
  lines.push('"""');
  lines.push('');
  lines.push('from __future__ import annotations');
  lines.push('');

  // Imports
  lines.push('import asyncio');
  lines.push('from dataclasses import dataclass, field');
  lines.push('from enum import Enum');
  lines.push('from typing import Any, Generic, TypeVar, Optional, Dict, List, Union');
  lines.push('from datetime import datetime');
  lines.push('import httpx');
  if (options.includeValidation) {
    lines.push('from pydantic import BaseModel, Field, validator');
  }
  if (options.includeLogging) {
    lines.push('import logging');
  }
  lines.push('');
  lines.push('');

  // Type variable for Result
  lines.push('T = TypeVar("T")');
  lines.push('E = TypeVar("E")');
  lines.push('');
  lines.push('');

  // Result type
  lines.push('@dataclass');
  lines.push('class Success(Generic[T]):');
  lines.push('    """Successful result wrapper"""');
  lines.push('    data: T');
  lines.push('    success: bool = field(default=True, init=False)');
  lines.push('');
  lines.push('');
  lines.push('@dataclass');
  lines.push('class Failure(Generic[E]):');
  lines.push('    """Failed result wrapper"""');
  lines.push('    error: E');
  lines.push('    success: bool = field(default=False, init=False)');
  lines.push('');
  lines.push('');
  lines.push('Result = Union[Success[T], Failure[E]]');
  lines.push('');
  lines.push('');

  // API Error class
  lines.push('class ApiError(Exception):');
  lines.push('    """API error with code and details"""');
  lines.push('    ');
  lines.push('    def __init__(');
  lines.push('        self,');
  lines.push('        code: str,');
  lines.push('        message: str,');
  lines.push('        status: Optional[int] = None,');
  lines.push('        details: Optional[Dict[str, Any]] = None');
  lines.push('    ):');
  lines.push('        super().__init__(message)');
  lines.push('        self.code = code');
  lines.push('        self.message = message');
  lines.push('        self.status = status');
  lines.push('        self.details = details or {}');
  lines.push('');
  lines.push('');

  // Type definitions
  lines.push('# =============================================================================');
  lines.push('# Types');
  lines.push('# =============================================================================');
  lines.push('');

  for (const type of config.types) {
    lines.push(generatePythonType(type, options.includeValidation || false));
    lines.push('');
    lines.push('');
  }

  // Client options
  lines.push('@dataclass');
  lines.push('class ClientOptions:');
  lines.push('    """Configuration options for the API client"""');
  lines.push('    base_url: str');
  lines.push('    headers: Dict[str, str] = field(default_factory=dict)');
  lines.push('    timeout: float = 30.0');
  if (options.includeRetry) {
    lines.push('    max_retries: int = 3');
    lines.push('    backoff_ms: int = 1000');
  }
  lines.push('');
  lines.push('');

  // Client class
  lines.push('# =============================================================================');
  lines.push('# Client');
  lines.push('# =============================================================================');
  lines.push('');
  lines.push(`class ${config.className}:`);
  lines.push('    """');
  lines.push(`    API client for ${config.className.replace('Client', '')}`);
  lines.push('    """');
  lines.push('    ');
  lines.push('    def __init__(self, options: ClientOptions):');
  lines.push(`        self.base_url = options.base_url or "${config.baseUrl}"`);
  lines.push('        self.headers = {');
  lines.push('            "Content-Type": "application/json",');
  lines.push('            **options.headers');
  lines.push('        }');
  lines.push('        self.timeout = options.timeout');
  if (options.includeRetry) {
    lines.push('        self.max_retries = options.max_retries');
    lines.push('        self.backoff_ms = options.backoff_ms');
  }
  if (options.includeLogging) {
    lines.push('        self.logger = logging.getLogger(__name__)');
  }
  lines.push('        self._client = httpx.AsyncClient(');
  lines.push('            base_url=self.base_url,');
  lines.push('            headers=self.headers,');
  lines.push('            timeout=self.timeout');
  lines.push('        )');
  lines.push('    ');

  // Context manager methods
  lines.push('    async def __aenter__(self):');
  lines.push('        return self');
  lines.push('    ');
  lines.push('    async def __aexit__(self, exc_type, exc_val, exc_tb):');
  lines.push('        await self._client.aclose()');
  lines.push('    ');

  // Request method
  lines.push(generatePythonRequestMethod(options));
  lines.push('    ');

  // API methods
  for (const method of config.methods) {
    lines.push(generatePythonMethod(method, options));
    lines.push('    ');
  }

  return lines.join('\n');
}

function generatePythonType(type: TypeDefinition, useValidation: boolean): string {
  const lines: string[] = [];

  if (type.kind === 'enum') {
    lines.push(`class ${type.name}(str, Enum):`);
    lines.push(`    """${type.name} enumeration"""`);
    for (const value of type.values || []) {
      lines.push(`    ${value} = "${value}"`);
    }
  } else if (type.kind === 'interface' || type.kind === 'type') {
    const baseClass = useValidation ? 'BaseModel' : '';
    const decorator = useValidation ? '' : '@dataclass\n';
    
    if (!useValidation) {
      lines.push('@dataclass');
    }
    
    lines.push(`class ${type.name}${baseClass ? `(${baseClass})` : ''}:`);
    lines.push(`    """${type.name} data structure"""`);
    
    for (const field of type.fields || []) {
      const pythonType = toPythonType(field.type);
      const optional = field.optional ? `Optional[${pythonType}]` : pythonType;
      const default_value = field.optional ? ' = None' : '';
      
      if (field.description) {
        lines.push(`    # ${field.description}`);
      }
      lines.push(`    ${toSnakeCase(field.name)}: ${optional}${default_value}`);
    }
    
    if ((type.fields || []).length === 0) {
      lines.push('    pass');
    }
  }

  return lines.join('\n');
}

function generatePythonRequestMethod(options: GenerateOptions): string {
  const lines: string[] = [];

  lines.push('    async def _request(');
  lines.push('        self,');
  lines.push('        method: str,');
  lines.push('        path: str,');
  lines.push('        body: Optional[Dict[str, Any]] = None');
  lines.push('    ) -> Dict[str, Any]:');
  lines.push('        """Make HTTP request to API"""');

  if (options.includeLogging) {
    lines.push('        self.logger.debug(f"{method} {path}", extra={"body": body})');
  }

  if (options.includeRetry) {
    lines.push('        ');
    lines.push('        last_error: Optional[Exception] = None');
    lines.push('        for attempt in range(self.max_retries + 1):');
    lines.push('            try:');
    lines.push('                if attempt > 0:');
    lines.push('                    await asyncio.sleep(self.backoff_ms * (2 ** (attempt - 1)) / 1000)');
    lines.push('                ');
  }

  const indent = options.includeRetry ? '                ' : '        ';

  lines.push(`${indent}response = await self._client.request(`);
  lines.push(`${indent}    method=method,`);
  lines.push(`${indent}    url=path,`);
  lines.push(`${indent}    json=body`);
  lines.push(`${indent})`);
  lines.push(`${indent}`);
  lines.push(`${indent}if response.status_code >= 400:`);
  lines.push(`${indent}    error_body = response.json() if response.content else {}`);
  lines.push(`${indent}    raise ApiError(`);
  lines.push(`${indent}        code=error_body.get("code", "UNKNOWN_ERROR"),`);
  lines.push(`${indent}        message=error_body.get("message", response.reason_phrase),`);
  lines.push(`${indent}        status=response.status_code,`);
  lines.push(`${indent}        details=error_body`);
  lines.push(`${indent}    )`);
  lines.push(`${indent}`);
  lines.push(`${indent}return response.json()`);

  if (options.includeRetry) {
    lines.push('            except (httpx.TransportError, httpx.TimeoutException) as e:');
    lines.push('                last_error = e');
    if (options.includeLogging) {
      lines.push('                self.logger.debug(f"Retry attempt {attempt + 1}", extra={"error": str(e)})');
    }
    lines.push('                continue');
    lines.push('            except ApiError as e:');
    lines.push('                if e.status and e.status >= 500:');
    lines.push('                    last_error = e');
    lines.push('                    continue');
    lines.push('                raise');
    lines.push('        ');
    lines.push('        if last_error:');
    lines.push('            raise last_error');
    lines.push('        raise RuntimeError("Unexpected state")');
  }

  return lines.join('\n');
}

function generatePythonMethod(method: ClientMethod, options: GenerateOptions): string {
  const lines: string[] = [];
  const inputParam = method.inputType !== 'void' ? `input_data: ${toPythonType(method.inputType)}` : '';
  const returnType = `Result[${toPythonType(method.outputType)}, ApiError]`;

  // Docstring
  lines.push(`    async def ${toSnakeCase(method.name)}(self${inputParam ? ', ' + inputParam : ''}) -> ${returnType}:`);
  lines.push('        """');
  if (method.description) {
    lines.push(`        ${method.description}`);
  }
  if (method.errorTypes.length > 0) {
    lines.push('        ');
    lines.push(`        Raises: ${method.errorTypes.join(', ')}`);
  }
  lines.push('        """');

  lines.push('        try:');
  
  if (method.inputType !== 'void') {
    lines.push('            body = input_data.__dict__ if hasattr(input_data, "__dict__") else input_data');
    lines.push(`            data = await self._request("${method.httpMethod}", "${method.path}", body)`);
  } else {
    lines.push(`            data = await self._request("${method.httpMethod}", "${method.path}")`);
  }
  
  lines.push(`            return Success(data=${toPythonType(method.outputType)}(**data) if isinstance(data, dict) else data)`);
  lines.push('        except ApiError as e:');
  lines.push('            return Failure(error=e)');
  lines.push('        except Exception as e:');
  lines.push('            return Failure(error=ApiError("UNKNOWN", str(e)))');

  return lines.join('\n');
}

function toPythonType(tsType: string): string {
  const typeMap: Record<string, string> = {
    'string': 'str',
    'number': 'float',
    'boolean': 'bool',
    'void': 'None',
    'any': 'Any',
    'unknown': 'Any',
    'null': 'None',
    'undefined': 'None',
    'Date': 'datetime',
    'Timestamp': 'datetime',
    'UUID': 'str',
  };

  // Handle arrays
  if (tsType.endsWith('[]')) {
    const elementType = tsType.slice(0, -2);
    return `List[${toPythonType(elementType)}]`;
  }

  // Handle optionals
  if (tsType.endsWith('?')) {
    const innerType = tsType.slice(0, -1);
    return `Optional[${toPythonType(innerType)}]`;
  }

  return typeMap[tsType] || tsType;
}

function toSnakeCase(str: string): string {
  return str
    .replace(/([A-Z])/g, '_$1')
    .toLowerCase()
    .replace(/^_/, '');
}

/**
 * Generate Python types file (separate from client)
 */
export function generatePythonTypes(types: TypeDefinition[], useValidation: boolean): string {
  const lines: string[] = [];

  lines.push('"""');
  lines.push('Auto-generated by @isl-lang/codegen-client');
  lines.push('Do not edit manually');
  lines.push('"""');
  lines.push('');
  lines.push('from __future__ import annotations');
  lines.push('');
  lines.push('from dataclasses import dataclass');
  lines.push('from enum import Enum');
  lines.push('from typing import Any, Optional, Dict, List');
  lines.push('from datetime import datetime');
  if (useValidation) {
    lines.push('from pydantic import BaseModel');
  }
  lines.push('');
  lines.push('');

  for (const type of types) {
    lines.push(generatePythonType(type, useValidation));
    lines.push('');
    lines.push('');
  }

  return lines.join('\n');
}
