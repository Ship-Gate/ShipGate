// ============================================================================
// Go Client Generator
// ============================================================================

import type { ClientConfig, ClientMethod, TypeDefinition, GenerateOptions } from '../types';

/**
 * Generate Go API client
 */
export function generateGoClient(
  config: ClientConfig,
  options: GenerateOptions
): string {
  const lines: string[] = [];
  const packageName = options.packageName || 'client';

  // Header
  lines.push('// Auto-generated by @isl-lang/codegen-client');
  lines.push('// Do not edit manually');
  lines.push('');
  lines.push(`package ${packageName}`);
  lines.push('');

  // Imports
  lines.push('import (');
  lines.push('\t"bytes"');
  lines.push('\t"context"');
  lines.push('\t"encoding/json"');
  lines.push('\t"fmt"');
  lines.push('\t"io"');
  lines.push('\t"net/http"');
  lines.push('\t"time"');
  if (options.includeRetry) {
    lines.push('\t"math"');
  }
  lines.push(')');
  lines.push('');

  // Type definitions
  lines.push('// =============================================================================');
  lines.push('// Types');
  lines.push('// =============================================================================');
  lines.push('');

  for (const type of config.types) {
    lines.push(generateGoType(type));
    lines.push('');
  }

  // Result type
  lines.push('// Result represents either a success or failure');
  lines.push('type Result[T any] struct {');
  lines.push('\tSuccess bool');
  lines.push('\tData    T');
  lines.push('\tError   *APIError');
  lines.push('}');
  lines.push('');

  // API Error
  lines.push('// APIError represents an API error response');
  lines.push('type APIError struct {');
  lines.push('\tCode    string                 `json:"code"`');
  lines.push('\tMessage string                 `json:"message"`');
  lines.push('\tStatus  int                    `json:"status,omitempty"`');
  lines.push('\tDetails map[string]interface{} `json:"details,omitempty"`');
  lines.push('}');
  lines.push('');
  lines.push('func (e *APIError) Error() string {');
  lines.push('\treturn fmt.Sprintf("%s: %s", e.Code, e.Message)');
  lines.push('}');
  lines.push('');

  // Client options
  lines.push('// ClientOptions configures the API client');
  lines.push('type ClientOptions struct {');
  lines.push('\tBaseURL    string');
  lines.push('\tHeaders    map[string]string');
  lines.push('\tTimeout    time.Duration');
  lines.push('\tHTTPClient *http.Client');
  if (options.includeRetry) {
    lines.push('\tMaxRetries int');
    lines.push('\tBackoffMs  int');
  }
  lines.push('}');
  lines.push('');

  // Default options
  lines.push('// DefaultOptions returns default client options');
  lines.push('func DefaultOptions(baseURL string) *ClientOptions {');
  lines.push('\treturn &ClientOptions{');
  lines.push('\t\tBaseURL: baseURL,');
  lines.push('\t\tHeaders: map[string]string{');
  lines.push('\t\t\t"Content-Type": "application/json",');
  lines.push('\t\t},');
  lines.push('\t\tTimeout: 30 * time.Second,');
  if (options.includeRetry) {
    lines.push('\t\tMaxRetries: 3,');
    lines.push('\t\tBackoffMs:  1000,');
  }
  lines.push('\t}');
  lines.push('}');
  lines.push('');

  // Client struct
  lines.push('// =============================================================================');
  lines.push('// Client');
  lines.push('// =============================================================================');
  lines.push('');
  lines.push(`// ${config.className} is the API client`);
  lines.push(`type ${config.className} struct {`);
  lines.push('\tbaseURL    string');
  lines.push('\theaders    map[string]string');
  lines.push('\thttpClient *http.Client');
  if (options.includeRetry) {
    lines.push('\tmaxRetries int');
    lines.push('\tbackoffMs  int');
  }
  lines.push('}');
  lines.push('');

  // Constructor
  lines.push(`// New${config.className} creates a new API client`);
  lines.push(`func New${config.className}(opts *ClientOptions) *${config.className} {`);
  lines.push('\tif opts == nil {');
  lines.push(`\t\topts = DefaultOptions("${config.baseUrl}")`);
  lines.push('\t}');
  lines.push('');
  lines.push('\thttpClient := opts.HTTPClient');
  lines.push('\tif httpClient == nil {');
  lines.push('\t\thttpClient = &http.Client{');
  lines.push('\t\t\tTimeout: opts.Timeout,');
  lines.push('\t\t}');
  lines.push('\t}');
  lines.push('');
  lines.push(`\treturn &${config.className}{`);
  lines.push('\t\tbaseURL:    opts.BaseURL,');
  lines.push('\t\theaders:    opts.Headers,');
  lines.push('\t\thttpClient: httpClient,');
  if (options.includeRetry) {
    lines.push('\t\tmaxRetries: opts.MaxRetries,');
    lines.push('\t\tbackoffMs:  opts.BackoffMs,');
  }
  lines.push('\t}');
  lines.push('}');
  lines.push('');

  // Request method
  lines.push(generateGoRequestMethod(config.className, options));
  lines.push('');

  // API methods
  for (const method of config.methods) {
    lines.push(generateGoMethod(config.className, method, options));
    lines.push('');
  }

  return lines.join('\n');
}

function generateGoType(type: TypeDefinition): string {
  const lines: string[] = [];

  if (type.kind === 'enum') {
    lines.push(`// ${type.name} represents the ${type.name} enumeration`);
    lines.push(`type ${type.name} string`);
    lines.push('');
    lines.push('const (');
    for (const value of type.values || []) {
      lines.push(`\t${type.name}${value} ${type.name} = "${value}"`);
    }
    lines.push(')');
  } else if (type.kind === 'interface' || type.kind === 'type') {
    lines.push(`// ${type.name} represents the ${type.name} data structure`);
    lines.push(`type ${type.name} struct {`);
    for (const field of type.fields || []) {
      const goType = toGoType(field.type);
      const jsonTag = `json:"${toSnakeCase(field.name)}${field.optional ? ',omitempty' : ''}"`;
      const pointer = field.optional ? '*' : '';
      lines.push(`\t${toPascalCase(field.name)} ${pointer}${goType} \`${jsonTag}\``);
    }
    lines.push('}');
  }

  return lines.join('\n');
}

function generateGoRequestMethod(className: string, options: GenerateOptions): string {
  const lines: string[] = [];

  lines.push(`func (c *${className}) request(ctx context.Context, method, path string, body interface{}, result interface{}) error {`);
  lines.push('\tvar bodyReader io.Reader');
  lines.push('\tif body != nil {');
  lines.push('\t\tjsonBody, err := json.Marshal(body)');
  lines.push('\t\tif err != nil {');
  lines.push('\t\t\treturn &APIError{Code: "MARSHAL_ERROR", Message: err.Error()}');
  lines.push('\t\t}');
  lines.push('\t\tbodyReader = bytes.NewReader(jsonBody)');
  lines.push('\t}');
  lines.push('');
  lines.push('\turl := c.baseURL + path');

  if (options.includeRetry) {
    lines.push('');
    lines.push('\tvar lastErr error');
    lines.push('\tfor attempt := 0; attempt <= c.maxRetries; attempt++ {');
    lines.push('\t\tif attempt > 0 {');
    lines.push('\t\t\tbackoff := time.Duration(c.backoffMs) * time.Millisecond * time.Duration(math.Pow(2, float64(attempt-1)))');
    lines.push('\t\t\ttime.Sleep(backoff)');
    lines.push('\t\t}');
    lines.push('');
  }

  const indent = options.includeRetry ? '\t\t' : '\t';

  lines.push(`${indent}req, err := http.NewRequestWithContext(ctx, method, url, bodyReader)`);
  lines.push(`${indent}if err != nil {`);
  lines.push(`${indent}\treturn &APIError{Code: "REQUEST_ERROR", Message: err.Error()}`);
  lines.push(`${indent}}`);
  lines.push('');
  lines.push(`${indent}for key, value := range c.headers {`);
  lines.push(`${indent}\treq.Header.Set(key, value)`);
  lines.push(`${indent}}`);
  lines.push('');
  lines.push(`${indent}resp, err := c.httpClient.Do(req)`);
  lines.push(`${indent}if err != nil {`);
  if (options.includeRetry) {
    lines.push(`${indent}\tlastErr = &APIError{Code: "NETWORK_ERROR", Message: err.Error()}`);
    lines.push(`${indent}\tcontinue`);
  } else {
    lines.push(`${indent}\treturn &APIError{Code: "NETWORK_ERROR", Message: err.Error()}`);
  }
  lines.push(`${indent}}`);
  lines.push(`${indent}defer resp.Body.Close()`);
  lines.push('');
  lines.push(`${indent}respBody, err := io.ReadAll(resp.Body)`);
  lines.push(`${indent}if err != nil {`);
  lines.push(`${indent}\treturn &APIError{Code: "READ_ERROR", Message: err.Error()}`);
  lines.push(`${indent}}`);
  lines.push('');
  lines.push(`${indent}if resp.StatusCode >= 400 {`);
  lines.push(`${indent}\tvar apiErr APIError`);
  lines.push(`${indent}\tif err := json.Unmarshal(respBody, &apiErr); err != nil {`);
  lines.push(`${indent}\t\tapiErr = APIError{Code: "UNKNOWN_ERROR", Message: string(respBody)}`);
  lines.push(`${indent}\t}`);
  lines.push(`${indent}\tapiErr.Status = resp.StatusCode`);
  if (options.includeRetry) {
    lines.push(`${indent}\tif resp.StatusCode >= 500 {`);
    lines.push(`${indent}\t\tlastErr = &apiErr`);
    lines.push(`${indent}\t\tcontinue`);
    lines.push(`${indent}\t}`);
  }
  lines.push(`${indent}\treturn &apiErr`);
  lines.push(`${indent}}`);
  lines.push('');
  lines.push(`${indent}if result != nil {`);
  lines.push(`${indent}\tif err := json.Unmarshal(respBody, result); err != nil {`);
  lines.push(`${indent}\t\treturn &APIError{Code: "UNMARSHAL_ERROR", Message: err.Error()}`);
  lines.push(`${indent}\t}`);
  lines.push(`${indent}}`);
  lines.push('');
  lines.push(`${indent}return nil`);

  if (options.includeRetry) {
    lines.push('\t}');
    lines.push('');
    lines.push('\treturn lastErr');
  }

  lines.push('}');

  return lines.join('\n');
}

function generateGoMethod(className: string, method: ClientMethod, options: GenerateOptions): string {
  const lines: string[] = [];
  const methodName = toPascalCase(method.name);
  const hasInput = method.inputType !== 'void';
  const inputType = hasInput ? toGoType(method.inputType) : '';
  const outputType = toGoType(method.outputType);

  // Function signature
  lines.push(`// ${methodName} ${method.description || `calls the ${method.name} API`}`);
  
  if (hasInput) {
    lines.push(`func (c *${className}) ${methodName}(ctx context.Context, input *${inputType}) Result[${outputType}] {`);
  } else {
    lines.push(`func (c *${className}) ${methodName}(ctx context.Context) Result[${outputType}] {`);
  }

  lines.push(`\tvar result ${outputType}`);
  
  if (hasInput) {
    lines.push(`\terr := c.request(ctx, "${method.httpMethod}", "${method.path}", input, &result)`);
  } else {
    lines.push(`\terr := c.request(ctx, "${method.httpMethod}", "${method.path}", nil, &result)`);
  }

  lines.push('\tif err != nil {');
  lines.push('\t\tapiErr, ok := err.(*APIError)');
  lines.push('\t\tif !ok {');
  lines.push('\t\t\tapiErr = &APIError{Code: "UNKNOWN", Message: err.Error()}');
  lines.push('\t\t}');
  lines.push(`\t\treturn Result[${outputType}]{Success: false, Error: apiErr}`);
  lines.push('\t}');
  lines.push(`\treturn Result[${outputType}]{Success: true, Data: result}`);
  lines.push('}');

  return lines.join('\n');
}

function toGoType(tsType: string): string {
  const typeMap: Record<string, string> = {
    'string': 'string',
    'number': 'float64',
    'int': 'int',
    'integer': 'int',
    'boolean': 'bool',
    'void': '',
    'any': 'interface{}',
    'unknown': 'interface{}',
    'null': 'interface{}',
    'Date': 'time.Time',
    'Timestamp': 'time.Time',
    'UUID': 'string',
  };

  // Handle arrays
  if (tsType.endsWith('[]')) {
    const elementType = tsType.slice(0, -2);
    return `[]${toGoType(elementType)}`;
  }

  // Handle optionals (Go uses pointers)
  if (tsType.endsWith('?')) {
    const innerType = tsType.slice(0, -1);
    return `*${toGoType(innerType)}`;
  }

  return typeMap[tsType] || tsType;
}

function toSnakeCase(str: string): string {
  return str
    .replace(/([A-Z])/g, '_$1')
    .toLowerCase()
    .replace(/^_/, '');
}

function toPascalCase(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Generate Go types file (separate from client)
 */
export function generateGoTypes(types: TypeDefinition[], packageName: string): string {
  const lines: string[] = [];

  lines.push('// Auto-generated by @isl-lang/codegen-client');
  lines.push('// Do not edit manually');
  lines.push('');
  lines.push(`package ${packageName}`);
  lines.push('');
  lines.push('import (');
  lines.push('\t"time"');
  lines.push(')');
  lines.push('');

  for (const type of types) {
    lines.push(generateGoType(type));
    lines.push('');
  }

  return lines.join('\n');
}
