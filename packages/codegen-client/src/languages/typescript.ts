// ============================================================================
// TypeScript Client Generator
// ============================================================================

import type { ClientConfig, ClientMethod, TypeDefinition, GenerateOptions } from '../types';

/**
 * Generate TypeScript API client
 */
export function generateTypeScriptClient(
  config: ClientConfig,
  options: GenerateOptions
): string {
  const lines: string[] = [];
  const httpClient = options.httpClient || 'fetch';

  // Header
  lines.push('// Auto-generated by @isl-lang/codegen-client');
  lines.push('// Do not edit manually');
  lines.push('');

  // Imports based on HTTP client
  if (httpClient === 'axios') {
    lines.push("import axios, { AxiosInstance, AxiosRequestConfig, AxiosError } from 'axios';");
  } else if (httpClient === 'ky') {
    lines.push("import ky, { KyInstance, Options as KyOptions } from 'ky';");
  }
  lines.push('');

  // Type definitions
  lines.push('// =============================================================================');
  lines.push('// Types');
  lines.push('// =============================================================================');
  lines.push('');

  for (const type of config.types) {
    lines.push(generateTypeDefinition(type));
    lines.push('');
  }

  // Result type for error handling
  lines.push('export type Result<T, E = Error> =');
  lines.push('  | { success: true; data: T }');
  lines.push('  | { success: false; error: E };');
  lines.push('');

  // Client options interface
  lines.push('export interface ClientOptions {');
  lines.push('  baseUrl: string;');
  lines.push('  headers?: Record<string, string>;');
  lines.push('  timeout?: number;');
  if (options.includeRetry) {
    lines.push('  retry?: {');
    lines.push('    maxRetries: number;');
    lines.push('    backoffMs: number;');
    lines.push('  };');
  }
  if (options.includeLogging) {
    lines.push('  logger?: {');
    lines.push('    debug: (message: string, data?: unknown) => void;');
    lines.push('    error: (message: string, data?: unknown) => void;');
    lines.push('  };');
  }
  lines.push('}');
  lines.push('');

  // Error class
  lines.push('export class ApiError extends Error {');
  lines.push('  constructor(');
  lines.push('    public readonly code: string,');
  lines.push('    message: string,');
  lines.push('    public readonly status?: number,');
  lines.push('    public readonly details?: unknown');
  lines.push('  ) {');
  lines.push('    super(message);');
  lines.push('    this.name = "ApiError";');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  // Client class
  lines.push('// =============================================================================');
  lines.push('// Client');
  lines.push('// =============================================================================');
  lines.push('');
  lines.push(`export class ${config.className} {`);
  lines.push('  private readonly baseUrl: string;');
  lines.push('  private readonly headers: Record<string, string>;');
  lines.push('  private readonly timeout: number;');
  if (options.includeRetry) {
    lines.push('  private readonly retry: { maxRetries: number; backoffMs: number };');
  }
  if (options.includeLogging) {
    lines.push('  private readonly logger?: ClientOptions["logger"];');
  }
  lines.push('');

  // Constructor
  lines.push('  constructor(options: ClientOptions) {');
  lines.push(`    this.baseUrl = options.baseUrl || '${config.baseUrl}';`);
  lines.push('    this.headers = {');
  lines.push("      'Content-Type': 'application/json',");
  lines.push('      ...options.headers,');
  lines.push('    };');
  lines.push('    this.timeout = options.timeout || 30000;');
  if (options.includeRetry) {
    lines.push('    this.retry = options.retry || { maxRetries: 3, backoffMs: 1000 };');
  }
  if (options.includeLogging) {
    lines.push('    this.logger = options.logger;');
  }
  lines.push('  }');
  lines.push('');

  // Request method
  lines.push(generateRequestMethod(httpClient, options));
  lines.push('');

  // API methods
  for (const method of config.methods) {
    lines.push(generateClientMethod(method, options));
    lines.push('');
  }

  lines.push('}');
  lines.push('');

  // Default export
  lines.push(`export default ${config.className};`);

  return lines.join('\n');
}

function generateTypeDefinition(type: TypeDefinition): string {
  const lines: string[] = [];

  if (type.kind === 'enum') {
    lines.push(`export enum ${type.name} {`);
    for (const value of type.values || []) {
      lines.push(`  ${value} = '${value}',`);
    }
    lines.push('}');
  } else if (type.kind === 'interface' || type.kind === 'type') {
    const keyword = type.kind === 'interface' ? 'interface' : 'type';
    const assignment = type.kind === 'type' ? ' =' : '';
    const extendsClause = type.extends ? ` extends ${type.extends}` : '';

    lines.push(`export ${keyword} ${type.name}${extendsClause}${assignment} {`);
    for (const field of type.fields || []) {
      const optional = field.optional ? '?' : '';
      const comment = field.description ? `  /** ${field.description} */\n` : '';
      lines.push(`${comment}  ${field.name}${optional}: ${field.type};`);
    }
    lines.push('}');
  }

  return lines.join('\n');
}

function generateRequestMethod(httpClient: string, options: GenerateOptions): string {
  const lines: string[] = [];

  lines.push('  private async request<T>(');
  lines.push('    method: string,');
  lines.push('    path: string,');
  lines.push('    body?: unknown');
  lines.push('  ): Promise<T> {');
  lines.push('    const url = `${this.baseUrl}${path}`;');

  if (options.includeLogging) {
    lines.push('    this.logger?.debug(`${method} ${url}`, { body });');
  }

  if (options.includeRetry) {
    lines.push('');
    lines.push('    let lastError: Error | undefined;');
    lines.push('    for (let attempt = 0; attempt <= this.retry.maxRetries; attempt++) {');
    lines.push('      try {');
    lines.push('        if (attempt > 0) {');
    lines.push('          await this.sleep(this.retry.backoffMs * Math.pow(2, attempt - 1));');
    lines.push('        }');
  }

  lines.push('');
  lines.push('        const response = await fetch(url, {');
  lines.push('          method,');
  lines.push('          headers: this.headers,');
  lines.push('          body: body ? JSON.stringify(body) : undefined,');
  lines.push('          signal: AbortSignal.timeout(this.timeout),');
  lines.push('        });');
  lines.push('');
  lines.push('        if (!response.ok) {');
  lines.push('          const errorBody = await response.json().catch(() => ({}));');
  lines.push('          throw new ApiError(');
  lines.push("            errorBody.code || 'UNKNOWN_ERROR',");
  lines.push("            errorBody.message || response.statusText,");
  lines.push('            response.status,');
  lines.push('            errorBody');
  lines.push('          );');
  lines.push('        }');
  lines.push('');
  lines.push('        const data = await response.json();');

  if (options.includeLogging) {
    lines.push('        this.logger?.debug(`Response ${response.status}`, { data });');
  }

  lines.push('        return data as T;');

  if (options.includeRetry) {
    lines.push('      } catch (error) {');
    lines.push('        lastError = error as Error;');
    lines.push('        if (!this.isRetryable(error)) {');
    lines.push('          throw error;');
    lines.push('        }');
    if (options.includeLogging) {
      lines.push('        this.logger?.debug(`Retry attempt ${attempt + 1}`, { error });');
    }
    lines.push('      }');
    lines.push('    }');
    lines.push('    throw lastError;');
  }

  lines.push('  }');

  if (options.includeRetry) {
    lines.push('');
    lines.push('  private isRetryable(error: unknown): boolean {');
    lines.push('    if (error instanceof ApiError) {');
    lines.push('      return error.status !== undefined && error.status >= 500;');
    lines.push('    }');
    lines.push('    return error instanceof TypeError; // Network errors');
    lines.push('  }');
    lines.push('');
    lines.push('  private sleep(ms: number): Promise<void> {');
    lines.push('    return new Promise(resolve => setTimeout(resolve, ms));');
    lines.push('  }');
  }

  return lines.join('\n');
}

function generateClientMethod(method: ClientMethod, options: GenerateOptions): string {
  const lines: string[] = [];
  const inputParam = method.inputType !== 'void' ? `input: ${method.inputType}` : '';
  const returnType = `Promise<Result<${method.outputType}, ApiError>>`;

  // JSDoc
  if (method.description) {
    lines.push('  /**');
    lines.push(`   * ${method.description}`);
    if (method.errorTypes.length > 0) {
      lines.push('   * @throws ' + method.errorTypes.join(', '));
    }
    lines.push('   */');
  }

  lines.push(`  async ${method.name}(${inputParam}): ${returnType} {`);
  lines.push('    try {');
  lines.push(`      const data = await this.request<${method.outputType}>(`);
  lines.push(`        '${method.httpMethod}',`);
  lines.push(`        '${method.path}'${method.inputType !== 'void' ? ',' : ''}`);
  if (method.inputType !== 'void') {
    lines.push('        input');
  }
  lines.push('      );');
  lines.push('      return { success: true, data };');
  lines.push('    } catch (error) {');
  lines.push('      if (error instanceof ApiError) {');
  lines.push('        return { success: false, error };');
  lines.push('      }');
  lines.push("      return { success: false, error: new ApiError('UNKNOWN', (error as Error).message) };");
  lines.push('    }');
  lines.push('  }');

  return lines.join('\n');
}

/**
 * Generate TypeScript types file (separate from client)
 */
export function generateTypeScriptTypes(types: TypeDefinition[]): string {
  const lines: string[] = [];

  lines.push('// Auto-generated by @isl-lang/codegen-client');
  lines.push('// Do not edit manually');
  lines.push('');

  for (const type of types) {
    lines.push(generateTypeDefinition(type));
    lines.push('');
  }

  return lines.join('\n');
}
