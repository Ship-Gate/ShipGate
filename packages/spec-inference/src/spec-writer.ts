/**
 * Writes inferred spec to .isl-verify/inferred-spec.isl with confidence comments.
 */

import * as fs from 'fs';
import * as path from 'path';
import type {
  InferredSpec,
  InferredEntity,
  InferredEnum,
  InferredEndpoint,
  InferredBehavior,
  InferredActor,
  InferredField,
} from './types.js';

export async function writeInferredSpec(
  spec: InferredSpec,
  outputPath: string
): Promise<void> {
  const dir = path.dirname(outputPath);
  await fs.promises.mkdir(dir, { recursive: true });

  const lines: string[] = [
    '# Auto-generated by ISL Verify Spec Inference Engine',
    '# Confidence: high = explicit types/schemas, medium = usage patterns, low = heuristics',
    '',
    `domain ${spec.domainName} {`,
    '  version: "1.0.0"',
    '',
  ];

  for (const e of spec.enums) {
    lines.push(`  # [${e.confidence}] inferred from ${e.source ?? 'unknown'}`);
    lines.push(`  enum ${e.name} {`);
    for (const m of e.members) {
      lines.push(`    ${m}`);
    }
    lines.push('  }');
    lines.push('');
  }

  for (const entity of spec.entities) {
    lines.push(`  # [${entity.confidence}] inferred from ${entity.source ?? 'unknown'}`);
    lines.push(`  entity ${entity.name} {`);
    for (const field of entity.fields) {
      const fieldLine = formatField(field);
      lines.push(`    ${fieldLine}`);
    }
    if (entity.invariants?.length) {
      lines.push('    invariants {');
      for (const inv of entity.invariants) {
        lines.push(`      - ${inv}`);
      }
      lines.push('    }');
    }
    lines.push('  }');
    lines.push('');
  }

  if (spec.behaviors.length > 0) {
    for (const b of spec.behaviors) {
      lines.push(`  # [${b.confidence}] inferred from ${b.source ?? 'unknown'}`);
      lines.push(`  behavior ${b.name} {`);
      if (b.description) {
        lines.push(`    description: "${escapeString(b.description)}"`);
      }
      lines.push('    input {');
      for (const [k, v] of Object.entries(b.input)) {
        const opt = v.optional ? '?' : '';
        lines.push(`      ${k}: ${v.type}${opt}`);
      }
      lines.push('    }');
      lines.push('    output {');
      lines.push(`      success: ${b.output.success}`);
      if (b.output.errors?.length) {
        lines.push('      errors {');
        for (const err of b.output.errors) {
          lines.push(`        ${err.code} { when: "${escapeString(err.when)}" retriable: ${err.retriable ?? false} }`);
        }
        lines.push('      }');
      }
      lines.push('    }');
      if (b.preconditions?.length) {
        lines.push('    preconditions {');
        for (const p of b.preconditions) {
          lines.push(`      - ${p}`);
        }
        lines.push('    }');
      }
      if (b.postconditions?.length) {
        lines.push('    postconditions {');
        lines.push('      success implies {');
        for (const p of b.postconditions) {
          lines.push(`        - ${p}`);
        }
        lines.push('      }');
        lines.push('    }');
      }
      lines.push('  }');
      lines.push('');
    }
  }

  if (spec.endpoints.length > 0) {
    lines.push('  api {');
    lines.push('    base: "/api"');
    for (const ep of spec.endpoints) {
      lines.push(`    # [${ep.confidence}] inferred from ${ep.source ?? 'unknown'}`);
      const epLine = formatEndpoint(ep);
      lines.push(`    ${epLine}`);
    }
    lines.push('  }');
    lines.push('');
  }

  lines.push('}');

  await fs.promises.writeFile(outputPath, lines.join('\n'), 'utf-8');
}

function formatField(field: InferredField): string {
  const typeStr = field.optional ? `${field.type}?` : field.type;
  const ann = field.annotations?.length
    ? ` [${field.annotations.join(', ')}]`
    : '';
  const constraints = field.constraints
    ? ` { ${Object.entries(field.constraints)
        .map(([k, v]) => `${k}: ${v}`)
        .join(' ')} }`
    : '';
  return `${field.name}: ${typeStr}${ann}${constraints}`;
}

function formatEndpoint(ep: InferredEndpoint): string {
  const pathStr = ep.path.startsWith('/') ? ep.path : `/${ep.path}`;
  const parts: string[] = [`${ep.method} "${pathStr}"`];
  if (ep.behaviorName) parts.push(`-> ${ep.behaviorName}`);
  const opts: string[] = [];
  if (ep.auth && ep.auth !== 'public') opts.push(`auth: ${ep.auth}`);
  if (ep.requestBody) opts.push(`body: ${ep.requestBody}`);
  if (ep.responseType) opts.push(`response: ${ep.responseType}`);
  if (opts.length) parts.push(`{ ${opts.join(' ')} }`);
  return parts.join(' ');
}

function escapeString(s: string): string {
  return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
}
