/**
 * AI Safety Guardrails Tests
 *
 * Tests the four guardrail defaults, override paper trail, and risk acceptance recording.
 */

import { describe, it, expect } from 'vitest';
import {
  applyGuardrails,
  isAutoGeneratedSpec,
  hasAiRuleEvidence,
  findEmptyCategories,
  formatGuardrailWarnings,
} from '../src/authoritative/guardrails.js';
import type {
  AggregatedSignals,
  GuardrailPolicy,
  GuardrailResult,
  VerificationSignal,
} from '../src/authoritative/types.js';
import { DEFAULT_GUARDRAIL_POLICY } from '../src/authoritative/types.js';

// ============================================================================
// Helpers
// ============================================================================

function makeAggregation(overrides: Partial<AggregatedSignals> = {}): AggregatedSignals {
  return {
    signals: [],
    overallScore: 85,
    tests: { total: 0, passed: 0, failed: 0, skipped: 0, passRate: 0 },
    findings: { critical: 0, high: 0, medium: 0, low: 0, total: 0 },
    blockingIssues: [],
    ...overrides,
  };
}

function makeSignal(source: VerificationSignal['source'], passed: boolean): VerificationSignal {
  return {
    source,
    passed,
    summary: `${source} ${passed ? 'passed' : 'failed'}`,
    blocking: !passed,
  };
}

// ============================================================================
// isAutoGeneratedSpec
// ============================================================================

describe('isAutoGeneratedSpec', () => {
  it('returns true when explicit flag is true', () => {
    expect(isAutoGeneratedSpec('domain X version "1"', undefined, true)).toBe(true);
  });

  it('returns false when explicit flag is false', () => {
    expect(isAutoGeneratedSpec('// @generated\ndomain X version "1"', undefined, false)).toBe(false);
  });

  it('detects .shipgate/generated-specs/ path', () => {
    expect(isAutoGeneratedSpec('domain X version "1"', '.shipgate/generated-specs/foo.isl')).toBe(true);
  });

  it('detects windows-style path', () => {
    expect(isAutoGeneratedSpec('domain X version "1"', '.shipgate\\generated-specs\\foo.isl')).toBe(true);
  });

  it('detects @generated marker in source', () => {
    expect(isAutoGeneratedSpec('// @generated\ndomain X version "1"')).toBe(true);
  });

  it('detects @auto-generated marker', () => {
    expect(isAutoGeneratedSpec('// @auto-generated\ndomain X version "1"')).toBe(true);
  });

  it('detects "auto-generated by" marker', () => {
    expect(isAutoGeneratedSpec('// auto-generated by shipgate\ndomain X version "1"')).toBe(true);
  });

  it('returns false for human-authored spec', () => {
    expect(isAutoGeneratedSpec('domain UserService version "1.0"')).toBe(false);
  });
});

// ============================================================================
// hasAiRuleEvidence
// ============================================================================

describe('hasAiRuleEvidence', () => {
  it('returns true when verifier signal passes', () => {
    const agg = makeAggregation({
      signals: [makeSignal('verifier', true)],
    });
    expect(hasAiRuleEvidence(agg)).toBe(true);
  });

  it('returns true when test_runner signal passes', () => {
    const agg = makeAggregation({
      signals: [makeSignal('test_runner', true)],
    });
    expect(hasAiRuleEvidence(agg)).toBe(true);
  });

  it('returns true when contract_check signal passes', () => {
    const agg = makeAggregation({
      signals: [makeSignal('contract_check', true)],
    });
    expect(hasAiRuleEvidence(agg)).toBe(true);
  });

  it('returns false when only parser passes (not a verification source)', () => {
    const agg = makeAggregation({
      signals: [makeSignal('parser', true)],
    });
    expect(hasAiRuleEvidence(agg)).toBe(false);
  });

  it('returns false when verifier fails', () => {
    const agg = makeAggregation({
      signals: [makeSignal('verifier', false)],
    });
    expect(hasAiRuleEvidence(agg)).toBe(false);
  });

  it('returns false with no signals', () => {
    expect(hasAiRuleEvidence(makeAggregation())).toBe(false);
  });
});

// ============================================================================
// findEmptyCategories
// ============================================================================

describe('findEmptyCategories', () => {
  it('returns all expected categories when no signals present', () => {
    const empty = findEmptyCategories(makeAggregation());
    expect(empty).toContain('parser');
    expect(empty).toContain('typechecker');
    expect(empty).toContain('verifier');
    expect(empty).toContain('test_runner');
    expect(empty).toContain('static_analysis');
    expect(empty.length).toBe(5);
  });

  it('returns no empty categories when all expected sources present', () => {
    const agg = makeAggregation({
      signals: [
        makeSignal('parser', true),
        makeSignal('typechecker', true),
        makeSignal('verifier', true),
        makeSignal('test_runner', true),
        makeSignal('static_analysis', true),
      ],
    });
    expect(findEmptyCategories(agg)).toEqual([]);
  });

  it('returns only missing categories', () => {
    const agg = makeAggregation({
      signals: [
        makeSignal('parser', true),
        makeSignal('verifier', true),
      ],
    });
    const empty = findEmptyCategories(agg);
    expect(empty).toContain('typechecker');
    expect(empty).toContain('test_runner');
    expect(empty).toContain('static_analysis');
    expect(empty).not.toContain('parser');
    expect(empty).not.toContain('verifier');
  });
});

// ============================================================================
// applyGuardrails — Guardrail 1: Auto-generated specs → WARN at best
// ============================================================================

describe('applyGuardrails — auto-generated spec cap', () => {
  it('caps verdict at WARN for auto-generated spec with strict defaults', () => {
    const agg = makeAggregation({
      signals: [makeSignal('verifier', true), makeSignal('test_runner', true)],
      tests: { total: 5, passed: 5, failed: 0, skipped: 0, passRate: 100 },
    });
    const result = applyGuardrails(agg, {
      autoGeneratedSpec: true,
    });
    expect(result.verdictCap).toBe('WARN');
    expect(result.reasons.some(r => r.code === 'AUTO_SPEC_WARN_CAP')).toBe(true);
    expect(result.riskAcceptances).toEqual([]);
  });

  it('does not cap when spec is not auto-generated', () => {
    const agg = makeAggregation({
      signals: [makeSignal('verifier', true), makeSignal('test_runner', true)],
      tests: { total: 5, passed: 5, failed: 0, skipped: 0, passRate: 100 },
    });
    const result = applyGuardrails(agg, {
      autoGeneratedSpec: false,
    });
    expect(result.reasons.some(r => r.code === 'AUTO_SPEC_WARN_CAP')).toBe(false);
  });

  it('records risk acceptance when allowAutoSpecShip overrides', () => {
    const agg = makeAggregation({
      signals: [makeSignal('verifier', true), makeSignal('test_runner', true)],
      tests: { total: 5, passed: 5, failed: 0, skipped: 0, passRate: 100 },
    });
    const result = applyGuardrails(agg, {
      autoGeneratedSpec: true,
      policy: { allowAutoSpecShip: true },
      configSource: '/project/.shipgate.yml',
    });
    expect(result.verdictCap).toBeNull();
    expect(result.riskAcceptances.length).toBe(1);
    expect(result.riskAcceptances[0].guardrail).toBe('allowAutoSpecShip');
    expect(result.riskAcceptances[0].displayLabel).toBe('user allowed auto-spec-ship');
    expect(result.riskAcceptances[0].configSource).toBe('/project/.shipgate.yml');
    expect(result.warnings).toContain('⚠ user allowed auto-spec-ship');
  });
});

// ============================================================================
// applyGuardrails — Guardrail 2: No tests executed → NO_SHIP
// ============================================================================

describe('applyGuardrails — no tests executed', () => {
  it('forces NO_SHIP when no tests were executed with strict defaults', () => {
    const agg = makeAggregation({
      signals: [makeSignal('verifier', true)],
      tests: { total: 0, passed: 0, failed: 0, skipped: 0, passRate: 0 },
    });
    const result = applyGuardrails(agg);
    expect(result.verdictCap).toBe('NO_SHIP');
    expect(result.reasons.some(r => r.code === 'NO_TESTS_EXECUTED')).toBe(true);
    expect(result.reasons.find(r => r.code === 'NO_TESTS_EXECUTED')?.blocking).toBe(true);
  });

  it('does not penalize when tests were executed', () => {
    const agg = makeAggregation({
      signals: [makeSignal('verifier', true), makeSignal('test_runner', true)],
      tests: { total: 3, passed: 3, failed: 0, skipped: 0, passRate: 100 },
    });
    const result = applyGuardrails(agg);
    expect(result.reasons.some(r => r.code === 'NO_TESTS_EXECUTED')).toBe(false);
  });

  it('records risk acceptance when allowNoTestExecution overrides', () => {
    const agg = makeAggregation({
      tests: { total: 0, passed: 0, failed: 0, skipped: 0, passRate: 0 },
    });
    const result = applyGuardrails(agg, {
      policy: { allowNoTestExecution: true },
      configSource: '/project/.shipgate.yml',
    });
    expect(result.riskAcceptances.some(r => r.guardrail === 'allowNoTestExecution')).toBe(true);
    expect(result.riskAcceptances.find(r => r.guardrail === 'allowNoTestExecution')?.displayLabel)
      .toBe('user allowed warn-on-exec-failure');
    expect(result.warnings).toContain('⚠ user allowed warn-on-exec-failure');
  });
});

// ============================================================================
// applyGuardrails — Guardrail 3: Empty categories → penalized
// ============================================================================

describe('applyGuardrails — empty categories penalty', () => {
  it('penalizes score for empty categories with strict defaults', () => {
    const agg = makeAggregation({
      signals: [makeSignal('parser', true), makeSignal('test_runner', true)],
      tests: { total: 1, passed: 1, failed: 0, skipped: 0, passRate: 100 },
    });
    const result = applyGuardrails(agg);
    // 3 missing: typechecker, verifier, static_analysis = 30 penalty
    expect(result.scorePenalty).toBe(30);
    expect(result.reasons.some(r => r.code === 'EMPTY_CATEGORIES')).toBe(true);
  });

  it('no penalty when all expected categories present', () => {
    const agg = makeAggregation({
      signals: [
        makeSignal('parser', true),
        makeSignal('typechecker', true),
        makeSignal('verifier', true),
        makeSignal('test_runner', true),
        makeSignal('static_analysis', true),
      ],
      tests: { total: 1, passed: 1, failed: 0, skipped: 0, passRate: 100 },
    });
    const result = applyGuardrails(agg);
    expect(result.reasons.some(r => r.code === 'EMPTY_CATEGORIES')).toBe(false);
    // Only penalty from other guardrails (no AI rule evidence in this case)
    expect(result.scorePenalty).toBeGreaterThanOrEqual(0);
  });

  it('records risk acceptance when allowEmptyCategories overrides', () => {
    const agg = makeAggregation({
      signals: [makeSignal('parser', true)],
      tests: { total: 1, passed: 1, failed: 0, skipped: 0, passRate: 100 },
    });
    const result = applyGuardrails(agg, {
      policy: { allowEmptyCategories: true },
    });
    expect(result.scorePenalty).toBe(0 + 15); // 0 from categories, 15 from unvalidated AI rules
    expect(result.riskAcceptances.some(r => r.guardrail === 'allowEmptyCategories')).toBe(true);
    expect(result.warnings).toContain('⚠ user allowed empty-categories');
  });
});

// ============================================================================
// applyGuardrails — Guardrail 4: AI rules require evidence
// ============================================================================

describe('applyGuardrails — AI rules evidence', () => {
  it('caps verdict at WARN when no verification evidence with strict defaults', () => {
    const agg = makeAggregation({
      signals: [makeSignal('parser', true), makeSignal('static_analysis', true)],
      tests: { total: 1, passed: 1, failed: 0, skipped: 0, passRate: 100 },
    });
    const result = applyGuardrails(agg);
    expect(result.reasons.some(r => r.code === 'UNVALIDATED_AI_RULES')).toBe(true);
    // verdictCap should be WARN (or NO_SHIP if other guardrails forced it)
    const capOrder: Record<string, number> = { 'NO_SHIP': 0, 'WARN': 1, 'SHIP': 2 };
    expect(capOrder[result.verdictCap!]).toBeLessThanOrEqual(1); // WARN or NO_SHIP
  });

  it('adds 15 score penalty for unvalidated AI rules', () => {
    const agg = makeAggregation({
      signals: [makeSignal('parser', true), makeSignal('static_analysis', true)],
      tests: { total: 1, passed: 1, failed: 0, skipped: 0, passRate: 100 },
    });
    const result = applyGuardrails(agg);
    // Score penalty includes both empty categories + AI rules
    expect(result.scorePenalty).toBeGreaterThanOrEqual(15);
  });

  it('no penalty when verifier passes (has evidence)', () => {
    const agg = makeAggregation({
      signals: [
        makeSignal('parser', true),
        makeSignal('typechecker', true),
        makeSignal('verifier', true),
        makeSignal('test_runner', true),
        makeSignal('static_analysis', true),
      ],
      tests: { total: 5, passed: 5, failed: 0, skipped: 0, passRate: 100 },
    });
    const result = applyGuardrails(agg);
    expect(result.reasons.some(r => r.code === 'UNVALIDATED_AI_RULES')).toBe(false);
  });

  it('records risk acceptance when allowUnvalidatedAiRules overrides', () => {
    const agg = makeAggregation({
      signals: [makeSignal('parser', true)],
      tests: { total: 1, passed: 1, failed: 0, skipped: 0, passRate: 100 },
    });
    const result = applyGuardrails(agg, {
      policy: { allowUnvalidatedAiRules: true },
    });
    expect(result.riskAcceptances.some(r => r.guardrail === 'allowUnvalidatedAiRules')).toBe(true);
    expect(result.warnings).toContain('⚠ user allowed unvalidated-ai-rules');
  });
});

// ============================================================================
// applyGuardrails — Multiple overrides = multiple risk acceptances
// ============================================================================

describe('applyGuardrails — multiple overrides', () => {
  it('records all risk acceptances when multiple guardrails overridden', () => {
    const agg = makeAggregation({
      signals: [],
      tests: { total: 0, passed: 0, failed: 0, skipped: 0, passRate: 0 },
    });
    const result = applyGuardrails(agg, {
      autoGeneratedSpec: true,
      policy: {
        allowAutoSpecShip: true,
        allowNoTestExecution: true,
        allowEmptyCategories: true,
        allowUnvalidatedAiRules: true,
      },
      configSource: '/my/.shipgate.yml',
    });

    expect(result.riskAcceptances.length).toBe(4);
    expect(result.riskAcceptances.every(r => r.configSource === '/my/.shipgate.yml')).toBe(true);
    expect(result.riskAcceptances.every(r => r.timestamp.length > 0)).toBe(true);
    expect(result.warnings.length).toBe(4);
  });
});

// ============================================================================
// applyGuardrails — Default strict policy
// ============================================================================

describe('DEFAULT_GUARDRAIL_POLICY', () => {
  it('has all guardrails enforced by default', () => {
    expect(DEFAULT_GUARDRAIL_POLICY.allowAutoSpecShip).toBe(false);
    expect(DEFAULT_GUARDRAIL_POLICY.allowNoTestExecution).toBe(false);
    expect(DEFAULT_GUARDRAIL_POLICY.allowEmptyCategories).toBe(false);
    expect(DEFAULT_GUARDRAIL_POLICY.allowUnvalidatedAiRules).toBe(false);
  });
});

// ============================================================================
// formatGuardrailWarnings
// ============================================================================

describe('formatGuardrailWarnings', () => {
  it('returns empty array when no warnings', () => {
    const result: GuardrailResult = {
      reasons: [],
      verdictCap: null,
      scorePenalty: 0,
      riskAcceptances: [],
      warnings: [],
    };
    expect(formatGuardrailWarnings(result)).toEqual([]);
  });

  it('returns all warning labels', () => {
    const result: GuardrailResult = {
      reasons: [],
      verdictCap: null,
      scorePenalty: 0,
      riskAcceptances: [],
      warnings: [
        '⚠ user allowed auto-spec-ship',
        '⚠ user allowed warn-on-exec-failure',
      ],
    };
    expect(formatGuardrailWarnings(result)).toEqual([
      '⚠ user allowed auto-spec-ship',
      '⚠ user allowed warn-on-exec-failure',
    ]);
  });
});

// ============================================================================
// applyGuardrails — Verdict cap stacking (strictest wins)
// ============================================================================

describe('applyGuardrails — verdict cap stacking', () => {
  it('NO_SHIP cap wins over WARN cap', () => {
    // Auto-spec → WARN cap, no tests → NO_SHIP cap; NO_SHIP should win
    const agg = makeAggregation({
      signals: [makeSignal('verifier', true)],
      tests: { total: 0, passed: 0, failed: 0, skipped: 0, passRate: 0 },
    });
    const result = applyGuardrails(agg, {
      autoGeneratedSpec: true,
    });
    expect(result.verdictCap).toBe('NO_SHIP');
  });
});

// ============================================================================
// Risk acceptance audit trail
// ============================================================================

describe('Risk acceptance audit trail', () => {
  it('includes ISO 8601 timestamp', () => {
    const agg = makeAggregation({
      tests: { total: 0, passed: 0, failed: 0, skipped: 0, passRate: 0 },
    });
    const result = applyGuardrails(agg, {
      policy: { allowNoTestExecution: true },
    });
    const ra = result.riskAcceptances[0];
    expect(ra.timestamp).toMatch(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/);
  });

  it('records configSource as null when no config file', () => {
    const agg = makeAggregation({
      tests: { total: 0, passed: 0, failed: 0, skipped: 0, passRate: 0 },
    });
    const result = applyGuardrails(agg, {
      policy: { allowNoTestExecution: true },
    });
    expect(result.riskAcceptances[0].configSource).toBeNull();
  });

  it('records configSource when provided', () => {
    const agg = makeAggregation({
      tests: { total: 0, passed: 0, failed: 0, skipped: 0, passRate: 0 },
    });
    const result = applyGuardrails(agg, {
      policy: { allowNoTestExecution: true },
      configSource: '/project/.shipgate.yml',
    });
    expect(result.riskAcceptances[0].configSource).toBe('/project/.shipgate.yml');
  });
});
