/**
 * AI Safety Guardrails
 *
 * Enforces strict defaults for shipping safe AI code:
 *   1. Auto-generated specs → WARN at best until human-validated
 *   2. No tests executed → NO_SHIP
 *   3. Empty verification categories → penalized
 *   4. AI-generated rules require evidence and validation
 *
 * Overrides are allowed via .shipgate.yml but always leave a paper trail:
 *   - Display label printed in CLI output
 *   - RiskAcceptance entry recorded in proof bundle metadata
 *
 * @module @isl-lang/gate/authoritative/guardrails
 */

import type {
  GuardrailPolicy,
  GuardrailResult,
  RiskAcceptance,
  VerdictReason,
  AggregatedSignals,
  SignalSource,
} from './types.js';

import { DEFAULT_GUARDRAIL_POLICY } from './types.js';

// ============================================================================
// Constants
// ============================================================================

/** Score penalty for each empty verification category */
const EMPTY_CATEGORY_PENALTY = 10;

/** Minimum number of signal sources expected for full coverage */
const EXPECTED_SIGNAL_SOURCES: readonly SignalSource[] = [
  'parser',
  'typechecker',
  'verifier',
  'test_runner',
  'static_analysis',
];

/** Auto-generated spec markers (in file path or ISL comment) */
const AUTO_SPEC_MARKERS = [
  '.shipgate/generated-specs/',
  '.shipgate\\generated-specs\\',
  '@generated',
  '@auto-generated',
  'auto-generated by',
  '# status: incomplete',
];

/** Score penalty for INCOMPLETE specs (no business rules) */
const INCOMPLETE_SPEC_PENALTY = 20;

/** Markers that indicate a spec is INCOMPLETE (typed scaffold only, no rules) */
const INCOMPLETE_SPEC_MARKERS = [
  '# status: incomplete',
  'incomplete — auto-generated typed contract scaffold',
  'this spec captures exact signatures but has no business rules',
];

// ============================================================================
// Spec Origin Detection
// ============================================================================

/**
 * Detect whether a spec is auto-generated (not human-validated).
 *
 * Checks:
 *   - Explicit `autoGeneratedSpec` flag from caller
 *   - Spec path inside `.shipgate/generated-specs/`
 *   - `@generated` / `@auto-generated` marker in spec source
 */
export function isAutoGeneratedSpec(
  specSource: string,
  specPath?: string,
  explicitFlag?: boolean,
): boolean {
  if (explicitFlag === true) return true;
  if (explicitFlag === false) return false;

  // Check path
  if (specPath) {
    const normalizedPath = specPath.replace(/\\/g, '/');
    if (
      normalizedPath.includes('.shipgate/generated-specs/') ||
      normalizedPath.includes('.shipgate/generated-specs\\')
    ) {
      return true;
    }
  }

  // Check spec source for markers (first 500 chars — markers are typically at the top)
  const header = specSource.slice(0, 500).toLowerCase();
  return AUTO_SPEC_MARKERS.some(marker => header.includes(marker.toLowerCase()));
}

// ============================================================================
// AI Rule Evidence Detection
// ============================================================================

/**
 * Check whether AI-generated rules have supporting evidence.
 *
 * Evidence means:
 *   - At least one 'pass' result from 'verifier' or 'test_runner'
 *   - Or at least one 'isl-spec' evidence with result 'pass'
 *
 * Without this, AI rules are unvalidated assertions.
 */
export function hasAiRuleEvidence(aggregation: AggregatedSignals): boolean {
  // Need at least one passing signal from a verification source
  const verificationSources: SignalSource[] = ['verifier', 'test_runner', 'contract_check'];
  return aggregation.signals.some(
    s => verificationSources.includes(s.source) && s.passed,
  );
}

// ============================================================================
// Empty Category Detection
// ============================================================================

/**
 * Find verification categories that have no signals (empty).
 * Each missing expected source is an empty category.
 */
export function findEmptyCategories(aggregation: AggregatedSignals): SignalSource[] {
  const presentSources = new Set(aggregation.signals.map(s => s.source));
  return EXPECTED_SIGNAL_SOURCES.filter(src => !presentSources.has(src)) as SignalSource[];
}

// ============================================================================
// Main Guardrail Application
// ============================================================================

/**
 * Apply guardrails to an aggregation and produce guardrail results.
 *
 * This does NOT mutate the aggregation — it returns additional reasons,
 * score penalties, verdict caps, and risk acceptances for the caller
 * to merge into the final decision.
 */
export function applyGuardrails(
  aggregation: AggregatedSignals,
  opts: {
    policy?: Partial<GuardrailPolicy>;
    autoGeneratedSpec?: boolean;
    specSource?: string;
    specPath?: string;
    configSource?: string | null;
  } = {},
): GuardrailResult {
  const policy: GuardrailPolicy = {
    ...DEFAULT_GUARDRAIL_POLICY,
    ...opts.policy,
  };
  const configSource = opts.configSource ?? null;
  const now = new Date().toISOString();

  const reasons: VerdictReason[] = [];
  const riskAcceptances: RiskAcceptance[] = [];
  const warnings: string[] = [];
  let verdictCap: GuardrailResult['verdictCap'] = null;
  let scorePenalty = 0;

  // ── Guardrail 1: Auto-generated specs → WARN at best ──────────────────
  const isAutoSpec = isAutoGeneratedSpec(
    opts.specSource ?? '',
    opts.specPath,
    opts.autoGeneratedSpec,
  );

  if (isAutoSpec) {
    if (!policy.allowAutoSpecShip) {
      // Enforce: cap verdict at WARN
      verdictCap = capVerdict(verdictCap, 'WARN');
      reasons.push({
        code: 'AUTO_SPEC_WARN_CAP',
        message: 'Auto-generated spec detected — verdict capped at WARN until spec is human-validated',
        severity: 'high',
        source: 'verifier',
        blocking: false,
      });
    } else {
      // Override active: record risk acceptance
      riskAcceptances.push({
        guardrail: 'allowAutoSpecShip',
        description: 'Auto-generated spec allowed to reach SHIP without human validation',
        displayLabel: 'user allowed auto-spec-ship',
        timestamp: now,
        configSource,
      });
      warnings.push('⚠ user allowed auto-spec-ship');
    }
  }

  // ── Guardrail 2: No tests executed → NO_SHIP ─────────────────────────
  const noTestsExecuted = aggregation.tests.total === 0;

  if (noTestsExecuted) {
    if (!policy.allowNoTestExecution) {
      // Enforce: force NO_SHIP
      verdictCap = capVerdict(verdictCap, 'NO_SHIP');
      reasons.push({
        code: 'NO_TESTS_EXECUTED',
        message: 'No tests were executed — NO_SHIP (tests are required for safe AI code)',
        severity: 'critical',
        source: 'test_runner',
        blocking: true,
      });
    } else {
      // Override active: record risk acceptance
      riskAcceptances.push({
        guardrail: 'allowNoTestExecution',
        description: 'Shipping without test execution allowed',
        displayLabel: 'user allowed warn-on-exec-failure',
        timestamp: now,
        configSource,
      });
      warnings.push('⚠ user allowed warn-on-exec-failure');
    }
  }

  // ── Guardrail 3: Empty categories → penalized ────────────────────────
  const emptyCategories = findEmptyCategories(aggregation);

  if (emptyCategories.length > 0) {
    if (!policy.allowEmptyCategories) {
      // Enforce: penalize score per empty category
      const penalty = emptyCategories.length * EMPTY_CATEGORY_PENALTY;
      scorePenalty += penalty;
      reasons.push({
        code: 'EMPTY_CATEGORIES',
        message: `${emptyCategories.length} verification category(ies) empty: ${emptyCategories.join(', ')} — score penalized by ${penalty}`,
        severity: 'medium',
        source: 'verifier',
        blocking: false,
      });
    } else {
      // Override active: record risk acceptance
      riskAcceptances.push({
        guardrail: 'allowEmptyCategories',
        description: `Empty verification categories allowed: ${emptyCategories.join(', ')}`,
        displayLabel: 'user allowed empty-categories',
        timestamp: now,
        configSource,
      });
      warnings.push('⚠ user allowed empty-categories');
    }
  }

  // ── Guardrail 5: INCOMPLETE specs (no business rules) → penalized ────
  const isIncompleteSpec = isIncompleteSpecCheck(opts.specSource ?? '');

  if (isIncompleteSpec) {
    scorePenalty += INCOMPLETE_SPEC_PENALTY;
    verdictCap = capVerdict(verdictCap, 'WARN');
    reasons.push({
      code: 'INCOMPLETE_SPEC',
      message: `INCOMPLETE spec detected — typed contract scaffold only, no business rules. Score penalized by ${INCOMPLETE_SPEC_PENALTY}, verdict capped at WARN.`,
      severity: 'high',
      source: 'verifier',
      blocking: false,
    });
  }

  // ── Guardrail 4: AI rules require evidence ────────────────────────────
  const hasEvidence = hasAiRuleEvidence(aggregation);

  if (!hasEvidence) {
    if (!policy.allowUnvalidatedAiRules) {
      // Enforce: cap at WARN and penalize
      verdictCap = capVerdict(verdictCap, 'WARN');
      scorePenalty += 15;
      reasons.push({
        code: 'UNVALIDATED_AI_RULES',
        message: 'AI-generated rules have no supporting evidence (no passing verifier/test signals) — verdict capped at WARN',
        severity: 'high',
        source: 'verifier',
        blocking: false,
      });
    } else {
      // Override active: record risk acceptance
      riskAcceptances.push({
        guardrail: 'allowUnvalidatedAiRules',
        description: 'AI-generated rules allowed without evidence validation',
        displayLabel: 'user allowed unvalidated-ai-rules',
        timestamp: now,
        configSource,
      });
      warnings.push('⚠ user allowed unvalidated-ai-rules');
    }
  }

  return {
    reasons,
    verdictCap,
    scorePenalty,
    riskAcceptances,
    warnings,
  };
}

// ============================================================================
// Helpers
// ============================================================================

/**
 * Cap a verdict to a stricter level.
 * NO_SHIP < WARN < SHIP
 */
function capVerdict(
  current: GuardrailResult['verdictCap'],
  newCap: 'SHIP' | 'WARN' | 'NO_SHIP',
): GuardrailResult['verdictCap'] {
  const order: Record<string, number> = { 'NO_SHIP': 0, 'WARN': 1, 'SHIP': 2 };
  if (current === null) return newCap;
  return order[newCap] <= order[current] ? newCap : current;
}

/**
 * Detect whether a spec is INCOMPLETE (auto-generated typed scaffold with no business rules).
 */
export function isIncompleteSpecCheck(specSource: string): boolean {
  const header = specSource.slice(0, 500).toLowerCase();
  return INCOMPLETE_SPEC_MARKERS.some(marker => header.includes(marker));
}

/**
 * Format risk acceptances for CLI display output.
 * Returns lines like: "⚠ user allowed warn-on-exec-failure"
 */
export function formatGuardrailWarnings(result: GuardrailResult): string[] {
  return result.warnings;
}
