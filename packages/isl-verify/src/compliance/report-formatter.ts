/**
 * Compliance Report Formatters
 * 
 * Formats compliance reports as Markdown, HTML, or PDF
 */

import type { ComplianceReport, ComplianceControl, ExecutiveSummary } from './compliance-report-generator.js';

export type ReportFormat = 'markdown' | 'html' | 'json';

/**
 * Format compliance report as Markdown
 */
export function formatMarkdownReport(report: ComplianceReport): string {
  const lines: string[] = [];

  // Header
  lines.push(`# ${report.framework.toUpperCase()} Compliance Evidence ‚Äî ISL Verify`);
  lines.push('');
  lines.push(`**Project:** ${report.projectName}`);
  lines.push(`**Generated:** ${new Date(report.generatedAt).toLocaleString()}`);
  if (report.proofBundleId) {
    lines.push(`**Proof Bundle ID:** ${report.proofBundleId.slice(0, 16)}...`);
  }
  lines.push(`**Framework Version:** ${report.frameworkVersion}`);
  lines.push(`**Tool Version:** ${report.toolVersion}`);
  lines.push('');
  lines.push('---');
  lines.push('');

  // Executive Summary
  lines.push('## Executive Summary');
  lines.push('');
  lines.push(formatExecutiveSummary(report.executiveSummary));
  lines.push('');

  // Overall Status Badge
  const statusEmoji = getStatusEmoji(report.executiveSummary.overallStatus);
  lines.push(`**Overall Compliance Status:** ${statusEmoji} **${report.executiveSummary.overallStatus.toUpperCase()}**`);
  lines.push('');

  if (report.executiveSummary.criticalGaps > 0) {
    lines.push(`‚ö†Ô∏è **${report.executiveSummary.criticalGaps} Critical Gap(s) Require Immediate Attention**`);
    lines.push('');
  }

  lines.push('---');
  lines.push('');

  // Controls
  lines.push('## Control Evidence');
  lines.push('');

  // Group controls by category
  const controlsByCategory = groupByCategory(report.controls);

  for (const [category, controls] of Object.entries(controlsByCategory)) {
    lines.push(`### ${category}`);
    lines.push('');

    for (const control of controls) {
      lines.push(formatControl(control));
      lines.push('');
    }
  }

  // Footer
  lines.push('---');
  lines.push('');
  lines.push('## About This Report');
  lines.push('');
  lines.push('This compliance evidence report was automatically generated by **ISL Verify**, a formal verification tool that proves security and correctness properties in code.');
  lines.push('');
  lines.push('**How to use this report:**');
  lines.push('- Share with auditors as evidence of control implementation');
  lines.push('- Reference proof bundle ID for verification');
  lines.push('- Address remediation items before audit');
  lines.push('- Re-run ISL Verify after fixes to update compliance status');
  lines.push('');
  lines.push('**Verification Methods Used:**');
  lines.push('- Static AST Analysis: Code structure and patterns');
  lines.push('- TypeScript Compiler Validation: Type safety verification');
  lines.push('- Pattern Matching: Security vulnerability detection');
  lines.push('- Runtime HTTP Tests: Behavioral verification');
  lines.push('');

  return lines.join('\n');
}

/**
 * Format executive summary
 */
function formatExecutiveSummary(summary: ExecutiveSummary): string {
  const lines: string[] = [];

  lines.push(`| Metric | Count |`);
  lines.push(`|--------|-------|`);
  lines.push(`| Total Controls | ${summary.totalControls} |`);
  lines.push(`| ‚úÖ Compliant | ${summary.compliantControls} |`);
  lines.push(`| ‚ö†Ô∏è Partial | ${summary.partialControls} |`);
  lines.push(`| ‚ùå Non-Compliant | ${summary.nonCompliantControls} |`);
  lines.push(`| ‚ûñ Not Applicable | ${summary.notApplicableControls} |`);
  lines.push(`| üî¥ Critical Gaps | ${summary.criticalGaps} |`);
  lines.push(`| üü† High Priority Gaps | ${summary.highPriorityGaps} |`);

  return lines.join('\n');
}

/**
 * Format individual control
 */
function formatControl(control: ComplianceControl): string {
  const lines: string[] = [];

  const statusEmoji = getControlStatusEmoji(control.status);
  const riskBadge = getRiskBadge(control.riskLevel);

  lines.push(`#### ${control.controlId} ‚Äî ${control.controlName}`);
  lines.push('');
  lines.push(`**Status:** ${statusEmoji} ${control.status.toUpperCase()} ${riskBadge}`);
  lines.push('');
  lines.push(`**Description:** ${control.description}`);
  lines.push('');

  // Evidence
  if (control.evidence.length > 0) {
    lines.push('**Evidence:**');
    lines.push('');
    for (const evidence of control.evidence) {
      const evidenceStatus = getEvidenceStatusSymbol(evidence.propertyStatus);
      lines.push(`${evidenceStatus} **${evidence.propertyName}** ‚Äî ${evidence.summary}`);
      lines.push(`  - Method: ${evidence.method}`);
      lines.push(`  - Confidence: ${evidence.confidence}`);
      lines.push(`  - Evidence Count: ${evidence.evidenceCount} item(s)`);
      if (evidence.proofBundleRef) {
        lines.push(`  - Proof Reference: \`${evidence.proofBundleRef}\``);
      }
      lines.push('');
    }
  } else {
    lines.push('**Evidence:** No verification evidence available for this control.');
    lines.push('');
  }

  // Remediation
  if (control.remediation) {
    lines.push('**Remediation Required:**');
    lines.push('');
    lines.push(control.remediation);
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Format compliance report as HTML
 */
export function formatHtmlReport(report: ComplianceReport): string {
  const markdown = formatMarkdownReport(report);
  
  // Convert markdown to HTML (basic conversion)
  let html = markdown
    .replace(/^# (.*?)$/gm, '<h1>$1</h1>')
    .replace(/^## (.*?)$/gm, '<h2>$1</h2>')
    .replace(/^### (.*?)$/gm, '<h3>$1</h3>')
    .replace(/^#### (.*?)$/gm, '<h4>$1</h4>')
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.*?)\*/g, '<em>$1</em>')
    .replace(/`(.*?)`/g, '<code>$1</code>')
    .replace(/^---$/gm, '<hr>')
    .replace(/^\| (.*?) \|$/gm, (match) => {
      const cells = match.split('|').filter(s => s.trim());
      return '<tr>' + cells.map(c => `<td>${c.trim()}</td>`).join('') + '</tr>';
    });

  // Wrap in HTML document
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${report.framework.toUpperCase()} Compliance Report - ${report.projectName}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      line-height: 1.6;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      background: white;
      padding: 40px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    h1 {
      color: #2c3e50;
      border-bottom: 3px solid #3498db;
      padding-bottom: 10px;
    }
    h2 {
      color: #34495e;
      margin-top: 30px;
      border-bottom: 2px solid #ecf0f1;
      padding-bottom: 8px;
    }
    h3 {
      color: #7f8c8d;
      margin-top: 25px;
    }
    h4 {
      color: #2c3e50;
      margin-top: 20px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }
    td {
      padding: 10px;
      border: 1px solid #ddd;
    }
    code {
      background: #f4f4f4;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }
    .status-compliant { color: #27ae60; font-weight: bold; }
    .status-partial { color: #f39c12; font-weight: bold; }
    .status-non-compliant { color: #e74c3c; font-weight: bold; }
    .risk-critical { 
      background: #e74c3c; 
      color: white; 
      padding: 2px 8px; 
      border-radius: 4px; 
      font-size: 0.85em;
      margin-left: 8px;
    }
    .risk-high { 
      background: #f39c12; 
      color: white; 
      padding: 2px 8px; 
      border-radius: 4px; 
      font-size: 0.85em;
      margin-left: 8px;
    }
    .risk-medium { 
      background: #3498db; 
      color: white; 
      padding: 2px 8px; 
      border-radius: 4px; 
      font-size: 0.85em;
      margin-left: 8px;
    }
    .evidence-item {
      background: #f9f9f9;
      padding: 12px;
      margin: 10px 0;
      border-left: 4px solid #3498db;
      border-radius: 4px;
    }
    .remediation {
      background: #fff3cd;
      border-left: 4px solid #ffc107;
      padding: 15px;
      margin: 15px 0;
      border-radius: 4px;
    }
    .footer {
      margin-top: 40px;
      padding-top: 20px;
      border-top: 1px solid #ecf0f1;
      color: #7f8c8d;
      font-size: 0.9em;
    }
  </style>
</head>
<body>
  <div class="container">
    ${html}
  </div>
  <div class="footer">
    <p>Generated by ISL Verify - Formal Verification for Production Code</p>
  </div>
</body>
</html>`;
}

/**
 * Format compliance report as JSON
 */
export function formatJsonReport(report: ComplianceReport): string {
  return JSON.stringify(report, null, 2);
}

/**
 * Helper: Get status emoji
 */
function getStatusEmoji(status: string): string {
  switch (status) {
    case 'compliant':
      return '‚úÖ';
    case 'partial':
      return '‚ö†Ô∏è';
    case 'non-compliant':
      return '‚ùå';
    default:
      return '‚ùì';
  }
}

/**
 * Helper: Get control status emoji
 */
function getControlStatusEmoji(status: string): string {
  switch (status) {
    case 'compliant':
      return '‚úÖ';
    case 'partial':
      return '‚ö†Ô∏è';
    case 'non-compliant':
      return '‚ùå';
    case 'not-applicable':
      return '‚ûñ';
    default:
      return '‚ùì';
  }
}

/**
 * Helper: Get evidence status symbol
 */
function getEvidenceStatusSymbol(status: string): string {
  switch (status) {
    case 'PROVEN':
      return '‚úì';
    case 'PARTIAL':
      return '‚óê';
    case 'FAILED':
      return '‚úó';
    case 'NOT_VERIFIED':
      return '‚óã';
    default:
      return '?';
  }
}

/**
 * Helper: Get risk badge
 */
function getRiskBadge(risk: string): string {
  switch (risk) {
    case 'critical':
      return 'üî¥ CRITICAL';
    case 'high':
      return 'üü† HIGH';
    case 'medium':
      return 'üü° MEDIUM';
    case 'low':
      return 'üü¢ LOW';
    default:
      return '';
  }
}

/**
 * Helper: Group controls by category
 */
function groupByCategory(controls: ComplianceControl[]): Record<string, ComplianceControl[]> {
  const grouped: Record<string, ComplianceControl[]> = {};
  
  for (const control of controls) {
    if (!grouped[control.category]) {
      grouped[control.category] = [];
    }
    grouped[control.category].push(control);
  }
  
  return grouped;
}
