// ============================================================================
// Python SDK Generator
// ============================================================================

import type { Domain, Entity, Behavior, SDKOptions, GeneratedFile, Field } from '../types';

export function generatePython(domain: Domain, options: SDKOptions): GeneratedFile[] {
  const files: GeneratedFile[] = [];
  const { outputDir, packageName = domain.name.toLowerCase(), baseUrl = 'http://localhost:3000' } = options;

  // Models file
  files.push({
    path: `${outputDir}/${packageName}/models.py`,
    content: generateModels(domain),
  });

  // Client file
  files.push({
    path: `${outputDir}/${packageName}/client.py`,
    content: generateClient(domain, baseUrl),
  });

  // __init__.py
  files.push({
    path: `${outputDir}/${packageName}/__init__.py`,
    content: generateInit(domain),
  });

  // pyproject.toml
  files.push({
    path: `${outputDir}/pyproject.toml`,
    content: generatePyproject(domain, packageName),
  });

  // README
  files.push({
    path: `${outputDir}/README.md`,
    content: generateReadme(domain, packageName),
  });

  return files;
}

function generateModels(domain: Domain): string {
  const lines: string[] = [];

  lines.push('"""');
  lines.push(`${domain.name} SDK Models`);
  lines.push('Generated from ISL specification');
  lines.push('"""');
  lines.push('');
  lines.push('from __future__ import annotations');
  lines.push('from dataclasses import dataclass, field');
  lines.push('from typing import Optional, List, Dict, Any, TypeVar, Generic');
  lines.push('from datetime import datetime');
  lines.push('from uuid import UUID');
  lines.push('from decimal import Decimal');
  lines.push('from enum import Enum');
  lines.push('');

  // Type aliases
  lines.push('# Type Aliases');
  for (const type of domain.types) {
    lines.push(`${type.name} = ${mapISLToPython(type.baseType)}`);
  }
  if (domain.types.length > 0) lines.push('');

  // Entity classes
  for (const entity of domain.entities) {
    lines.push('@dataclass');
    lines.push(`class ${entity.name}:`);
    lines.push(`    """${entity.name} entity."""`);
    for (const f of entity.fields) {
      const pyType = mapISLToPython(f.type);
      const default_val = f.optional ? ' = None' : '';
      lines.push(`    ${toSnakeCase(f.name)}: ${f.optional ? `Optional[${pyType}]` : pyType}${default_val}`);
    }
    lines.push('');

    // Create input
    lines.push('@dataclass');
    lines.push(`class Create${entity.name}Input:`);
    lines.push(`    """Input for creating ${entity.name}."""`);
    const createFields = entity.fields.filter(f => !isAutoGenerated(f));
    if (createFields.length === 0) {
      lines.push('    pass');
    } else {
      for (const f of createFields) {
        const pyType = mapISLToPython(f.type);
        const default_val = f.optional ? ' = None' : '';
        lines.push(`    ${toSnakeCase(f.name)}: ${f.optional ? `Optional[${pyType}]` : pyType}${default_val}`);
      }
    }
    lines.push('');

    // Update input
    lines.push('@dataclass');
    lines.push(`class Update${entity.name}Input:`);
    lines.push(`    """Input for updating ${entity.name}."""`);
    if (createFields.length === 0) {
      lines.push('    pass');
    } else {
      for (const f of createFields) {
        const pyType = mapISLToPython(f.type);
        lines.push(`    ${toSnakeCase(f.name)}: Optional[${pyType}] = None`);
      }
    }
    lines.push('');
  }

  // Behavior inputs
  for (const behavior of domain.behaviors) {
    if (behavior.inputs.length > 0) {
      lines.push('@dataclass');
      lines.push(`class ${behavior.name}Input:`);
      lines.push(`    """Input for ${behavior.name} behavior."""`);
      for (const input of behavior.inputs) {
        const pyType = mapISLToPython(input.type);
        const default_val = input.optional ? ' = None' : '';
        lines.push(`    ${toSnakeCase(input.name)}: ${input.optional ? `Optional[${pyType}]` : pyType}${default_val}`);
      }
      lines.push('');
    }

    // Error enum
    if (behavior.errors.length > 0) {
      lines.push(`class ${behavior.name}Error(Enum):`);
      lines.push(`    """Possible errors for ${behavior.name}."""`);
      for (const error of behavior.errors) {
        lines.push(`    ${toScreamingSnake(error)} = "${error}"`);
      }
      lines.push('');
    }
  }

  // Response types
  lines.push('T = TypeVar("T")');
  lines.push('');
  lines.push('@dataclass');
  lines.push('class ApiResponse(Generic[T]):');
  lines.push('    """Generic API response."""');
  lines.push('    success: bool');
  lines.push('    data: Optional[T] = None');
  lines.push('    error: Optional[Dict[str, str]] = None');
  lines.push('');

  lines.push('@dataclass');
  lines.push('class PaginatedResponse(Generic[T]):');
  lines.push('    """Paginated response."""');
  lines.push('    items: List[T]');
  lines.push('    total: int');
  lines.push('    page: int');
  lines.push('    page_size: int');
  lines.push('    has_more: bool');

  return lines.join('\n');
}

function generateClient(domain: Domain, baseUrl: string): string {
  const lines: string[] = [];

  lines.push('"""');
  lines.push(`${domain.name} SDK Client`);
  lines.push('Generated from ISL specification');
  lines.push('"""');
  lines.push('');
  lines.push('from __future__ import annotations');
  lines.push('from typing import Optional, Dict, Any, TypeVar, Type');
  lines.push('from dataclasses import asdict');
  lines.push('import json');
  lines.push('');
  lines.push('try:');
  lines.push('    import httpx');
  lines.push('    HAS_HTTPX = True');
  lines.push('except ImportError:');
  lines.push('    HAS_HTTPX = False');
  lines.push('    import urllib.request');
  lines.push('    import urllib.error');
  lines.push('');
  lines.push('from .models import (');
  lines.push('    ApiResponse,');
  lines.push('    PaginatedResponse,');
  for (const entity of domain.entities) {
    lines.push(`    ${entity.name},`);
    lines.push(`    Create${entity.name}Input,`);
    lines.push(`    Update${entity.name}Input,`);
  }
  for (const behavior of domain.behaviors) {
    if (behavior.inputs.length > 0) {
      lines.push(`    ${behavior.name}Input,`);
    }
  }
  lines.push(')');
  lines.push('');

  lines.push('T = TypeVar("T")');
  lines.push('');

  lines.push(`class ${domain.name}Client:`);
  lines.push(`    """${domain.name} API Client."""`);
  lines.push('');
  lines.push('    def __init__(');
  lines.push('        self,');
  lines.push(`        base_url: str = "${baseUrl}",`);
  lines.push('        headers: Optional[Dict[str, str]] = None,');
  lines.push('    ):');
  lines.push('        self.base_url = base_url.rstrip("/")');
  lines.push('        self.headers = {"Content-Type": "application/json", **(headers or {})}');
  lines.push('        self._client = httpx.Client() if HAS_HTTPX else None');
  lines.push('');

  lines.push('    def _request(');
  lines.push('        self,');
  lines.push('        method: str,');
  lines.push('        path: str,');
  lines.push('        body: Optional[Any] = None,');
  lines.push('    ) -> Dict[str, Any]:');
  lines.push('        """Make HTTP request."""');
  lines.push('        url = f"{self.base_url}{path}"');
  lines.push('        data = json.dumps(body) if body else None');
  lines.push('');
  lines.push('        if HAS_HTTPX and self._client:');
  lines.push('            response = self._client.request(');
  lines.push('                method=method,');
  lines.push('                url=url,');
  lines.push('                headers=self.headers,');
  lines.push('                content=data,');
  lines.push('            )');
  lines.push('            return response.json()');
  lines.push('        else:');
  lines.push('            req = urllib.request.Request(');
  lines.push('                url,');
  lines.push('                data=data.encode() if data else None,');
  lines.push('                headers=self.headers,');
  lines.push('                method=method,');
  lines.push('            )');
  lines.push('            with urllib.request.urlopen(req) as response:');
  lines.push('                return json.loads(response.read().decode())');
  lines.push('');

  // Entity methods
  for (const entity of domain.entities) {
    const name = entity.name;
    const nameLower = toSnakeCase(name);
    const endpoint = `/api/${toKebabCase(name)}s`;

    lines.push(`    # ${name} Operations`);
    lines.push('');

    // Get
    lines.push(`    def get_${nameLower}(self, id: str) -> ApiResponse[${name}]:`);
    lines.push(`        """Get ${name} by ID."""`);
    lines.push(`        data = self._request("GET", f"${endpoint}/{id}")`);
    lines.push(`        return ApiResponse(success=True, data=${name}(**data))`);
    lines.push('');

    // List
    lines.push(`    def list_${nameLower}s(`);
    lines.push('        self,');
    lines.push('        page: int = 1,');
    lines.push('        page_size: int = 20,');
    lines.push(`    ) -> ApiResponse[PaginatedResponse[${name}]]:`);
    lines.push(`        """List ${name}s with pagination."""`);
    lines.push(`        data = self._request("GET", f"${endpoint}?page={page}&pageSize={page_size}")`);
    lines.push(`        items = [${name}(**item) for item in data.get("items", [])]`);
    lines.push('        return ApiResponse(');
    lines.push('            success=True,');
    lines.push(`            data=PaginatedResponse(`);
    lines.push('                items=items,');
    lines.push('                total=data.get("total", 0),');
    lines.push('                page=data.get("page", 1),');
    lines.push('                page_size=data.get("pageSize", 20),');
    lines.push('                has_more=data.get("hasMore", False),');
    lines.push('            ),');
    lines.push('        )');
    lines.push('');

    // Create
    lines.push(`    def create_${nameLower}(self, input: Create${name}Input) -> ApiResponse[${name}]:`);
    lines.push(`        """Create a new ${name}."""`);
    lines.push(`        data = self._request("POST", "${endpoint}", asdict(input))`);
    lines.push(`        return ApiResponse(success=True, data=${name}(**data))`);
    lines.push('');

    // Update
    lines.push(`    def update_${nameLower}(self, id: str, input: Update${name}Input) -> ApiResponse[${name}]:`);
    lines.push(`        """Update a ${name}."""`);
    lines.push('        body = {k: v for k, v in asdict(input).items() if v is not None}');
    lines.push(`        data = self._request("PUT", f"${endpoint}/{id}", body)`);
    lines.push(`        return ApiResponse(success=True, data=${name}(**data))`);
    lines.push('');

    // Delete
    lines.push(`    def delete_${nameLower}(self, id: str) -> ApiResponse[None]:`);
    lines.push(`        """Delete a ${name}."""`);
    lines.push(`        self._request("DELETE", f"${endpoint}/{id}")`);
    lines.push('        return ApiResponse(success=True)');
    lines.push('');
  }

  // Behavior methods
  for (const behavior of domain.behaviors) {
    const name = behavior.name;
    const nameLower = toSnakeCase(name);
    const endpoint = `/api/${toKebabCase(name)}`;
    const outputType = mapISLToPython(behavior.outputType);

    if (behavior.inputs.length > 0) {
      lines.push(`    def ${nameLower}(self, input: ${name}Input) -> ApiResponse[${outputType}]:`);
      lines.push(`        """Execute ${name} behavior."""`);
      lines.push(`        data = self._request("POST", "${endpoint}", asdict(input))`);
    } else {
      lines.push(`    def ${nameLower}(self) -> ApiResponse[${outputType}]:`);
      lines.push(`        """Execute ${name} behavior."""`);
      lines.push(`        data = self._request("POST", "${endpoint}")`);
    }
    lines.push('        return ApiResponse(success=True, data=data)');
    lines.push('');
  }

  lines.push('    def close(self):');
  lines.push('        """Close the client."""');
  lines.push('        if self._client:');
  lines.push('            self._client.close()');
  lines.push('');
  lines.push('    def __enter__(self):');
  lines.push('        return self');
  lines.push('');
  lines.push('    def __exit__(self, *args):');
  lines.push('        self.close()');

  return lines.join('\n');
}

function generateInit(domain: Domain): string {
  const lines: string[] = [];

  lines.push('"""');
  lines.push(`${domain.name} SDK`);
  lines.push(`Version: ${domain.version || '0.1.0'}`);
  lines.push('"""');
  lines.push('');
  lines.push(`from .client import ${domain.name}Client`);
  lines.push('from .models import (');
  for (const entity of domain.entities) {
    lines.push(`    ${entity.name},`);
    lines.push(`    Create${entity.name}Input,`);
    lines.push(`    Update${entity.name}Input,`);
  }
  for (const behavior of domain.behaviors) {
    if (behavior.inputs.length > 0) {
      lines.push(`    ${behavior.name}Input,`);
    }
    if (behavior.errors.length > 0) {
      lines.push(`    ${behavior.name}Error,`);
    }
  }
  lines.push('    ApiResponse,');
  lines.push('    PaginatedResponse,');
  lines.push(')');
  lines.push('');
  lines.push('__all__ = [');
  lines.push(`    "${domain.name}Client",`);
  for (const entity of domain.entities) {
    lines.push(`    "${entity.name}",`);
    lines.push(`    "Create${entity.name}Input",`);
    lines.push(`    "Update${entity.name}Input",`);
  }
  for (const behavior of domain.behaviors) {
    if (behavior.inputs.length > 0) {
      lines.push(`    "${behavior.name}Input",`);
    }
  }
  lines.push('    "ApiResponse",');
  lines.push('    "PaginatedResponse",');
  lines.push(']');
  lines.push('');
  lines.push(`__version__ = "${domain.version || '0.1.0'}"`);

  return lines.join('\n');
}

function generatePyproject(domain: Domain, packageName: string): string {
  return `[build-system]
requires = ["setuptools>=61.0"]
build-backend = "setuptools.build_meta"

[project]
name = "${packageName}"
version = "${domain.version || '0.1.0'}"
description = "${domain.name} Python SDK"
readme = "README.md"
requires-python = ">=3.8"
dependencies = []

[project.optional-dependencies]
httpx = ["httpx>=0.24.0"]
`;
}

function generateReadme(domain: Domain, packageName: string): string {
  return `# ${domain.name} Python SDK

Generated from ISL specification.

## Installation

\`\`\`bash
pip install ${packageName}
# Optional: for better HTTP client
pip install ${packageName}[httpx]
\`\`\`

## Usage

\`\`\`python
from ${packageName} import ${domain.name}Client

client = ${domain.name}Client(base_url="http://localhost:3000")

# List entities
response = client.list_users()
if response.success:
    for user in response.data.items:
        print(user)
\`\`\`
`;
}

function mapISLToPython(islType: string): string {
  const genericMatch = islType.match(/^(\w+)<(.+)>$/);
  if (genericMatch) {
    const [, container, inner] = genericMatch;
    switch (container) {
      case 'List': return `List[${mapISLToPython(inner)}]`;
      case 'Map': {
        const [k, v] = inner.split(',').map(s => s.trim());
        return `Dict[${mapISLToPython(k)}, ${mapISLToPython(v)}]`;
      }
      case 'Optional': return `Optional[${mapISLToPython(inner)}]`;
    }
  }

  switch (islType) {
    case 'String': return 'str';
    case 'Int': return 'int';
    case 'Boolean': return 'bool';
    case 'UUID': return 'str';
    case 'Timestamp': return 'datetime';
    case 'Decimal': return 'Decimal';
    default: return islType;
  }
}

function isAutoGenerated(field: Field): boolean {
  return field.name === 'id' || field.name === 'createdAt' || field.name === 'updatedAt';
}

function toSnakeCase(str: string): string {
  return str.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase();
}

function toKebabCase(str: string): string {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}

function toScreamingSnake(str: string): string {
  return str.replace(/([a-z])([A-Z])/g, '$1_$2').toUpperCase();
}
