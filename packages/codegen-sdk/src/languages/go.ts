// ============================================================================
// Go SDK Generator
// ============================================================================

import type { Domain, Entity, Behavior, SDKOptions, GeneratedFile, Field } from '../types';

export function generateGo(domain: Domain, options: SDKOptions): GeneratedFile[] {
  const files: GeneratedFile[] = [];
  const { outputDir, packageName = domain.name.toLowerCase() } = options;

  // Models file
  files.push({
    path: `${outputDir}/models.go`,
    content: generateModels(domain, packageName),
  });

  // Client file
  files.push({
    path: `${outputDir}/client.go`,
    content: generateClient(domain, packageName, options.baseUrl || 'http://localhost:3000'),
  });

  // go.mod
  files.push({
    path: `${outputDir}/go.mod`,
    content: generateGoMod(packageName),
  });

  return files;
}

function generateModels(domain: Domain, packageName: string): string {
  const lines: string[] = [];

  lines.push(`// Package ${packageName} provides client for ${domain.name} API`);
  lines.push('// Generated from ISL specification');
  lines.push(`package ${packageName}`);
  lines.push('');
  lines.push('import (');
  lines.push('\t"time"');
  lines.push(')');
  lines.push('');

  // Entity structs
  for (const entity of domain.entities) {
    lines.push(`// ${entity.name} represents the ${entity.name} entity`);
    lines.push(`type ${entity.name} struct {`);
    for (const field of entity.fields) {
      const goType = mapISLToGo(field.type, field.optional);
      const jsonTag = `\`json:"${toCamelCase(field.name)}${field.optional ? ',omitempty' : ''}"\``;
      lines.push(`\t${toPascalCase(field.name)} ${goType} ${jsonTag}`);
    }
    lines.push('}');
    lines.push('');

    // Create input
    lines.push(`// Create${entity.name}Input is the input for creating a ${entity.name}`);
    lines.push(`type Create${entity.name}Input struct {`);
    for (const field of entity.fields) {
      if (isAutoGenerated(field)) continue;
      const goType = mapISLToGo(field.type, field.optional);
      const jsonTag = `\`json:"${toCamelCase(field.name)}${field.optional ? ',omitempty' : ''}"\``;
      lines.push(`\t${toPascalCase(field.name)} ${goType} ${jsonTag}`);
    }
    lines.push('}');
    lines.push('');

    // Update input
    lines.push(`// Update${entity.name}Input is the input for updating a ${entity.name}`);
    lines.push(`type Update${entity.name}Input struct {`);
    for (const field of entity.fields) {
      if (isAutoGenerated(field)) continue;
      const goType = mapISLToGo(field.type, true); // All optional for updates
      const jsonTag = `\`json:"${toCamelCase(field.name)},omitempty"\``;
      lines.push(`\t${toPascalCase(field.name)} ${goType} ${jsonTag}`);
    }
    lines.push('}');
    lines.push('');
  }

  // Behavior inputs
  for (const behavior of domain.behaviors) {
    if (behavior.inputs.length > 0) {
      lines.push(`// ${behavior.name}Input is the input for ${behavior.name} behavior`);
      lines.push(`type ${behavior.name}Input struct {`);
      for (const input of behavior.inputs) {
        const goType = mapISLToGo(input.type, input.optional);
        const jsonTag = `\`json:"${toCamelCase(input.name)}${input.optional ? ',omitempty' : ''}"\``;
        lines.push(`\t${toPascalCase(input.name)} ${goType} ${jsonTag}`);
      }
      lines.push('}');
      lines.push('');
    }

    // Error type
    if (behavior.errors.length > 0) {
      lines.push(`// ${behavior.name}Error represents possible errors for ${behavior.name}`);
      lines.push(`type ${behavior.name}Error string`);
      lines.push('');
      lines.push('const (');
      for (const error of behavior.errors) {
        lines.push(`\t${behavior.name}Error${toPascalCase(error)} ${behavior.name}Error = "${error}"`);
      }
      lines.push(')');
      lines.push('');
    }
  }

  // Response types
  lines.push('// APIError represents an API error');
  lines.push('type APIError struct {');
  lines.push('\tCode    string `json:"code"`');
  lines.push('\tMessage string `json:"message"`');
  lines.push('}');
  lines.push('');

  lines.push('// PaginatedResponse is a generic paginated response');
  lines.push('type PaginatedResponse[T any] struct {');
  lines.push('\tItems    []T  `json:"items"`');
  lines.push('\tTotal    int  `json:"total"`');
  lines.push('\tPage     int  `json:"page"`');
  lines.push('\tPageSize int  `json:"pageSize"`');
  lines.push('\tHasMore  bool `json:"hasMore"`');
  lines.push('}');

  return lines.join('\n');
}

function generateClient(domain: Domain, packageName: string, baseUrl: string): string {
  const lines: string[] = [];

  lines.push(`package ${packageName}`);
  lines.push('');
  lines.push('import (');
  lines.push('\t"bytes"');
  lines.push('\t"encoding/json"');
  lines.push('\t"fmt"');
  lines.push('\t"io"');
  lines.push('\t"net/http"');
  lines.push(')');
  lines.push('');

  lines.push('// Client is the API client');
  lines.push('type Client struct {');
  lines.push('\tbaseURL    string');
  lines.push('\thttpClient *http.Client');
  lines.push('\theaders    map[string]string');
  lines.push('}');
  lines.push('');

  lines.push('// NewClient creates a new API client');
  lines.push('func NewClient(opts ...ClientOption) *Client {');
  lines.push('\tc := &Client{');
  lines.push(`\t\tbaseURL:    "${baseUrl}",`);
  lines.push('\t\thttpClient: http.DefaultClient,');
  lines.push('\t\theaders:    make(map[string]string),');
  lines.push('\t}');
  lines.push('\tc.headers["Content-Type"] = "application/json"');
  lines.push('\tfor _, opt := range opts {');
  lines.push('\t\topt(c)');
  lines.push('\t}');
  lines.push('\treturn c');
  lines.push('}');
  lines.push('');

  lines.push('// ClientOption is a function that configures the client');
  lines.push('type ClientOption func(*Client)');
  lines.push('');

  lines.push('// WithBaseURL sets the base URL');
  lines.push('func WithBaseURL(url string) ClientOption {');
  lines.push('\treturn func(c *Client) {');
  lines.push('\t\tc.baseURL = url');
  lines.push('\t}');
  lines.push('}');
  lines.push('');

  lines.push('// WithHTTPClient sets the HTTP client');
  lines.push('func WithHTTPClient(client *http.Client) ClientOption {');
  lines.push('\treturn func(c *Client) {');
  lines.push('\t\tc.httpClient = client');
  lines.push('\t}');
  lines.push('}');
  lines.push('');

  lines.push('// WithHeader adds a header to all requests');
  lines.push('func WithHeader(key, value string) ClientOption {');
  lines.push('\treturn func(c *Client) {');
  lines.push('\t\tc.headers[key] = value');
  lines.push('\t}');
  lines.push('}');
  lines.push('');

  lines.push('func (c *Client) doRequest(method, path string, body interface{}, result interface{}) error {');
  lines.push('\tvar bodyReader io.Reader');
  lines.push('\tif body != nil {');
  lines.push('\t\tjsonBody, err := json.Marshal(body)');
  lines.push('\t\tif err != nil {');
  lines.push('\t\t\treturn fmt.Errorf("failed to marshal body: %w", err)');
  lines.push('\t\t}');
  lines.push('\t\tbodyReader = bytes.NewReader(jsonBody)');
  lines.push('\t}');
  lines.push('');
  lines.push('\treq, err := http.NewRequest(method, c.baseURL+path, bodyReader)');
  lines.push('\tif err != nil {');
  lines.push('\t\treturn fmt.Errorf("failed to create request: %w", err)');
  lines.push('\t}');
  lines.push('');
  lines.push('\tfor key, value := range c.headers {');
  lines.push('\t\treq.Header.Set(key, value)');
  lines.push('\t}');
  lines.push('');
  lines.push('\tresp, err := c.httpClient.Do(req)');
  lines.push('\tif err != nil {');
  lines.push('\t\treturn fmt.Errorf("request failed: %w", err)');
  lines.push('\t}');
  lines.push('\tdefer resp.Body.Close()');
  lines.push('');
  lines.push('\tif resp.StatusCode >= 400 {');
  lines.push('\t\tvar apiErr APIError');
  lines.push('\t\tjson.NewDecoder(resp.Body).Decode(&apiErr)');
  lines.push('\t\treturn fmt.Errorf("API error: %s - %s", apiErr.Code, apiErr.Message)');
  lines.push('\t}');
  lines.push('');
  lines.push('\tif result != nil {');
  lines.push('\t\tif err := json.NewDecoder(resp.Body).Decode(result); err != nil {');
  lines.push('\t\t\treturn fmt.Errorf("failed to decode response: %w", err)');
  lines.push('\t\t}');
  lines.push('\t}');
  lines.push('');
  lines.push('\treturn nil');
  lines.push('}');
  lines.push('');

  // Entity methods
  for (const entity of domain.entities) {
    const name = entity.name;
    const endpoint = `/api/${toKebabCase(name)}s`;

    // Get
    lines.push(`// Get${name} retrieves a ${name} by ID`);
    lines.push(`func (c *Client) Get${name}(id string) (*${name}, error) {`);
    lines.push(`\tvar result ${name}`);
    lines.push(`\terr := c.doRequest("GET", fmt.Sprintf("${endpoint}/%s", id), nil, &result)`);
    lines.push('\tif err != nil {');
    lines.push('\t\treturn nil, err');
    lines.push('\t}');
    lines.push('\treturn &result, nil');
    lines.push('}');
    lines.push('');

    // List
    lines.push(`// List${name}s retrieves a paginated list of ${name}s`);
    lines.push(`func (c *Client) List${name}s(page, pageSize int) (*PaginatedResponse[${name}], error) {`);
    lines.push(`\tvar result PaginatedResponse[${name}]`);
    lines.push(`\tpath := fmt.Sprintf("${endpoint}?page=%d&pageSize=%d", page, pageSize)`);
    lines.push('\terr := c.doRequest("GET", path, nil, &result)');
    lines.push('\tif err != nil {');
    lines.push('\t\treturn nil, err');
    lines.push('\t}');
    lines.push('\treturn &result, nil');
    lines.push('}');
    lines.push('');

    // Create
    lines.push(`// Create${name} creates a new ${name}`);
    lines.push(`func (c *Client) Create${name}(input Create${name}Input) (*${name}, error) {`);
    lines.push(`\tvar result ${name}`);
    lines.push(`\terr := c.doRequest("POST", "${endpoint}", input, &result)`);
    lines.push('\tif err != nil {');
    lines.push('\t\treturn nil, err');
    lines.push('\t}');
    lines.push('\treturn &result, nil');
    lines.push('}');
    lines.push('');

    // Update
    lines.push(`// Update${name} updates a ${name}`);
    lines.push(`func (c *Client) Update${name}(id string, input Update${name}Input) (*${name}, error) {`);
    lines.push(`\tvar result ${name}`);
    lines.push(`\terr := c.doRequest("PUT", fmt.Sprintf("${endpoint}/%s", id), input, &result)`);
    lines.push('\tif err != nil {');
    lines.push('\t\treturn nil, err');
    lines.push('\t}');
    lines.push('\treturn &result, nil');
    lines.push('}');
    lines.push('');

    // Delete
    lines.push(`// Delete${name} deletes a ${name}`);
    lines.push(`func (c *Client) Delete${name}(id string) error {`);
    lines.push(`\treturn c.doRequest("DELETE", fmt.Sprintf("${endpoint}/%s", id), nil, nil)`);
    lines.push('}');
    lines.push('');
  }

  // Behavior methods
  for (const behavior of domain.behaviors) {
    const name = behavior.name;
    const endpoint = `/api/${toKebabCase(name)}`;
    const outputType = mapISLToGo(behavior.outputType, false);

    lines.push(`// ${name} executes the ${name} behavior`);
    if (behavior.inputs.length > 0) {
      lines.push(`func (c *Client) ${name}(input ${name}Input) (*${outputType}, error) {`);
      lines.push(`\tvar result ${outputType}`);
      lines.push(`\terr := c.doRequest("POST", "${endpoint}", input, &result)`);
    } else {
      lines.push(`func (c *Client) ${name}() (*${outputType}, error) {`);
      lines.push(`\tvar result ${outputType}`);
      lines.push(`\terr := c.doRequest("POST", "${endpoint}", nil, &result)`);
    }
    lines.push('\tif err != nil {');
    lines.push('\t\treturn nil, err');
    lines.push('\t}');
    lines.push('\treturn &result, nil');
    lines.push('}');
    lines.push('');
  }

  return lines.join('\n');
}

function generateGoMod(packageName: string): string {
  return `module github.com/example/${packageName}

go 1.21
`;
}

function mapISLToGo(islType: string, optional: boolean): string {
  const genericMatch = islType.match(/^(\w+)<(.+)>$/);
  if (genericMatch) {
    const [, container, inner] = genericMatch;
    switch (container) {
      case 'List': return `[]${mapISLToGo(inner, false)}`;
      case 'Map': {
        const [k, v] = inner.split(',').map(s => s.trim());
        return `map[${mapISLToGo(k, false)}]${mapISLToGo(v, false)}`;
      }
      case 'Optional': return `*${mapISLToGo(inner, false)}`;
    }
  }

  let goType: string;
  switch (islType) {
    case 'String': goType = 'string'; break;
    case 'Int': goType = 'int64'; break;
    case 'Boolean': goType = 'bool'; break;
    case 'UUID': goType = 'string'; break;
    case 'Timestamp': goType = 'time.Time'; break;
    case 'Decimal': goType = 'float64'; break;
    default: goType = islType;
  }

  return optional ? `*${goType}` : goType;
}

function isAutoGenerated(field: Field): boolean {
  return field.name === 'id' || field.name === 'createdAt' || field.name === 'updatedAt';
}

function toPascalCase(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function toCamelCase(str: string): string {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

function toKebabCase(str: string): string {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
