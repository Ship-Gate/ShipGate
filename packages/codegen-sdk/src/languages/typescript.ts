// ============================================================================
// TypeScript SDK Generator
// ============================================================================

import type { Domain, Entity, Behavior, SDKOptions, GeneratedFile, Field } from '../types';

export function generateTypeScript(domain: Domain, options: SDKOptions): GeneratedFile[] {
  const files: GeneratedFile[] = [];
  const { outputDir, packageName = domain.name.toLowerCase(), baseUrl = 'http://localhost:3000' } = options;

  // Types file
  files.push({
    path: `${outputDir}/types.ts`,
    content: generateTypes(domain),
  });

  // Client file
  files.push({
    path: `${outputDir}/client.ts`,
    content: generateClient(domain, baseUrl),
  });

  // Index file
  files.push({
    path: `${outputDir}/index.ts`,
    content: generateIndex(domain),
  });

  // Package.json
  files.push({
    path: `${outputDir}/package.json`,
    content: JSON.stringify({
      name: `@${packageName}/sdk`,
      version: domain.version || '0.1.0',
      main: 'dist/index.js',
      types: 'dist/index.d.ts',
      scripts: {
        build: 'tsc',
        prepublishOnly: 'npm run build',
      },
      devDependencies: {
        typescript: '^5.3.0',
      },
    }, null, 2),
  });

  // tsconfig.json
  files.push({
    path: `${outputDir}/tsconfig.json`,
    content: JSON.stringify({
      compilerOptions: {
        target: 'ES2022',
        module: 'commonjs',
        declaration: true,
        outDir: './dist',
        strict: true,
        esModuleInterop: true,
      },
      include: ['*.ts'],
    }, null, 2),
  });

  return files;
}

function generateTypes(domain: Domain): string {
  const lines: string[] = [];

  lines.push('// ============================================================================');
  lines.push(`// ${domain.name} SDK Types`);
  lines.push('// Generated from ISL specification');
  lines.push('// ============================================================================');
  lines.push('');

  // Base types
  lines.push('export type UUID = string;');
  lines.push('export type Timestamp = string | Date;');
  lines.push('export type Decimal = number | string;');
  lines.push('');

  // Custom types
  for (const type of domain.types) {
    lines.push(`export type ${type.name} = ${mapISLToTS(type.baseType)};`);
  }
  if (domain.types.length > 0) lines.push('');

  // Entity interfaces
  for (const entity of domain.entities) {
    lines.push(`export interface ${entity.name} {`);
    for (const field of entity.fields) {
      const tsType = mapISLToTS(field.type);
      const optional = field.optional ? '?' : '';
      lines.push(`  ${field.name}${optional}: ${tsType};`);
    }
    lines.push('}');
    lines.push('');

    // Create input
    lines.push(`export interface Create${entity.name}Input {`);
    for (const field of entity.fields) {
      if (isAutoGenerated(field)) continue;
      const tsType = mapISLToTS(field.type);
      const optional = field.optional ? '?' : '';
      lines.push(`  ${field.name}${optional}: ${tsType};`);
    }
    lines.push('}');
    lines.push('');

    // Update input
    lines.push(`export interface Update${entity.name}Input {`);
    for (const field of entity.fields) {
      if (isAutoGenerated(field)) continue;
      const tsType = mapISLToTS(field.type);
      lines.push(`  ${field.name}?: ${tsType};`);
    }
    lines.push('}');
    lines.push('');
  }

  // Behavior types
  for (const behavior of domain.behaviors) {
    if (behavior.inputs.length > 0) {
      lines.push(`export interface ${behavior.name}Input {`);
      for (const input of behavior.inputs) {
        const tsType = mapISLToTS(input.type);
        const optional = input.optional ? '?' : '';
        lines.push(`  ${input.name}${optional}: ${tsType};`);
      }
      lines.push('}');
      lines.push('');
    }

    if (behavior.errors.length > 0) {
      lines.push(`export type ${behavior.name}Error =`);
      lines.push(behavior.errors.map(e => `  | '${e}'`).join('\n') + ';');
      lines.push('');
    }
  }

  // API Response types
  lines.push('export interface ApiResponse<T> {');
  lines.push('  success: boolean;');
  lines.push('  data?: T;');
  lines.push('  error?: { code: string; message: string };');
  lines.push('}');
  lines.push('');

  lines.push('export interface PaginatedResponse<T> {');
  lines.push('  items: T[];');
  lines.push('  total: number;');
  lines.push('  page: number;');
  lines.push('  pageSize: number;');
  lines.push('  hasMore: boolean;');
  lines.push('}');

  return lines.join('\n');
}

function generateClient(domain: Domain, baseUrl: string): string {
  const lines: string[] = [];

  lines.push('// ============================================================================');
  lines.push(`// ${domain.name} SDK Client`);
  lines.push('// Generated from ISL specification');
  lines.push('// ============================================================================');
  lines.push('');
  lines.push('import type {');
  lines.push('  ApiResponse,');
  lines.push('  PaginatedResponse,');
  for (const entity of domain.entities) {
    lines.push(`  ${entity.name},`);
    lines.push(`  Create${entity.name}Input,`);
    lines.push(`  Update${entity.name}Input,`);
  }
  for (const behavior of domain.behaviors) {
    if (behavior.inputs.length > 0) {
      lines.push(`  ${behavior.name}Input,`);
    }
  }
  lines.push("} from './types';");
  lines.push('');

  lines.push('export interface ClientConfig {');
  lines.push('  baseUrl?: string;');
  lines.push('  headers?: Record<string, string>;');
  lines.push('  onError?: (error: Error) => void;');
  lines.push('}');
  lines.push('');

  lines.push(`const DEFAULT_BASE_URL = '${baseUrl}';`);
  lines.push('');

  lines.push(`export class ${domain.name}Client {`);
  lines.push('  private baseUrl: string;');
  lines.push('  private headers: Record<string, string>;');
  lines.push('  private onError?: (error: Error) => void;');
  lines.push('');
  lines.push('  constructor(config: ClientConfig = {}) {');
  lines.push('    this.baseUrl = config.baseUrl || DEFAULT_BASE_URL;');
  lines.push("    this.headers = { 'Content-Type': 'application/json', ...config.headers };");
  lines.push('    this.onError = config.onError;');
  lines.push('  }');
  lines.push('');

  lines.push('  private async request<T>(');
  lines.push('    method: string,');
  lines.push('    path: string,');
  lines.push('    body?: unknown');
  lines.push('  ): Promise<ApiResponse<T>> {');
  lines.push('    try {');
  lines.push('      const response = await fetch(`${this.baseUrl}${path}`, {');
  lines.push('        method,');
  lines.push('        headers: this.headers,');
  lines.push('        body: body ? JSON.stringify(body) : undefined,');
  lines.push('      });');
  lines.push('');
  lines.push('      const data = await response.json();');
  lines.push('');
  lines.push('      if (!response.ok) {');
  lines.push('        return {');
  lines.push('          success: false,');
  lines.push("          error: { code: data.code || 'ERROR', message: data.message || 'Request failed' },");
  lines.push('        };');
  lines.push('      }');
  lines.push('');
  lines.push('      return { success: true, data };');
  lines.push('    } catch (error) {');
  lines.push('      const err = error instanceof Error ? error : new Error(String(error));');
  lines.push('      this.onError?.(err);');
  lines.push("      return { success: false, error: { code: 'NETWORK_ERROR', message: err.message } };");
  lines.push('    }');
  lines.push('  }');
  lines.push('');

  // Generate entity methods
  for (const entity of domain.entities) {
    const name = entity.name;
    const nameLower = toCamelCase(name);
    const endpoint = `/api/${toKebabCase(name)}s`;

    lines.push(`  // ${name} Operations`);
    lines.push('');

    // Get by ID
    lines.push(`  async get${name}(id: string): Promise<ApiResponse<${name}>> {`);
    lines.push(`    return this.request<${name}>('GET', \`${endpoint}/\${id}\`);`);
    lines.push('  }');
    lines.push('');

    // List
    lines.push(`  async list${name}s(params: { page?: number; pageSize?: number } = {}): Promise<ApiResponse<PaginatedResponse<${name}>>> {`);
    lines.push('    const { page = 1, pageSize = 20 } = params;');
    lines.push(`    return this.request<PaginatedResponse<${name}>>('GET', \`${endpoint}?page=\${page}&pageSize=\${pageSize}\`);`);
    lines.push('  }');
    lines.push('');

    // Create
    lines.push(`  async create${name}(input: Create${name}Input): Promise<ApiResponse<${name}>> {`);
    lines.push(`    return this.request<${name}>('POST', '${endpoint}', input);`);
    lines.push('  }');
    lines.push('');

    // Update
    lines.push(`  async update${name}(id: string, input: Update${name}Input): Promise<ApiResponse<${name}>> {`);
    lines.push(`    return this.request<${name}>('PUT', \`${endpoint}/\${id}\`, input);`);
    lines.push('  }');
    lines.push('');

    // Delete
    lines.push(`  async delete${name}(id: string): Promise<ApiResponse<void>> {`);
    lines.push(`    return this.request<void>('DELETE', \`${endpoint}/\${id}\`);`);
    lines.push('  }');
    lines.push('');
  }

  // Generate behavior methods
  for (const behavior of domain.behaviors) {
    const name = behavior.name;
    const nameLower = toCamelCase(name);
    const endpoint = `/api/${toKebabCase(name)}`;
    const outputType = mapISLToTS(behavior.outputType);

    lines.push(`  // ${name} Behavior`);
    if (behavior.inputs.length > 0) {
      lines.push(`  async ${nameLower}(input: ${name}Input): Promise<ApiResponse<${outputType}>> {`);
      lines.push(`    return this.request<${outputType}>('POST', '${endpoint}', input);`);
    } else {
      lines.push(`  async ${nameLower}(): Promise<ApiResponse<${outputType}>> {`);
      lines.push(`    return this.request<${outputType}>('POST', '${endpoint}');`);
    }
    lines.push('  }');
    lines.push('');
  }

  lines.push('}');
  lines.push('');

  // Factory function
  lines.push(`export function create${domain.name}Client(config?: ClientConfig): ${domain.name}Client {`);
  lines.push(`  return new ${domain.name}Client(config);`);
  lines.push('}');

  return lines.join('\n');
}

function generateIndex(domain: Domain): string {
  const lines: string[] = [];

  lines.push("export * from './types';");
  lines.push(`export { ${domain.name}Client, create${domain.name}Client } from './client';`);
  lines.push("export type { ClientConfig } from './client';");

  return lines.join('\n');
}

function mapISLToTS(islType: string): string {
  const genericMatch = islType.match(/^(\w+)<(.+)>$/);
  if (genericMatch) {
    const [, container, inner] = genericMatch;
    switch (container) {
      case 'List': return `${mapISLToTS(inner)}[]`;
      case 'Map': {
        const [k, v] = inner.split(',').map(s => s.trim());
        return `Record<${mapISLToTS(k)}, ${mapISLToTS(v)}>`;
      }
      case 'Optional': return `${mapISLToTS(inner)} | null`;
    }
  }

  switch (islType) {
    case 'String': return 'string';
    case 'Int': return 'number';
    case 'Boolean': return 'boolean';
    case 'UUID': return 'string';
    case 'Timestamp': return 'string';
    case 'Decimal': return 'number';
    default: return islType;
  }
}

function isAutoGenerated(field: Field): boolean {
  return field.name === 'id' || field.name === 'createdAt' || field.name === 'updatedAt';
}

function toCamelCase(str: string): string {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

function toKebabCase(str: string): string {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
