/**
 * TypeScript error classes generator
 */

import type { ErrorCatalog } from '../catalog.js';
import type {
  ErrorDefinition,
  GeneratorOutput,
  TypeScriptConfig,
} from '../types.js';

/**
 * TypeScript generator class
 */
export class TypeScriptGenerator {
  private config: TypeScriptConfig;

  constructor(config: TypeScriptConfig) {
    this.config = {
      generateClasses: true,
      generateTypeGuards: true,
      generateFactories: true,
      baseClassName: 'ApiError',
      ...config,
    };
  }

  /**
   * Generate TypeScript code
   */
  async generate(catalog: ErrorCatalog): Promise<GeneratorOutput[]> {
    const errors = catalog.getAllErrors();
    const groups = catalog.getGroups();

    const sections: string[] = [
      this.generateHeader(),
      this.generateEnums(errors),
      this.generateInterfaces(),
    ];

    if (this.config.generateClasses) {
      sections.push(this.generateBaseClass());
      sections.push(this.generateErrorClasses(errors));
    }

    if (this.config.generateTypeGuards) {
      sections.push(this.generateTypeGuards(errors));
    }

    if (this.config.generateFactories) {
      sections.push(this.generateFactories(errors));
    }

    sections.push(this.generateErrorMap(errors));
    sections.push(this.generateUtilities(errors));

    return [
      {
        path: this.config.outputFile,
        content: sections.join('\n\n'),
        type: 'typescript',
      },
    ];
  }

  /**
   * Generate file header
   */
  private generateHeader(): string {
    return `/**
 * Auto-generated error types and classes
 * DO NOT EDIT - Generated by ISL Error Catalog Generator
 * Generated at: ${new Date().toISOString()}
 */

/* eslint-disable @typescript-eslint/no-namespace */`;
  }

  /**
   * Generate error code enums
   */
  private generateEnums(errors: ErrorDefinition[]): string {
    const lines = [
      '/**',
      ' * Error codes enum',
      ' */',
      'export enum ErrorCode {',
    ];

    for (const error of errors) {
      lines.push(`  /** ${error.message} */`);
      lines.push(`  ${error.id} = '${error.code}',`);
    }

    lines.push('}');

    // HTTP status enum
    lines.push('');
    lines.push('/**');
    lines.push(' * HTTP status codes used by errors');
    lines.push(' */');
    lines.push('export enum HttpStatus {');

    const statuses = new Set(errors.map((e) => e.httpStatus));
    for (const status of Array.from(statuses).sort()) {
      const name = this.getStatusConstName(status);
      lines.push(`  ${name} = ${status},`);
    }

    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate interfaces
   */
  private generateInterfaces(): string {
    return `/**
 * Error response structure
 */
export interface ErrorResponse {
  error: {
    code: string;
    type: string;
    message: string;
    details?: Record<string, unknown>;
    retriable?: boolean;
    retryAfter?: number;
  };
}

/**
 * Error metadata
 */
export interface ErrorMetadata {
  code: ErrorCode;
  httpStatus: HttpStatus;
  retriable: boolean;
  retryAfter?: number;
  severity: 'critical' | 'error' | 'warning' | 'info';
}

/**
 * Error details type
 */
export type ErrorDetails = Record<string, unknown>;`;
  }

  /**
   * Generate base error class
   */
  private generateBaseClass(): string {
    const className = this.config.baseClassName;

    return `/**
 * Base API error class
 */
export class ${className} extends Error {
  readonly code: ErrorCode;
  readonly httpStatus: HttpStatus;
  readonly type: string;
  readonly details: ErrorDetails;
  readonly retriable: boolean;
  readonly retryAfter?: number;

  constructor(
    code: ErrorCode,
    httpStatus: HttpStatus,
    message: string,
    details: ErrorDetails = {},
    retriable = false,
    retryAfter?: number
  ) {
    super(message);
    this.name = '${className}';
    this.code = code;
    this.httpStatus = httpStatus;
    this.type = code;
    this.details = details;
    this.retriable = retriable;
    this.retryAfter = retryAfter;

    // Maintains proper stack trace in V8 environments
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ${className});
    }
  }

  /**
   * Convert to error response format
   */
  toResponse(): ErrorResponse {
    return {
      error: {
        code: this.code,
        type: this.type,
        message: this.message,
        details: Object.keys(this.details).length > 0 ? this.details : undefined,
        retriable: this.retriable || undefined,
        retryAfter: this.retryAfter,
      },
    };
  }

  /**
   * Convert to JSON
   */
  toJSON(): Record<string, unknown> {
    return {
      name: this.name,
      code: this.code,
      httpStatus: this.httpStatus,
      message: this.message,
      details: this.details,
      retriable: this.retriable,
      retryAfter: this.retryAfter,
    };
  }
}`;
  }

  /**
   * Generate individual error classes
   */
  private generateErrorClasses(errors: ErrorDefinition[]): string {
    const baseClass = this.config.baseClassName;
    const classes: string[] = [];

    for (const error of errors) {
      const className = this.toClassName(error.id);
      const httpStatusConst = this.getStatusConstName(error.httpStatus);

      classes.push(`/**
 * ${error.message}
 * 
 * ${error.description || 'No description available.'}
 * 
 * @httpStatus ${error.httpStatus}
 * @retriable ${error.retriable}
 */
export class ${className} extends ${baseClass} {
  constructor(details: ErrorDetails = {}) {
    super(
      ErrorCode.${error.id},
      HttpStatus.${httpStatusConst},
      '${this.escapeString(error.message)}',
      details,
      ${error.retriable},
      ${error.retryAfter ?? 'undefined'}
    );
    this.name = '${className}';
  }
}`);
    }

    return classes.join('\n\n');
  }

  /**
   * Generate type guards
   */
  private generateTypeGuards(errors: ErrorDefinition[]): string {
    const baseClass = this.config.baseClassName;
    const guards: string[] = [
      `/**
 * Check if error is an API error
 */
export function is${baseClass}(error: unknown): error is ${baseClass} {
  return error instanceof ${baseClass};
}`,
    ];

    for (const error of errors) {
      const className = this.toClassName(error.id);
      guards.push(`
/**
 * Check if error is ${className}
 */
export function is${className}(error: unknown): error is ${className} {
  return error instanceof ${className} || 
    (is${baseClass}(error) && error.code === ErrorCode.${error.id});
}`);
    }

    return guards.join('\n');
  }

  /**
   * Generate factory functions
   */
  private generateFactories(errors: ErrorDefinition[]): string {
    const factories: string[] = [
      '/**',
      ' * Error factory namespace',
      ' */',
      'export namespace Errors {',
    ];

    for (const error of errors) {
      const className = this.toClassName(error.id);
      const factoryName = this.toCamelCase(error.id);

      factories.push(`
  /**
   * Create ${error.id} error
   * ${error.message}
   */
  export function ${factoryName}(details?: ErrorDetails): ${className} {
    return new ${className}(details);
  }`);
    }

    factories.push('}');

    return factories.join('\n');
  }

  /**
   * Generate error map
   */
  private generateErrorMap(errors: ErrorDefinition[]): string {
    const lines = [
      '/**',
      ' * Map of error codes to error classes',
      ' */',
      `export const ErrorMap: Record<ErrorCode, new (details?: ErrorDetails) => ${this.config.baseClassName}> = {`,
    ];

    for (const error of errors) {
      const className = this.toClassName(error.id);
      lines.push(`  [ErrorCode.${error.id}]: ${className},`);
    }

    lines.push('};');

    return lines.join('\n');
  }

  /**
   * Generate utility functions
   */
  private generateUtilities(errors: ErrorDefinition[]): string {
    const baseClass = this.config.baseClassName;

    return `/**
 * Create error from error code
 */
export function createError(
  code: ErrorCode,
  details?: ErrorDetails
): ${baseClass} {
  const ErrorClass = ErrorMap[code];
  if (!ErrorClass) {
    throw new Error(\`Unknown error code: \${code}\`);
  }
  return new ErrorClass(details);
}

/**
 * Create error from error response
 */
export function fromResponse(response: ErrorResponse): ${baseClass} {
  const code = response.error.code as ErrorCode;
  return createError(code, response.error.details);
}

/**
 * Get error metadata by code
 */
export function getErrorMetadata(code: ErrorCode): ErrorMetadata | undefined {
  const metadata: Record<ErrorCode, ErrorMetadata> = {
${errors.map((e) => `    [ErrorCode.${e.id}]: {
      code: ErrorCode.${e.id},
      httpStatus: HttpStatus.${this.getStatusConstName(e.httpStatus)},
      retriable: ${e.retriable},
      ${e.retryAfter ? `retryAfter: ${e.retryAfter},` : ''}
      severity: '${e.severity}',
    }`).join(',\n')}
  };
  return metadata[code];
}

/**
 * Check if error code is retriable
 */
export function isRetriable(code: ErrorCode): boolean {
  const metadata = getErrorMetadata(code);
  return metadata?.retriable ?? false;
}

/**
 * Get all error codes for a domain
 */
export function getErrorCodesForDomain(domain: string): ErrorCode[] {
  const domainErrors: Record<string, ErrorCode[]> = {
${this.groupByDomain(errors)}
  };
  return domainErrors[domain.toLowerCase()] ?? [];
}`;
  }

  /**
   * Group errors by domain for utility function
   */
  private groupByDomain(errors: ErrorDefinition[]): string {
    const domains = new Map<string, string[]>();

    for (const error of errors) {
      const domain = error.domain.toLowerCase();
      if (!domains.has(domain)) {
        domains.set(domain, []);
      }
      domains.get(domain)!.push(`ErrorCode.${error.id}`);
    }

    return Array.from(domains.entries())
      .map(([domain, codes]) => `    '${domain}': [${codes.join(', ')}]`)
      .join(',\n');
  }

  /**
   * Convert error ID to class name
   */
  private toClassName(id: string): string {
    return id
      .split('_')
      .map((part) => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
      .join('') + 'Error';
  }

  /**
   * Convert error ID to camelCase
   */
  private toCamelCase(id: string): string {
    const parts = id.toLowerCase().split('_');
    return parts[0] + parts.slice(1)
      .map((p) => p.charAt(0).toUpperCase() + p.slice(1))
      .join('');
  }

  /**
   * Get HTTP status constant name
   */
  private getStatusConstName(status: number): string {
    const names: Record<number, string> = {
      400: 'BAD_REQUEST',
      401: 'UNAUTHORIZED',
      403: 'FORBIDDEN',
      404: 'NOT_FOUND',
      405: 'METHOD_NOT_ALLOWED',
      408: 'REQUEST_TIMEOUT',
      409: 'CONFLICT',
      410: 'GONE',
      422: 'UNPROCESSABLE_ENTITY',
      429: 'TOO_MANY_REQUESTS',
      500: 'INTERNAL_SERVER_ERROR',
      501: 'NOT_IMPLEMENTED',
      502: 'BAD_GATEWAY',
      503: 'SERVICE_UNAVAILABLE',
      504: 'GATEWAY_TIMEOUT',
    };
    return names[status] ?? `STATUS_${status}`;
  }

  /**
   * Escape string for TypeScript
   */
  private escapeString(str: string): string {
    return str.replace(/'/g, "\\'").replace(/\n/g, '\\n');
  }
}
