/**
 * Markdown documentation generator
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import Handlebars from 'handlebars';
import type { ErrorCatalog } from '../catalog.js';
import type {
  ErrorDefinition,
  ErrorGroup,
  GeneratorOutput,
  MarkdownConfig,
} from '../types.js';

/**
 * Default markdown template
 */
const DEFAULT_TEMPLATE = `# Error Catalog{{#if groupName}}: {{groupName}}{{/if}}

{{#if description}}
{{description}}

{{/if}}
{{#if stats}}
## Statistics

| Metric | Count |
|--------|-------|
| Total Errors | {{stats.totalErrors}} |
| Retriable | {{stats.retriableCount}} |
| Deprecated | {{stats.deprecatedCount}} |

{{/if}}
{{#if toc}}
## Table of Contents

{{#each groups}}
- [{{name}}](#{{anchor}})
{{#each errors}}
  - [{{id}}](#{{../anchor}}-{{lowercase id}})
{{/each}}
{{/each}}

{{/if}}
{{#each groups}}
## {{name}}

{{#if description}}
{{description}}

{{/if}}
{{#each errors}}
### {{id}}

**Code:** \`{{code}}\`
**HTTP Status:** {{httpStatus}} {{httpStatusName}}
**Retriable:** {{#if retriable}}Yes{{else}}No{{/if}}
{{#if retryAfter}}**Retry After:** {{retryAfter}} seconds{{/if}}
**Severity:** {{severity}}

{{#if deprecated}}
> ⚠️ **Deprecated** since {{deprecated.since}}{{#if deprecated.replacement}} - Use {{deprecated.replacement}} instead{{/if}}
{{#if deprecated.message}}
> {{deprecated.message}}
{{/if}}

{{/if}}
#### Description

{{#if description}}
{{description}}
{{else}}
{{message}}
{{/if}}

{{#if causes.length}}
#### When This Occurs

{{#each causes}}
- {{this}}
{{/each}}

{{/if}}
{{#if resolutions.length}}
#### Resolution

{{#each resolutions}}
- {{this}}
{{/each}}

{{/if}}
{{#if relatedErrors.length}}
#### Related Errors

{{#each relatedErrors}}
- [\`{{this}}\`](#{{lowercase this}})
{{/each}}

{{/if}}
{{#if tags.length}}
**Tags:** {{#each tags}}\`{{this}}\`{{#unless @last}}, {{/unless}}{{/each}}

{{/if}}
{{#if includeExamples}}
{{#if example}}
#### Example Response

\`\`\`json
{{json example.response.body}}
\`\`\`

{{/if}}
{{/if}}
---

{{/each}}
{{/each}}

---
*Generated by ISL Error Catalog Generator*
`;

/**
 * Markdown generator class
 */
export class MarkdownGenerator {
  private config: MarkdownConfig;
  private template: Handlebars.TemplateDelegate;

  constructor(config: MarkdownConfig) {
    this.config = {
      splitByGroup: false,
      includeToc: true,
      includeExamples: true,
      ...config,
    };

    this.registerHelpers();
    this.template = Handlebars.compile(DEFAULT_TEMPLATE);
  }

  /**
   * Generate markdown documentation
   */
  async generate(catalog: ErrorCatalog): Promise<GeneratorOutput[]> {
    // Load custom template if specified
    if (this.config.template) {
      const templateContent = await fs.readFile(this.config.template, 'utf-8');
      this.template = Handlebars.compile(templateContent);
    }

    const groups = catalog.getGroups();
    const stats = catalog.getStats();

    if (this.config.splitByGroup) {
      return this.generateSplitFiles(groups, stats);
    }

    return this.generateSingleFile(groups, stats);
  }

  /**
   * Generate a single markdown file
   */
  private generateSingleFile(
    groups: ErrorGroup[],
    stats: ReturnType<ErrorCatalog['getStats']>
  ): GeneratorOutput[] {
    const enrichedGroups = groups.map((g) => this.enrichGroup(g));

    const content = this.template({
      groups: enrichedGroups,
      stats,
      toc: this.config.includeToc,
      includeExamples: this.config.includeExamples,
    });

    return [
      {
        path: path.join(this.config.outputDir, 'errors.md'),
        content: this.cleanupMarkdown(content),
        type: 'markdown',
      },
    ];
  }

  /**
   * Generate separate files for each group
   */
  private generateSplitFiles(
    groups: ErrorGroup[],
    stats: ReturnType<ErrorCatalog['getStats']>
  ): GeneratorOutput[] {
    const outputs: GeneratorOutput[] = [];

    // Generate index file
    const indexContent = this.generateIndex(groups, stats);
    outputs.push({
      path: path.join(this.config.outputDir, 'index.md'),
      content: indexContent,
      type: 'markdown',
    });

    // Generate individual group files
    for (const group of groups) {
      const enrichedGroup = this.enrichGroup(group);
      const content = this.template({
        groupName: group.name,
        description: group.description,
        groups: [enrichedGroup],
        toc: false,
        includeExamples: this.config.includeExamples,
      });

      outputs.push({
        path: path.join(this.config.outputDir, `${group.id}.md`),
        content: this.cleanupMarkdown(content),
        type: 'markdown',
      });
    }

    return outputs;
  }

  /**
   * Generate index file for split documentation
   */
  private generateIndex(
    groups: ErrorGroup[],
    stats: ReturnType<ErrorCatalog['getStats']>
  ): string {
    const lines = [
      '# Error Catalog',
      '',
      '## Overview',
      '',
      '| Metric | Count |',
      '|--------|-------|',
      `| Total Errors | ${stats.totalErrors} |`,
      `| Retriable | ${stats.retriableCount} |`,
      `| Deprecated | ${stats.deprecatedCount} |`,
      '',
      '## Domains',
      '',
    ];

    for (const group of groups) {
      lines.push(`### [${group.name}](./${group.id}.md)`);
      lines.push('');
      if (group.description) {
        lines.push(group.description);
        lines.push('');
      }
      lines.push(`| Error | Code | HTTP Status |`);
      lines.push(`|-------|------|-------------|`);
      for (const error of group.errors) {
        lines.push(
          `| [${error.id}](./${group.id}.md#${error.id.toLowerCase()}) | \`${error.code}\` | ${error.httpStatus} |`
        );
      }
      lines.push('');
    }

    lines.push('---');
    lines.push('*Generated by ISL Error Catalog Generator*');

    return lines.join('\n');
  }

  /**
   * Enrich group with additional data for template
   */
  private enrichGroup(group: ErrorGroup): EnrichedGroup {
    return {
      ...group,
      anchor: this.generateAnchor(group.name),
      errors: group.errors.map((e) => this.enrichError(e)),
    };
  }

  /**
   * Enrich error with additional data for template
   */
  private enrichError(error: ErrorDefinition): EnrichedError {
    return {
      ...error,
      httpStatusName: this.getStatusName(error.httpStatus),
      anchor: this.generateAnchor(error.id),
    };
  }

  /**
   * Generate anchor from text
   */
  private generateAnchor(text: string): string {
    return text
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '');
  }

  /**
   * Get HTTP status name
   */
  private getStatusName(status: number): string {
    const names: Record<number, string> = {
      400: 'Bad Request',
      401: 'Unauthorized',
      403: 'Forbidden',
      404: 'Not Found',
      405: 'Method Not Allowed',
      408: 'Request Timeout',
      409: 'Conflict',
      410: 'Gone',
      422: 'Unprocessable Entity',
      429: 'Too Many Requests',
      500: 'Internal Server Error',
      501: 'Not Implemented',
      502: 'Bad Gateway',
      503: 'Service Unavailable',
      504: 'Gateway Timeout',
    };
    return names[status] ?? '';
  }

  /**
   * Register Handlebars helpers
   */
  private registerHelpers(): void {
    Handlebars.registerHelper('lowercase', (str: string) =>
      str?.toLowerCase().replace(/_/g, '-')
    );

    Handlebars.registerHelper('json', (obj: unknown) =>
      JSON.stringify(obj, null, 2)
    );

    Handlebars.registerHelper('eq', (a: unknown, b: unknown) => a === b);
  }

  /**
   * Clean up markdown output
   */
  private cleanupMarkdown(content: string): string {
    return content
      .replace(/\n{3,}/g, '\n\n') // Remove excessive newlines
      .replace(/\n+$/g, '\n') // Single newline at end
      .trim() + '\n';
  }
}

/**
 * Enriched group with template data
 */
interface EnrichedGroup extends ErrorGroup {
  anchor: string;
  errors: EnrichedError[];
}

/**
 * Enriched error with template data
 */
interface EnrichedError extends ErrorDefinition {
  httpStatusName: string;
  anchor: string;
}
