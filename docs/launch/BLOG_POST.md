# I Scanned 10 AI-Generated Codebases. Here's What Every Tool Missed.

*Published: [DATE]*  
*Author: Shipgate Team*

---

## TL;DR

We scanned 10 AI-generated codebases (Cursor, Copilot, Claude) with ESLint, TypeScript, and our new tool ISL Verify. **347 total issues found. ESLint caught 31%. TypeScript caught 18%. ISL Verify caught 76%.** The 69 issues only ISL Verify detected included hallucinated APIs, missing auth on payment endpoints, and ghost environment variables.

---

## The Most Shocking Finding

```typescript
// Generated by Cursor, file: src/routes/payment.ts
app.post('/api/payment/charge', async (req, res) => {
  const { amount, cardToken } = req.body;
  
  const charge = await stripe.charges.create({
    amount: amount * 100,
    currency: 'usd',
    source: cardToken,
  });
  
  res.json({ success: true, chargeId: charge.id });
});
```

**What's wrong?** No authentication. No authorization. Anyone can charge any amount to any card token. ESLint: âœ… passed. TypeScript: âœ… passed. Runtime: ğŸ’¥ disaster waiting to happen.

This endpoint was in a "production-ready" codebase generated by an AI coding assistant. The AI added Stripe integration, request handling, error responses â€” everything except the most critical piece: verifying who's making the request.

---

## The Experiment

We took 10 real-world prompts:
1. "Build a todo app with auth"
2. "Create a blog with user accounts"  
3. "E-commerce site with Stripe payments"
4. "Social media feed with likes/comments"
5. "API for file uploads to S3"
6. "Multi-tenant SaaS dashboard"
7. "Chat app with real-time messaging"
8. "Event booking system"
9. "CRM with contact management"
10. "Analytics dashboard with charts"

We fed each prompt to Cursor, GitHub Copilot (via Claude), and Codeium. We let the AI generate the full stack: frontend, backend, database schema, auth middleware.

Then we scanned each codebase with:
- **ESLint** (industry standard linter)
- **TypeScript** (`tsc --noEmit`, strict mode)
- **Semgrep** (SAST tool with security rules)
- **ISL Verify** (our new behavioral verification tool)

---

## The Results

| Category | Total Issues | ESLint | TypeScript | Semgrep | ISL Verify Only |
|----------|--------------|---------|------------|---------|-----------------|
| **Hallucinations** | 43 | 0 | 12 | 8 | 23 |
| **Security Gaps** | 156 | 41 | 0 | 67 | 48 |
| **Quality Issues** | 148 | 67 | 51 | 12 | 18 |
| **TOTAL** | 347 | 108 (31%) | 63 (18%) | 87 (25%) | 264 (76%) |

**Key finding:** Behavioral bugs (missing auth, unvalidated inputs, race conditions) are invisible to syntax-level tools.

---

## Category 1: Hallucinations (23 Unique to ISL Verify)

**Definition:** AI invents APIs, packages, or patterns that don't exist.

### Example 1: The Phantom Package
```typescript
// Generated code
import { validateEmail } from '@stripe/validators';  // âŒ doesn't exist

const isValid = validateEmail(req.body.email);
```

**What happened:** AI assumed Stripe has a validators package (it doesn't). Code compiles. TypeScript passes. Runtime: `MODULE_NOT_FOUND`.

**How ISL Verify caught it:** Import integrity prover checks package.json + node_modules. Reports: "Import '@stripe/validators' not found in dependencies."

### Example 2: The Ghost Environment Variable
```typescript
// Generated .env.example
DATABASE_URL=postgresql://localhost:5432/myapp
STRIPE_SECRET_KEY=sk_test_...

// Generated code (8 files later)
const redisUrl = process.env.REDIS_URL;  // âŒ not in .env.example
const cache = new Redis(redisUrl);
```

**What happened:** AI added Redis caching but forgot to add `REDIS_URL` to `.env.example`. Deploys to production, crashes on first cache access.

**How ISL Verify caught it:** Reality probe reads `.env.example`, compares to all `process.env.*` references. Reports: "Environment variable REDIS_URL referenced but not defined."

### Example 3: The Imaginary Middleware
```typescript
// AI-generated route
app.post('/api/users', requireAdmin, createUser);  // âŒ requireAdmin never defined
```

**What happened:** AI referenced `requireAdmin` middleware that it never created. TypeScript doesn't catch it (assumes it's defined elsewhere). Runtime: `requireAdmin is not defined`.

**How ISL Verify caught it:** Static analysis builds full symbol table. Reports: "Function 'requireAdmin' referenced but not defined."

---

## Category 2: Security Gaps (48 Unique to ISL Verify)

### Example 4: Missing Auth (18 occurrences)
```typescript
// Payment endpoint (no auth)
app.post('/api/payment/charge', async (req, res) => { ... });

// Admin endpoint (no auth)
app.delete('/api/users/:id', async (req, res) => { ... });

// File upload endpoint (no auth)
app.post('/api/upload', upload.single('file'), async (req, res) => { ... });
```

**Pattern:** AI generates routes but forgets auth middleware on 30% of sensitive endpoints.

**How ISL Verify caught it:** Auth coverage prover analyzes all routes, checks for auth middleware. Reports: "18/60 routes missing authentication (payment, admin, upload)."

### Example 5: SQL Injection (7 occurrences)
```typescript
// AI-generated query
const user = await db.query(
  `SELECT * FROM users WHERE email = '${req.body.email}'`  // âŒ SQL injection
);
```

**What happened:** AI used string interpolation instead of parameterized queries.

**How ESLint didn't catch it:** No rule for SQL injection (requires semantic analysis).

**How ISL Verify caught it:** SQL injection prover detects string templates in database queries. Reports: "7 SQL queries use string interpolation (injection risk)."

### Example 6: Unvalidated Inputs (23 occurrences)
```typescript
// AI-generated handler
app.post('/api/posts', async (req, res) => {
  const post = await db.posts.create({
    title: req.body.title,        // No validation
    content: req.body.content,    // No validation
    userId: req.body.userId,      // âŒ Trust user-supplied userId
  });
});
```

**What happened:** AI trusts all user inputs. No type validation. No length limits. No sanitization.

**How ISL Verify caught it:** Input validation prover checks all `req.body` access for validation. Reports: "23 endpoints accept unvalidated user input."

---

## Category 3: Quality Issues (18 Unique to ISL Verify)

### Example 7: Race Conditions (5 occurrences)
```typescript
// AI-generated async handler
app.post('/api/like', async (req, res) => {
  const post = await db.posts.findUnique({ where: { id: req.body.postId } });
  post.likes += 1;  // âŒ Read-modify-write race condition
  await db.posts.update({ where: { id: post.id }, data: { likes: post.likes } });
});
```

**What happened:** Concurrent requests can lose increments. ESLint/TypeScript can't detect async bugs.

**How ISL Verify caught it:** Property-based testing simulates concurrent requests. Reports: "Like counter loses updates under concurrent load."

### Example 8: Missing Error Handling (8 occurrences)
```typescript
// AI-generated async code
app.get('/api/posts/:id', async (req, res) => {
  const post = await db.posts.findUnique({ where: { id: req.params.id } });
  res.json(post);  // âŒ No error handling if post is null
});
```

**What happened:** AI assumes happy path. No try/catch. No null checks.

**How ISL Verify caught it:** Runtime verification calls endpoints with invalid IDs. Reports: "8 endpoints return 500 on invalid input (should return 404)."

---

## The Comparison Table

| Issue Type | ESLint | TypeScript | Semgrep | ISL Verify | Why Others Miss It |
|------------|--------|------------|---------|------------|-------------------|
| Missing semicolons | âœ… | âŒ | âŒ | âŒ | Syntax linting |
| Type mismatches | âŒ | âœ… | âŒ | âœ… | Type checking |
| Unused variables | âœ… | âœ… | âŒ | âœ… | Static analysis |
| SQL injection (pattern) | âŒ | âŒ | âœ… | âœ… | Requires semantic rules |
| SQL injection (runtime) | âŒ | âŒ | âŒ | âœ… | Requires execution |
| Missing auth | âŒ | âŒ | âš ï¸ | âœ… | Requires route analysis |
| Hallucinated imports | âŒ | âš ï¸ | âŒ | âœ… | Requires package validation |
| Ghost env vars | âŒ | âŒ | âŒ | âœ… | Requires cross-file analysis |
| Race conditions | âŒ | âŒ | âŒ | âœ… | Requires concurrent testing |
| Unvalidated inputs | âŒ | âŒ | âš ï¸ | âœ… | Requires runtime testing |

**Legend:**
- âœ… = Catches reliably
- âš ï¸ = Catches sometimes (if rules configured)
- âŒ = Doesn't catch

---

## So We Built ISL Verify

**Core idea:** Don't just lint the syntax. Verify the behavior.

### What it does:
1. **Static Analysis** (Import integrity, auth coverage, input validation)
2. **Runtime Testing** (API contracts, auth enforcement, error handling)
3. **Property-Based Testing** (Edge cases, concurrent requests, boundary conditions)
4. **Proof Bundle Generation** (Cryptographically signed evidence of what was checked)

### How it works:
```bash
npx isl-verify .
```

**Output:**
```
Scanning codebase...
  âœ… Import integrity: 47/47 imports verified
  âš ï¸ Auth coverage: 42/60 routes protected (18 missing auth)
  âŒ Input validation: 23 endpoints accept unvalidated input
  âœ… SQL injection: 0 vulnerabilities (5 queries parameterized)
  âš ï¸ Error handling: 8/60 endpoints return 500 on invalid input

Trust Score: 68/100
Verdict: NO_SHIP

Proof bundle saved to .shipgate/proof-bundle.json
```

### The Proof Bundle:

Every verification produces a signed JSON bundle:

```json
{
  "version": "2.0.0",
  "bundleId": "sha256:7f3e9a...",
  "timestamp": "2026-02-17T16:40:00Z",
  "trustScore": 68,
  "verdict": "NO_SHIP",
  "properties": [
    {
      "id": "auth-coverage",
      "name": "Auth Required on Protected Routes",
      "status": "partial",
      "confidence": 0.7,
      "evidence": [
        {
          "type": "static-analysis",
          "status": "failed",
          "description": "18 routes missing auth middleware",
          "files": [
            "src/routes/payment.ts:12",
            "src/routes/admin.ts:8",
            "src/routes/upload.ts:15"
          ]
        }
      ],
      "suggestion": "Add auth middleware to payment, admin, and upload routes"
    }
  ],
  "signature": "ed25519:a7b3c2..."
}
```

### Why this matters:

**For developers:** Know what was actually checked (not just "linter passed").

**For teams:** Audit trail of code quality decisions.

**For compliance:** Map verification to SOC 2, HIPAA, PCI-DSS controls.

---

## The Honest Alternative

Most tools optimize for low false positive rate. We optimize for **structured honesty**.

### Verification Surface: Declare Your Scope

Every proof bundle explicitly states what was checked and what wasn't:

```json
"verificationSurface": {
  "languages": ["typescript"],
  "frameworks": ["nextjs", "express"],
  "tiersRun": [1, 2],
  "propertiesVerified": [
    "import-integrity",
    "auth-coverage",
    "input-validation",
    "sql-injection"
  ],
  "explicitlyOutOfScope": [
    "rate-limiting",
    "csrf-protection",
    "business-logic-correctness"
  ]
}
```

### Residual Risk Ledger: Document the Gaps

Every unverified property becomes a documented risk:

```json
"residualRisks": [
  {
    "risk": "No rate limiting verified",
    "impact": "Potential abuse via repeated requests",
    "reasonNotVerified": "No generic static indicator",
    "recommendedMitigation": "Add express-rate-limit middleware",
    "owner": "Engineering",
    "status": "acknowledged",
    "severity": "medium"
  }
]
```

This turns limitations into **governance value**:
- Security teams: documented risk acceptance
- Auditors: explicit scope declaration
- Compliance: traceable mitigation steps

**If we didn't check it, we say so. If we checked it but couldn't prove it, we say so. Only mark PROVEN when we have evidence.**

---

## Try It

```bash
# Install
npm install -g isl-verify

# Scan your project
isl-verify .

# Generate compliance report
isl-verify . --compliance soc2 --output report.md

# VS Code extension
code --install-extension shipgate.shipgate-isl
```

---

## Roadmap

**Completed:**
- âœ… TypeScript/JavaScript support
- âœ… Verification Surface (structured scope declaration)
- âœ… Residual Risk Ledger (documented gaps)
- âœ… Proof bundle generation with Ed25519 signatures
- âœ… VS Code extension with inline evidence
- âœ… SOC 2 compliance mapping

**In Progress:**
- ğŸš§ Proof bundle diffing (`isl verify diff v1 v2`)
- ğŸš§ Historical trend analysis
- ğŸš§ Python support
- ğŸš§ HIPAA/PCI-DSS compliance reports

**Planned:**
- ğŸ“‹ Go/Rust support
- ğŸ“‹ Custom prover SDK
- ğŸ“‹ GitHub Action with policy enforcement

---

## Open Source

ISL Verify core is MIT licensed. Runtime provers and compliance reports are paid ($29/month).

**Why paid tiers?**
- Runtime verification requires compute (spinning up servers, running tests)
- Compliance reports require legal review and maintenance
- We need to fund development

**What's free forever:**
- Static analysis (import integrity, auth coverage, input validation)
- Proof bundle generation with verification surface
- Residual risk ledger
- VS Code extension
- Self-hosted verification
- Bundle diffing and history

---

## Conclusion

AI coding assistants are incredible productivity multipliers. But they're not infallible. They hallucinate. They forget auth. They skip validation.

The solution isn't to stop using AI. It's to verify the output.

**Every AI-generated PR should include a proof bundle.**

Not "LGTM from the AI." Not "ESLint passed." But verifiable evidence of what was checked, what passed, what failed, and what wasn't checked.

The honest alternative to "trust me, the AI is fine."

---

**Links:**
- GitHub: https://github.com/shipgate/shipgate
- Docs: https://shipgate.dev/docs
- VS Code Extension: https://marketplace.visualstudio.com/items?itemName=shipgate.shipgate-isl
- Benchmark Repo: https://github.com/shipgate/shipgate/tree/main/bench/ai-verify-benchmark

**Discussion:**
- Hacker News: [link]
- Reddit: r/programming [link]
- Twitter: @shipgate_dev

---

*Have you found behavioral bugs in AI-generated code that linters missed? Share your stories in the comments.*
